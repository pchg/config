" Probl√®mes √† r√©soudre:
" o BkSp ne fonctionne pas en mode insertion
" x Alt-H ne va pas √† gauche
" x √® en mode insertion va vers la gauche
let va1="oui"
let va2="oui"
let va3="oui"
let va4="oui"
let va5="oui"
let va55="oui"
" C'est √† ce va55 que se situe le probl√®me qui emp√™che de faire √® en mode insertion
let va6="oui"
let va7="oui"
let va8="oui"
let va9="oui"
let va10="oui"
let va11="oui"
let va12="oui"
let va13="oui"
let va14="oui"
let va15="oui"
let va16="oui"
let va17="oui"
let va18="oui"
" Les touches de fonctions avec des raccourcis (√† maintenir):
" F1  F2  F3  F4  F5  F6  F7  F8  F9  F10  F11  F12  F13  F14  F15  F16  F17  F18  F19  F20
" -   -   |   |   |   |   |   |   |    |    |    |   -    -    -    -    -    -    -    -
" F2  \_ (libre)
" F3      \_ ouvre une fen√™tre au-dessus avec l'occurrence pr√©c√©dente du mot sous le curseur
" F4          \_ (libre)
" F5              \_ sauver et faire tourner le fichier courant par rebol, ou plut√¥t par le shebang
" F6                  \_ faire tourner le paragraphe courant par rebol
" ctrl-F6             \_ faire tourner le paragraphe courant par python3
" shift-F6            \_ faire tourner le paragraphe courant par javascript
" ctrl-shift-F6       \_ faire tourner le paragraphe courant par une compilation de C et une ex√©cution
" F7                      \_ insertion de timestamp, comme dans le bon vieux ultraedit
" F8                          \_ faire tourner le paragraphe courant par bash
" F9                              \_ dict√©e du paragraphe en cours
" shift-F9                        \_ shift => idem en anglais
" F10                                  \_ correction orthographique du paragraphe courant
" F11                                       \_ aller √† l'√©tiquette _______________ENCOURS_______________ pr√©c√©dente
" F12                                            \_ derni√®re macro


" Pour le d√©bogage du pr√©sent f√©chier: " [[[[
" il faut faire:
" set foldmarker=[[[[,]]]]


" ]]]]

" Trucs bateau:
if va1 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[
" Des trucs assez bateau: "{{{

syntax on
set noautoindent
"set autoindent
set noerrorbells

set ignorecase
set ruler
set showmatch
set showmode

set hlsearch
set incsearch
set scrolloff=5
set mouse=a
set infercase

" changes special characters in search patterns (default)
" set magic
set esckeys            " Required to be able to use keypad keys and map missed escape sequences

" get easier to use and more user friendly vim defaults
" CAUTION: This option breaks some vi compatibility.
"          Switch it off if you prefer real vi compatibility
set nocompatible

" Complete longest common string, then each full match
" enable this for bash compatible behaviour
" set wildmode=longest,full


set history=10000
set encoding=utf-8
set fileencoding=utf-8


" Je ne sais trop ce que c'est que ceci:
set keymodel=startsel,stopsel


"Pour PAS ne pas recommencer la recherche au d√©but/fin du fichier:
"set nowrapscan
"Pour ne pas recommencer la recherche au d√©but/fin du fichier:
set wrapscan

"}}}
let salut="coucou1"
endif "@# fin de code d√©sactiv√© #############################################]]]]

" De vieux trucs avec des clefs:
if va2 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[
" Un tas de trucs h√©rit√©s d'un pass√© lointain, avec des machins li√©s au type de terminal: "{{{

" Try to get the correct main terminal type "{{{
if &term =~ "xterm"
    let myterm = "xterm"
else
    let myterm =  &term
endif
let myterm = substitute(myterm, "cons[0-9][0-9].*$",  "linux", "")
let myterm = substitute(myterm, "vt1[0-9][0-9].*$",   "vt100", "")
let myterm = substitute(myterm, "vt2[0-9][0-9].*$",   "vt220", "")
let myterm = substitute(myterm, "\\([^-]*\\)[_-].*$", "\\1",   "")
"}}}



" Here we define the keys of the NumLock in keyboard transmit mode of xterm "{{{
" which misses or hasn't activated Alt/NumLock Modifiers.  Often not defined
" within termcap/terminfo and we should map the character printed on the keys.
if myterm == "xterm" || myterm == "kvt" || myterm == "gnome"
    " keys in insert/command mode.
    noremap! <ESC>Oo  :
    noremap! <ESC>Oj  *
    noremap! <ESC>Om  -
    noremap! <ESC>Ok  +
    noremap! <ESC>Ol  ,
    noremap! <ESC>OM  
    noremap! <ESC>Ow  7
    noremap! <ESC>Ox  8
    noremap! <ESC>Oy  9
    noremap! <ESC>Ot  4
    noremap! <ESC>Ou  5
    noremap! <ESC>Ov  6
    noremap! <ESC>Oq  1
    noremap! <ESC>Or  2
    noremap! <ESC>Os  3
    noremap! <ESC>Op  0
    noremap! <ESC>On  .
    " keys in normal mode
    noremap <ESC>Oo  :
    noremap <ESC>Oj  *
    noremap <ESC>Om  -
    noremap <ESC>Ok  +
    noremap <ESC>Ol  ,
    noremap <ESC>OM  
    noremap <ESC>Ow  7
    noremap <ESC>Ox  8
    noremap <ESC>Oy  9
    noremap <ESC>Ot  4
    noremap <ESC>Ou  5
    noremap <ESC>Ov  6
    noremap <ESC>Oq  1
    noremap <ESC>Or  2
    noremap <ESC>Os  3
    noremap <ESC>Op  0
    noremap <ESC>On  .
endif
"}}}

" xterm but without activated keyboard transmit mode "{{{
" and therefore not defined in termcap/terminfo.
if myterm == "xterm" || myterm == "kvt" || myterm == "gnome"
    " keys in insert/command mode.
    noremap! <Esc>[H  <Home>
    noremap! <Esc>[F  <End>
    " Home/End: older xterms do not fit termcap/terminfo.
    noremap! <Esc>[1~ <Home>
    noremap! <Esc>[4~ <End>
    " Up/Down/Right/Left
    noremap! <Esc>[A  <Up>
    noremap! <Esc>[B  <Down>
    noremap! <Esc>[C  <Right>
    noremap! <Esc>[D  <Left>
    " KP_5 (NumLock off)
    noremap! <Esc>[E  <Insert>
    " PageUp/PageDown
    noremap <ESC>[5~ <PageUp>
    noremap <ESC>[6~ <PageDown>
    noremap <ESC>[5;2~ <PageUp>
    noremap <ESC>[6;2~ <PageDown>
    noremap <ESC>[5;5~ <PageUp>
    noremap <ESC>[6;5~ <PageDown>
    " keys in normal mode
    noremap <ESC>[H  0
    noremap <ESC>[F  $
    " Home/End: older xterms do not fit termcap/terminfo.
    noremap <ESC>[1~ 0
    noremap <ESC>[4~ $
    " Up/Down/Right/Left
    noremap <ESC>[A  k
    noremap <ESC>[B  j
    noremap <ESC>[C  l
    noremap <ESC>[D  h
    " KP_5 (NumLock off)
    noremap <ESC>[E  i
    " PageUp/PageDown
    noremap <ESC>[5~ 
    noremap <ESC>[6~ 
    noremap <ESC>[5;2~ 
    noremap <ESC>[6;2~ 
    noremap <ESC>[5;5~ 
    noremap <ESC>[6;5~ 
endif
"}}}

" xterm/kvt but with activated keyboard transmit mode. "{{{
" Sometimes not or wrong defined within termcap/terminfo.
if myterm == "xterm" || myterm == "kvt" || myterm == "gnome"
    " keys in insert/command mode.
    noremap! <Esc>OH <Home>
    noremap! <Esc>OF <End>
    noremap! <ESC>O2H <Home>
    noremap! <ESC>O2F <End>
    noremap! <ESC>O5H <Home>
    noremap! <ESC>O5F <End>
    " Cursor keys which works mostly
    " map! <Esc>OA <Up>
    " map! <Esc>OB <Down>
    " map! <Esc>OC <Right>
    " map! <Esc>OD <Left>
    noremap! <Esc>[2;2~ <Insert>
    noremap! <Esc>[3;2~ <Delete>
    noremap! <Esc>[2;5~ <Insert>
    noremap! <Esc>[3;5~ <Delete>
    noremap! <Esc>O2A <PageUp>
    noremap! <Esc>O2B <PageDown>
    noremap! <Esc>O2C <S-Right>
    noremap! <Esc>O2D <S-Left>
    noremap! <Esc>O5A <PageUp>
    noremap! <Esc>O5B <PageDown>
    noremap! <Esc>O5C <S-Right>
    noremap! <Esc>O5D <S-Left>
    " KP_5 (NumLock off)
    noremap! <Esc>OE <Insert>
    " keys in normal mode
    noremap <ESC>OH  0
    noremap <ESC>OF  $
    noremap <ESC>O2H  0
    noremap <ESC>O2F  $
    noremap <ESC>O5H  0
    noremap <ESC>O5F  $
    " Cursor keys which works mostly
    " map <ESC>OA  k
    " map <ESC>OB  j
    " map <ESC>OD  h
    " map <ESC>OC  l
    noremap <Esc>[2;2~ i
    noremap <Esc>[3;2~ x
    noremap <Esc>[2;5~ i
    noremap <Esc>[3;5~ x
    noremap <ESC>O2A  ^B
    noremap <ESC>O2B  ^F
    noremap <ESC>O2D  b
    noremap <ESC>O2C  w
    noremap <ESC>O5A  ^B
    noremap <ESC>O5B  ^F
    noremap <ESC>O5D  b
    noremap <ESC>O5C  w
    " KP_5 (NumLock off)
    noremap <ESC>OE  i
endif
"}}}

" tmux stuff:{{{
" https://stackoverflow.com/questions/15445481/mapping-arrow-keys-when-running-tmux

" Vim knows that xterm-like terminals (identified by TERM starting with xterm, or a particular response to the t_RV sequence, if it is defined) support extended sequences for certain modified keys, but it does not assume this for screen TERMs (which you should be using under tmux).
" 
" You can, however tell Vim about these sequences and enable them if TMUX is present, and TERM starts with screen (the first lines enable (better) mouse support under tmux, which you might also like):

if &term =~ '^screen' && exists('$TMUX')
    set mouse+=a
    " tmux knows the extended mouse mode
    set ttymouse=xterm2
    " tmux will send xterm-style keys when xterm-keys is on
    execute "set <xUp>=\e[1;*A"
    execute "set <xDown>=\e[1;*B"
    execute "set <xRight>=\e[1;*C"
    execute "set <xLeft>=\e[1;*D"
    execute "set <xHome>=\e[1;*H"
    execute "set <xEnd>=\e[1;*F"
    execute "set <Insert>=\e[2;*~"
    execute "set <Delete>=\e[3;*~"
    execute "set <PageUp>=\e[5;*~"
    execute "set <PageDown>=\e[6;*~"
    execute "set <xF1>=\e[1;*P"
    execute "set <xF2>=\e[1;*Q"
    execute "set <xF3>=\e[1;*R"
    execute "set <xF4>=\e[1;*S"
    execute "set <F5>=\e[15;*~"
    execute "set <F6>=\e[17;*~"
    execute "set <F7>=\e[18;*~"
    execute "set <F8>=\e[19;*~"
    execute "set <F9>=\e[20;*~"
    execute "set <F10>=\e[21;*~"
    execute "set <F11>=\e[23;*~"
    execute "set <F12>=\e[24;*~"
endif

" As the comment indicates, you also need to have the window‚Äôs xterm-keys option enabled. You can do this for all your windows like this (in your ~/.tmux.conf):

" set-option -gw xterm-keys on



"}}}



" Tentative (annul√©e) pour faire fonctionner <C-j> dans vim dans screen: "{{{
" En suivant les conseils de https://vim.fandom.com/wiki/GNU_Screen_integration :
" if match($TERM, "screen")!=-1
"   " On est dans un screen
"   set term=xterm
"   map [1~ <Home>
"   " Tentative de remapper Ctrl-j:
"   "noremap   <C-j>
"   " => ne fonctionne pas
"   let g:GNU_Screen_used = 1
" else
"   " Hors screen
"   map OH <Home>
"   let g:GNU_Screen_used = 0
" endif
"}}}


if myterm == "linux"
    " keys in insert/command mode.
    noremap! <Esc>[G  <Insert>
    " KP_5 (NumLock off)
    " keys in normal mode
    " KP_5 (NumLock off)
    noremap <ESC>[G  i
endif

" " This escape sequence is the well known ANSI sequence for
" " Remove Character Under The Cursor (RCUTC[tm])
" noremap! <Esc>[3~ <Delete>
" noremap  <ESC>[3~    x


"}}}
let salut="coucou2"
endif "@# fin de code d√©sactiv√© #############################################]]]]

" Leader
if va3 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[
" La leader key: espace, au lieu de l'abscon et malpratique \: "{{{
nnoremap <Space> <Nop>
let mapleader = " "         " map leader to Space
let mapleader = "\<Space>"  "map leader to Space
set timeoutlen=500          " Set timeout length to 500 ms
set showcmd "Vim, by default, shows no feedback for this timeout length. Add set showcmd to your vimrc and it will show your leader key in the bottom right corner for the duration of the timeout.



" Nota Bene: pour highlighter les mots sous le curseur avec 123456789,
" il faut faire <leader>m
" puis <leader>1 ou 2 ... sur le mot choisi
"}}}


" Pour les folds^Wreplis ch√©ris: "{{{

set foldmethod=marker
set fdc=5
set foldclose=all

" pour se d√©placer dans les replis: "{{{
" https://stackoverflow.com/questions/9403098/is-it-possible-to-jump-to-the-next-closed-fold-in-vim
"
" In Vim, I often find myself wanting to do a quick zk or zj to jump to the previous or next fold in a file. The problem is, I frequently want to skip all the open folds, and just jump to the nearest closed fold.
" Is there a way to do this? I see no built-in keymap in the help.
"
"=>
" Let me propose the following implementation of the described behavior.
nnoremap <silent> <leader>zj :call NextClosedFold('j')<cr>
nnoremap <silent> <leader>zk :call NextClosedFold('k')<cr>

function! NextClosedFold(dir)
    let cmd = 'norm!z'..a:dir
    let view = winsaveview()
    let [l0, l, open] = [0, view.lnum, 1]
    while l != l0 && open
        exe cmd
        let [l0, l] = [l, line('.')]
        let open = foldclosed(l) < 0
    endwhile
    if open
        call winrestview(view)
    endif
endfunction

" If it is desirable for the mappings to accept a count for the number of repetitions of the corresponding movement, one can implement a simple function for repeating any given command:

function! RepeatCmd(cmd) range abort
    let n = v:count < 1 ? 1 : v:count
    while n > 0
        exe a:cmd
        let n -= 1
    endwhile
endfunction

" and then redefine the above mappings as follows:
nnoremap <silent> <leader>zj :<c-u>call RepeatCmd('call NextClosedFold("j")')<cr>
nnoremap <silent> <leader>zk :<c-u>call RepeatCmd('call NextClosedFold("k")')<cr>

"}}}

"Pour √¥ter les /* */ disgr√¢cieux de mes folds {{{ }}} ou [ ]
set commentstring=%s

"}}}


" Pour commenter des lignes: "{{{

" pour commenter une ligne de code Rebol et passer √† la suivante:
noremap ; ^i;<Space><Esc><Down>

"pour commenter une ligne de code, genre shell script, par # , puis passer √† la suivante:
"noremap &; <Home>i#<Esc><Down>
" => marche pas...
noremap ¬£ ^i#<Space><Esc><Down>

" pour commenter une ligne de code SQL et passer √† la suivante:
noremap - ^i--<Space><Esc><Down><Home>

" pour commenter une ligne de code vim et passer √† la suivante:
noremap " ^i"<Space><Esc><Down><Home>

" enfin, pour d√©commenter une ligne en supprimant les 2 premiers caract√®res (√ßa laissera une espace pour le SQL: bof, osef):
noremap ¬µ ^<Del><Del><Down><Home>


" 2023_07_25__18_32_28 je fais plut√¥t une fonction, pour trouver s'il n'y a pas des espaces en d√©but de ligne et pr√©server ainsi une indentation:
"function! CommentLine(commentstring)
"    "check if at beginning of line or after a space
"    if strpart(getline('.'), 0, col('.')-1) =~ '^\s*$'
"    return "w
"endfunction

" " Plut√¥t, je recopie un plugin, commentary: "{{{ "" => annul√©
"
" " https://github.com/tpope/vim-commentary/blob/master/plugin/commentary.vim
"
"
" " commentary.vim - Comment stuff out
" " Maintainer:   Tim Pope <http://tpo.pe/>
" " Version:      1.3
" " GetLatestVimScripts: 3695 1 :AutoInstall: commentary.vim
"
" if exists("g:loaded_commentary") || v:version < 703
"   finish
" endif
" let g:loaded_commentary = 1
"
" function! s:surroundings() abort
"   return split(get(b:, 'commentary_format', substitute(substitute(substitute(
"         \ &commentstring, '^$', '%s', ''), '\S\zs%s',' %s', '') ,'%s\ze\S', '%s ', '')), '%s', 1)
" endfunction
"
" function! s:strip_white_space(l,r,line) abort
"   let [l, r] = [a:l, a:r]
"   if l[-1:] ==# ' ' && stridx(a:line,l) == -1 && stridx(a:line,l[0:-2]) == 0
"     let l = l[:-2]
"   endif
"   if r[0] ==# ' ' && (' ' . a:line)[-strlen(r)-1:] != r && a:line[-strlen(r):] == r[1:]
"     let r = r[1:]
"   endif
"   return [l, r]
" endfunction
"
" function! s:go(...) abort
"   if !a:0
"     let &operatorfunc = matchstr(expand('<sfile>'), '[^. ]*$')
"     return 'g@'
"   elseif a:0 > 1
"     let [lnum1, lnum2] = [a:1, a:2]
"   else
"     let [lnum1, lnum2] = [line("'["), line("']")]
"   endif
"
"   let [l, r] = s:surroundings()
"   let uncomment = 2
"   let force_uncomment = a:0 > 2 && a:3
"   for lnum in range(lnum1,lnum2)
"     let line = matchstr(getline(lnum),'\S.*\s\@<!')
"     let [l, r] = s:strip_white_space(l,r,line)
"     if len(line) && (stridx(line,l) || line[strlen(line)-strlen(r) : -1] != r)
"       let uncomment = 0
"     endif
"   endfor
"
"   if get(b:, 'commentary_startofline')
"     let indent = '^'
"   else
"     let indent = '^\s*'
"   endif
"
"   let lines = []
"   for lnum in range(lnum1,lnum2)
"     let line = getline(lnum)
"     if strlen(r) > 2 && l.r !~# '\\'
"       let line = substitute(line,
"             \'\M' . substitute(l, '\ze\S\s*$', '\\zs\\d\\*\\ze', '') . '\|' . substitute(r, '\S\zs', '\\zs\\d\\*\\ze', ''),
"             \'\=substitute(submatch(0)+1-uncomment,"^0$\\|^-\\d*$","","")','g')
"     endif
"     if force_uncomment
"       if line =~ '^\s*' . l
"         let line = substitute(line,'\S.*\s\@<!','\=submatch(0)[strlen(l):-strlen(r)-1]','')
"       endif
"     elseif uncomment
"       let line = substitute(line,'\S.*\s\@<!','\=submatch(0)[strlen(l):-strlen(r)-1]','')
"     else
"       let line = substitute(line,'^\%('.matchstr(getline(lnum1),indent).'\|\s*\)\zs.*\S\@<=','\=l.submatch(0).r','')
"     endif
"     call add(lines, line)
"   endfor
"   call setline(lnum1, lines)
"   let modelines = &modelines
"   try
"     set modelines=0
"     silent doautocmd User CommentaryPost
"   finally
"     let &modelines = modelines
"   endtry
"   return ''
" endfunction
"
" function! s:textobject(inner) abort
"   let [l, r] = s:surroundings()
"   let lnums = [line('.')+1, line('.')-2]
"   for [index, dir, bound, line] in [[0, -1, 1, ''], [1, 1, line('$'), '']]
"     while lnums[index] != bound && line ==# '' || !(stridx(line,l) || line[strlen(line)-strlen(r) : -1] != r)
"       let lnums[index] += dir
"       let line = matchstr(getline(lnums[index]+dir),'\S.*\s\@<!')
"       let [l, r] = s:strip_white_space(l,r,line)
"     endwhile
"   endfor
"   while (a:inner || lnums[1] != line('$')) && empty(getline(lnums[0]))
"     let lnums[0] += 1
"   endwhile
"   while a:inner && empty(getline(lnums[1]))
"     let lnums[1] -= 1
"   endwhile
"   if lnums[0] <= lnums[1]
"     execute 'normal! 'lnums[0].'GV'.lnums[1].'G'
"   endif
" endfunction
"
" command! -range -bar -bang Commentary call s:go(<line1>,<line2>,<bang>0)
" xnoremap <expr>   <Plug>Commentary     <SID>go()
" nnoremap <expr>   <Plug>Commentary     <SID>go()
" nnoremap <expr>   <Plug>CommentaryLine <SID>go() . '_'
" onoremap <silent> <Plug>Commentary        :<C-U>call <SID>textobject(get(v:, 'operator', '') ==# 'c')<CR>
" nnoremap <silent> <Plug>ChangeCommentary c:<C-U>call <SID>textobject(1)<CR>
" nmap <silent> <Plug>CommentaryUndo :echoerr "Change your <Plug>CommentaryUndo map to <Plug>Commentary<Plug>Commentary"<CR>
"
" if !hasmapto('<Plug>Commentary') || maparg('gc','n') ==# ''
"   xmap gc  <Plug>Commentary
"   nmap gc  <Plug>Commentary
"   omap gc  <Plug>Commentary
"   nmap gcc <Plug>CommentaryLine
"   nmap gcu <Plug>Commentary<Plug>Commentary
" endif
"
" " vim:set et sw=2:
"
"}}}

"}}}


" Syntaxe: "{{{

"syntaxe Rebol:
set syntax=rebol
"aussit√¥t d√©sactiv√©e:
set syntax=none
"=> c'est pour avoir les compl√©tions judicieuses, les mots avec des - vus comme un seul mot (ce qui est commode), mais sans avoir les couleurs (qui n'aident pas forc√©ment beaucoup).

"}}}


" Couleurs pour vimdiff: "{{{

" Des couleurs de vimdiff un peu plus humainement lisibles pour un presse-b!t3:
highlight DiffAdd    ctermbg=6
highlight DiffChange ctermbg=2
highlight DiffDelete ctermbg=6
highlight DiffText   ctermfg=1 ctermbg=2 cterm=bold

" Toujours dans le cadre d'un vimdiff, passer √† la ligne et ne pas coloriser la syntaxe:
if &diff
    syntax off
    " essay√© tout √ßa, sans succ√®s: "{{{
    "execute 'set wrap'
    ""set wrap
    "execute 'windo set wrap'
    "autocmd FilterWritePre * if &diff | setlocal wrap< | endif
    "}}}
    set wrap
    " Pour ignorer les espaces (utile quand collage de codes divers...)
    " set diffopt+=iwhite
    " set diffexpr=""
endif

"}}}


" Remappage de touches diverses: "{{{

" Pour coller rapidement en passant par xclip, au lieu d'avoir des caract√®res √† la noix quand on colle: "{{{
nnoremap <C-Insert>         :r !xclip -o<cr>
inoremap <C-Insert>  <Esc>mz:r !xclip -o<cr>`zi
" vnoremap <C-Insert>        x:r !xclip -o<cr>
" non, ce dernier est stupide, dans la mesure o√π la s√©lection (chez un vim
" bien √©lev√©) est d√©j√† dans le presse-papiers de X...

"}}}

" T√©, pour naviguer dans les tampons (buffers): "{{{
nnoremap <Leader>b :buffers<cr>:buffer<Space>
"}}}


"}}}
let salut="coucou3"
endif "@# fin de code d√©sactiv√© #############################################]]]]

" Ctrl-fl√®ches et Ctrl-jk pour d√©placer les lignes: 
if va4 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[
" Ctrl-fl√®ches et Ctrl-jk pour d√©placer les lignes: "{{{

"Ctrl-jk pour faire pareil: (marche pas...) => 2020_07_09__12_13_32 en fait, si on met les lignes map <S-C-k> avant, ce sont elles qui prennent le pas sur les lignes map <C-k>, curieusement. √áa ne le fait pas pour les <C-Fl√®ches, c'est √©trange. => 2023_07_25__18_21_51 √ßa fonctionne. => 2023_07_26__13_01_35 √ßa fonctionne, mais pas dans un screen... => 2023_08_30__18_23_19 √ßa fonctionne, mais pas dans un tmux...
" let g:C_Ctrl_j = 'off'

" nnoremap < > <C-j>
" nnoremap <> <C-k>
nnoremap <C-j>      ddp
noremap  <C-j>      ddp
inoremap <C-j> <Esc>ddpi
nnoremap <C-k>      ddkP
noremap  <C-k>      ddkP
inoremap <C-k> <Esc>ddkPi

if empty($TMUX)
  " nnoremap <A-j> :echo "Pas dans TMUX!"<cr>
  " nnoremap <C-j> :echo "Pas dans TMUX!"<cr>
  nnoremap <C-j>  ddp
else
  " nnoremap <A-j> :echo " dans TMUX!"<cr>
  " nnoremap <C-j> :echo " dans TMUX!"<cr>
  " noremap <C- > :echo "Dans TMUX!"<cr>
  " let g:C_Ctrl_j = 'off'
endif

"Ctrl-fl√®ches pour d√©placer les lignes, comme dans oOo: "{{{

"nnoremap <C-Up> ddkp <CR>    "DONE marche pas => si, ainsi:
"map <C-Up> ddkP
"map <C-Down> ddp
"inoremap <C-Up>   <Esc>ddkPi
"inoremap <C-Down> <Esc>ddpi

" Autre version, trouv√©e dans http://www.billodom.com/talks/vim-key-mapping.pdf: plus efficace, marche avec des s√©lections, en les gardant:
"nnoremap <silent> <C-Up> :move -2<CR>
"nnoremap <silent> <C-Down> :move +<CR>
"xnoremap <silent> <C-Up> :move '<-2<CR>gv
"xnoremap <silent> <C-Down> :move '>+<CR>gv
"imap <silent> <C-Up> <C-O><C-Up>
"imap <silent> <C-Down> <C-O><C-Down>
"smap <silent> <C-Up> <C-G><C-Up><C-G>
"smap <silent> <C-Down> <C-G><C-Down><C-G>

"Encore une autre version, en essayant d'am√©liorer, pour faire comme avant, notamment en bougeant les blocs z:
"nnoremap <C-Up> ddkp <CR>    "DONE marche pas => si, ainsi:
"map <C-Up> ddkP
"map <C-Down> ddp
"inoremap <C-Up>   <Esc>ddkPi
"inoremap <C-Down> <Esc>ddpi

nnoremap <silent> <C-Up>        ddkP
inoremap <silent> <C-Up>   <Esc>ddkPi
xnoremap <silent> <C-Up>        :move '<-2<CR>gv
nnoremap <silent> <C-Down>      ddp
inoremap <silent> <C-Down> <Esc>ddpi
xnoremap <silent> <C-Down>      :move '>+<CR>gv

"}}}


"}}}

" Shift-Ctrl-fl√®ches et Shift-Ctrl-jk pour d√©filer: "{{{
" Shift-Ctrl-fl√®ches pour d√©filer (scroller) de 5 lignes:
noremap  <S-C-Up>        5<C-y>
inoremap <S-C-Up>   <Esc>5<C-y>i
noremap  <S-C-Down>      5<C-e>
inoremap <S-C-Down> <Esc>5<C-e>i


" Shift-Ctrl-jk pour d√©filer (scroller) de 3 lignes:
noremap  <S-C-k>        3<C-y>
inoremap <S-C-k>   <Esc>3<C-y>i
noremap  <S-C-j>        3<C-e>
inoremap <S-C-j>   <Esc>3<C-e>i

"}}}
let salut="coucou4"
endif "@# fin de code d√©sactiv√© #############################################]]]]

if va5 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[
" Navigation entre fen√™tres avec Alt-fl√®ches et Alt-hjkl: "{{{

" Pour vivre avec tmux, voir 2023_10_01__20_32_50


" " Alt-fl√®ches pour naviguer entre les fen√™tres, √† la mode de chez terminator: "{{{
" " 2023_08_28__12_36_18 Annul√©, pour le tmux_navigator, voir √† cet autre horodatage
" noremap  <A-Up>         :wincmd k<cr>
" noremap  <A-Down>       :wincmd j<cr>
" noremap  <A-Left>       :wincmd h<cr>
" noremap  <A-Right>      :wincmd l<cr>
" inoremap <A-Up>    <esc>:wincmd k<cr>i
" inoremap <A-Down>  <esc>:wincmd j<cr>i
" inoremap <A-Left>  <esc>:wincmd h<cr>i
" inoremap <A-Right> <esc>:wincmd l<cr>i
"
" "Alt-hjkl pour naviguer de m√™me:
" noremap <A-k>           :wincmd k<cr>
" noremap <A-j>           :wincmd j<cr>
" noremap <A-h>           :wincmd h<cr>
" noremap <A-l>           :wincmd l<cr>
" " inoremap <A-k>   <Esc>mz:wincmd k<cr>`zi
" " inoremap <A-j>   <Esc>mz:wincmd j<cr>`zi
" " inoremap <A-h>   <Esc>mz:wincmd h<cr>`zi
" " inoremap <A-l>   <Esc>mz:wincmd l<cr>`zi
" " => annul√© les 4 derni:wincmd h
" " res lignes, car voil√† ce qu'elles induisaient, m:wincmd j
" " me si l'on n'√©tait pas dans un screen...
" 2023_08_28__12_36_18


" if empty($TMUX)
"     " Touches captur√©es dans vim SANS tmux avec C-V:
"     " 
"     "  
"     " 
"     " 
"     noremap  <A-Up>         :TmuxNavigateUp<cr>
"     noremap  <A-Down>       :TmuxNavigateDown<cr>
"     noremap  <A-Left>       :TmuxNavigateLeft<cr>
"     noremap  <A-Right>      :TmuxNavigateRight<cr>
"     inoremap <A-Up>    <esc>:TmuxNavigateUp<cr>i
"     inoremap <A-Down>  <esc>:TmuxNavigateDown<cr>i
"     inoremap <A-Left>  <esc>:TmuxNavigateLeft<cr>i
"     inoremap <A-Right> <esc>:TmuxNavigateRight<cr>i
"     "Alt-hjkl pour naviguer de m√™me:
"     noremap  <A-k>          :TmuxNavigateUp<cr>
"     noremap  <A-j>          :TmuxNavigateDown<cr>
"     noremap  <A-h>          :TmuxNavigateLeft<cr>
"     noremap  <A-l>          :TmuxNavigateRight<cr>
"     inoremap <A-k>   <Esc>mz:TmuxNavigateUp<cr>`zi
"     inoremap <A-j>   <Esc>mz:TmuxNavigateDown<cr>`zi
"     inoremap <A-h>   <Esc>mz:TmuxNavigateLeft<cr>`zi
"     inoremap <A-l>   <Esc>mz:TmuxNavigateRight<cr>`zi
" else
"     " Touches captur√©es dans vim dans tmux avec C-V:
"     " k
"     " j
"     " h
"     " l
"     " Ah b√© si je refais √ßa, c'est diff√©rent: ???
"     " √™
"     " √´
"     " √®
"     " √¨
"     " => √† ne SURTOUT pas mettre en inoremap...
"     " TODO v√©rifier que tout aille bien avec les fl√®ches
"     noremap  k          :TmuxNavigateUp<cr>
"     noremap  j          :TmuxNavigateDown<cr>
"     noremap  h          :TmuxNavigateLeft<cr>
"     noremap  l          :TmuxNavigateRight<cr>
"     inoremap k     <esc>:TmuxNavigateUp<cr>i
"     inoremap j     <esc>:TmuxNavigateDown<cr>i
"     inoremap h     <esc>:TmuxNavigateLeft<cr>i
"     inoremap l     <esc>:TmuxNavigateRight<cr>i
"     "Alt-hjkl pour naviguer de m√™me:
"     noremap  k          :TmuxNavigateUp<cr>
"     noremap  j          :TmuxNavigateDown<cr>
"     noremap  h          :TmuxNavigateLeft<cr>
"     noremap  l          :TmuxNavigateRight<cr>
"     inoremap k   <Esc>mz:TmuxNavigateUp<cr>`zi
"     inoremap j   <Esc>mz:TmuxNavigateDown<cr>`zi
"     inoremap h   <Esc>mz:TmuxNavigateLeft<cr>`zi
"     inoremap l   <Esc>mz:TmuxNavigateRight<cr>`zi
"     "Alt-hjkl pour naviguer de m√™me, avec l'autre mappage dans tmux (??), SANS le mode insertion:
"     noremap  √™            :TmuxNavigateUp<cr>
"     noremap  √´            :TmuxNavigateDown<cr>
"     noremap  √®            :TmuxNavigateLeft<cr>
"     noremap  √¨            :TmuxNavigateRight<cr>
" endif



" Pareil, avec les touches telles que re√ßues dans le xterm en regardant avec
" sed -n l
"  nnoremap √´ :wincmd k<cr>
"  nnoremap √™ :wincmd j<cr>
"  nnoremap √® :wincmd h<cr>
"  nnoremap √¨ :wincmd l<cr>
" Cela ne fonctionne pas en mode insertion, bien s√ªr.
" => mais si!! √áa prend le pas et √ßa marque :wincmd h quand on tape sur la touche e avec accent grave!! => annul√©!


" # => √ßa ne fonctionne point...


"}}}
let salut="coucou5"
endif "@# fin de code d√©sactiv√© #############################################]]]]


if va55 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[
" # Autre essai, selon https://www.codeography.com/2013/06/19/navigating-vim-and-tmux-splits : "{{{

if exists('$TMUX')
  function! TmuxOrSplitSwitch(wincmd, tmuxdir)
    let previous_winnr = winnr()
    silent! execute "wincmd " . a:wincmd
    if previous_winnr == winnr()
      call system("tmux select-pane -" . a:tmuxdir)
      redraw!
    endif
  endfunction

  let previous_title = substitute(system("tmux display-message -p '#{pane_title}'"), '\n', '', '')
  let &t_ti = "\<Esc>]2;vim\<Esc>\\" . &t_ti
  let &t_te = "\<Esc>]2;". previous_title . "\<Esc>\\" . &t_te

  nnoremap <silent> <A-h>          :call TmuxOrSplitSwitch('h', 'L')<cr>
  nnoremap <silent> <A-j>          :call TmuxOrSplitSwitch('j', 'D')<cr>
  nnoremap <silent> <A-k>          :call TmuxOrSplitSwitch('k', 'U')<cr>
  nnoremap <silent> <A-l>          :call TmuxOrSplitSwitch('l', 'R')<cr>

" C'est √† la ligne suivante que se situe le probl√®me qui emp√™che de faire √® en mode insertion ###
  inoremap <silent> <A-h>     <esc>:call TmuxOrSplitSwitch('h', 'L')<cr>i
  inoremap <silent> <A-j>     <esc>:call TmuxOrSplitSwitch('j', 'D')<cr>i inoremap <silent> <A-k>     <esc>:call TmuxOrSplitSwitch('k', 'U')<cr>i
  inoremap <silent> <A-l>     <esc>:call TmuxOrSplitSwitch('l', 'R')<cr>i


  nnoremap <silent> <A-Left>       :call TmuxOrSplitSwitch('h', 'L')<cr>
  nnoremap <silent> <A-Down>       :call TmuxOrSplitSwitch('j', 'D')<cr>
  nnoremap <silent> <A-Up>         :call TmuxOrSplitSwitch('k', 'U')<cr>
  nnoremap <silent> <A-Right>      :call TmuxOrSplitSwitch('l', 'R')<cr>

  inoremap <silent> <A-Left>  <esc>:call TmuxOrSplitSwitch('h', 'L')<cr>i
  inoremap <silent> <A-Down>  <esc>:call TmuxOrSplitSwitch('j', 'D')<cr>i
  inoremap <silent> <A-Up>    <esc>:call TmuxOrSplitSwitch('k', 'U')<cr>i
  inoremap <silent> <A-Right> <esc>:call TmuxOrSplitSwitch('l', 'R')<cr>i

else
  "2023_12_16__19_47_21 
  " D√©plac√© vers .vim/vimrc_else.vim
  " => rapatri√©, avec des tests infructueux pour essayer avec Meta au lieu de Alt, en appelant la fonction Bonjour, pour voir:
  " nnoremap <M-h>                   :Bonjour h<cr>
  nnoremap <A-h>                   :wincmd h<cr>
  nnoremap <A-j>                   :wincmd j<cr>
  nnoremap <A-k>                   :wincmd k<cr>
  nnoremap <A-l>                   :wincmd l<cr>

  nnoremap <A-Left>                :wincmd h<cr>
  nnoremap <A-Down>                :wincmd j<cr>
  nnoremap <A-Up>                  :wincmd k<cr>
  nnoremap <A-Right>               :wincmd l<cr>


" C'est √† la ligne suivante que se situe le probl√®me qui emp√™che de faire √® en mode insertion ###
  " inoremap <M-h>              <esc>:Bonjour h<cr>i
  inoremap <A-h>              <esc>:wincmd h<cr>i inoremap <A-j>              <esc>:wincmd j<cr>i inoremap <A-k>              <esc>:wincmd k<cr>i
  inoremap <A-l>              <esc>:wincmd l<cr>i

  inoremap <A-Left>           <esc>:wincmd h<cr>i
  inoremap <A-Down>           <esc>:wincmd j<cr>i
  inoremap <A-Up>             <esc>:wincmd k<cr>i
  inoremap <A-Right>          <esc>:wincmd l<cr>i

" source $HOME/.vim/vimrc_else.vim
endif


"}}}

"}}}
let salut="coucou55"
endif "@# fin de code d√©sactiv√© #############################################]]]]

if va6 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[
" Compl√©tion par tabulation: √† partir d'un vimrc trouv√© sur la Toile: "{{{
""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""
" Fichier .vimrc de Nicolas Gressier
" Cr√©√© le 11 mai 2006
" Yoshidu62@gmail.com
" Mise √† jour : 03/06/2009
" Version 2.6
""""""""""""""""""""""""""""""""""""""""""""""""""
"Compl√©tion par tabulation: "{{{
""""""""""""""""""""""""""""""""""""""""""""""""""
function! CleverTab()
    "check if at beginning of line of after a space
    if strpart(getline('.'), 0, col('.')-1) =~ '^\s*$'
    return "\<Tab>"
    else
    "use know-word completion
    "return "\<C-N>"
    "use know-word completion, mais plut√¥t √† l'envers
    return "\<C-P>"
    endif
endfunction

function! CleverTabShift()
    "check if at beginning of line or after a space
    if strpart(getline('.'), 0, col('.')-1) =~ '^\s*$'
    return "\<S-Tab>"
    else
    "use known-word completion, √† l'endroit
    return "\<C-N>"
    endif
endfunction

"Mapping sur la touche Tab
inoremap <Tab> <C-R>=CleverTab()<CR>

"et pareil sur la combinaison de touches Shift Tab:
inoremap <S-Tab> <C-R>=CleverTabShift()<CR>
"}}}

"}}}
let salut="coucou6"
endif "@# fin de code d√©sactiv√© #############################################]]]]

if va7 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[
" Ctrl-Tab pour naviguer entre les fen√™tres (bof, peu usit√©, abandonn√© le 2022_03_24__18_26_16 avec un " devant): "{{{

" " MARCHE PAS :
" map <C-Tab> <C-w><C-w>
" 2023_08_03__18_30_38 => si, √ßa fonctionne, mais √ßa n'est pas ce que je souhaite


" "Marche =>
" " http://stackoverflow.com/questions/2686766/mapping-c-tab-in-my-vimrc-fails-in-ubuntu
" " ...
" " Put this in your .vimrc:

" " !! Important - instead of XXXX you must type CTRL-V and then Esc OR copy-paste the whole text and run %s/\(set <F1[34]>=\)XXXX/\=submatch(1) . "\33"/g which is copy-pastable (insert it with <CTRL-R> +).
" set timeout timeoutlen=1000 ttimeoutlen=100
" set <F13>=[27;5;9~
" "nnoremap <F13> gt
" map <F13> <C-w><C-w>
" set <F14>=[27;6;9~
" "nnoremap <F14> gT
" "map <F14> :tabNext<CR>
" map <F14> <C-w><S-w>
" "And restart vim.
" "Done.
" " Pareil, pour le mode insertion (c'est quand m√™me commode):
" inoremap <F13> <Esc><C-w><C-w>i
" inoremap <F14> <Esc><C-w><S-w>i

"}}}
let salut="coucou7"
endif "@# fin de code d√©sactiv√© #############################################]]]]

if va8 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[
" Pour naviguer dans les onglets (bof => non, retent√© le 2022_03_24__18_26_16): "{{{
noremap <C-tab>          :tabnext<cr>
noremap <C-S-tab>        :tabprevious<cr>
"noremap <C-tab>         :tabnext<cr>
"""map <C-w>             :tabclose<cr> "Surtout pas! Quand on commence √† jouer avec les fen√™tres, √ßa interf√®re, mal!
inoremap <C-S-tab>  <ESC>:tabprevious<cr>i
inoremap <C-tab>    <ESC>:tabnext<cr>i

if empty($TMUX)
" Ceci ne fonctionne pas dans tmux, √ßa dit que "E73: La pile des marqueurs est vide"
" Donc on met √ßa dans un if
  noremap  <C-t>           :tabnew<cr>
  inoremap <C-t>      <ESC>:tabnew<cr>
else
  noremap                :tabnew<cr>
  inoremap          <ESC>:tabnew<cr>
endif


"" Bof: je pr√©f√®re naviguer dans les onglets avec Ctrl-PgUp/Dn: => 2022_03_25__21_10_28 marde, √ßa ne fonctionne pas.
if empty($TMUX)
    nnoremap     <C-PageUp>         :tabprevious<cr>
    inoremap     <C-PageUp>    <ESC>:tabprevious<cr>i
    nnoremap     <C-PageDown>       :tabnext<cr>
    inoremap     <C-PageDown>  <ESC>:tabnext<cr>i
else
    " Dans vim dans tmux, C-V donne √ßa:
    " Ctrl-PgDn:
    " [6;5~
    " Ctrl-PgUp:
    " [5;5~
    " Ctrl-Tab:
    " 	
    " Maj-Ctrl-Tab:
    " 	
    nnoremap  [5;5~       :tabprevious<cr>
    inoremap  [5;5~  <ESC>:tabprevious<cr>i
    nnoremap  [6;5~       :tabnext<cr>
    inoremap  [6;5~  <ESC>:tabnext<cr>i
endif

if empty($TMUX)
  " Navigation entre les onglets en mode vimesque:
  nnoremap <S-A-L>         :tabnext<cr>
  inoremap <S-A-L>  mz<Esc>:tabnext<cr>`zi
  nnoremap <S-A-H>         :tabprevious<cr>
  inoremap <S-A-H>  mz<Esc>:tabprevious<cr>`zi
else
  nnoremap √å               :tabnext<cr>
  inoremap √å        mz<Esc>:tabnext<cr>`zi
  nnoremap √à               :tabprevious<cr>
  inoremap √à        mz<Esc>:tabprevious<cr>`zi
endif




" Poubelle:
"     nmap      <C-PageUp>         :tabprevious<cr>
"     nmap      <C-PageUp>         :tabprevious<cr>
"     noremap      <C-PageDown>       :tabnext<cr>
"     nnoremap     <C-PageDown>       :tabnext<cr>
"     ""noremap      <C-t>              :tabnew<cr>
"     ""nnoremap <C-t>                  :tabnew<cr>
"     ""inoremap <C-t>             <ESC>:tabnew<cr>i
"     """map <C-w>                      :tabclose<cr> "Surtout pas! Quand on commence √† jouer avec les fen√™tres, √ßa interf√®re, mal!



"2023_07_18__23_02_42 solution plus VIMesque:
nnoremap H gT
nnoremap L gt

"}}}
let salut="coucou8"
endif "@# fin de code d√©sactiv√© #############################################]]]]

if va9 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[
"Alt-+- pour retailler les fen√™tres: (ne fonctionne pas) "{{{
"noremap  <A-+> :vertical resize +5<cr>
"noremap  <A--> :vertical resize -5<cr>
"noremap  <A-kPlus> :vertical resize +5<cr>
"noremap  <A-kMinus> :vertical resize -5<cr>
"}}}
let salut="coucou9"
endif "@# fin de code d√©sactiv√© #############################################]]]]

if va10 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[
" Autocmd: "{{{
" _______________ENCOURS_______________
" Only do this part when compiled with support for autocommands. "{{{
if has("autocmd")
  " When editing a file, always jump to the last known cursor position.
  " Don't do it when the position is invalid or when inside an event handler
  " (happens when dropping a file on gvim).
  autocmd BufReadPost *
    \ if line("'\"") > 0 && line("'\"") <= line("$") |
    \   exe "normal g`\"" |
    \ endif

endif " has("autocmd")
"}}}

"}}}
let salut="coucou10"
endif "@# fin de code d√©sactiv√© #############################################]]]]

if va11 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[
" F10 - La correction orthographique, c'est tr√®s tr√®s bien "{{{
noremap ,c :w<CR>:!aspell -c %<CR>:e %<CR>
" Pour le paragraphe en cours:
noremap <F10> vip :w! /tmp/tmp_current_paragraph<cr>dip<up>:!aspell -c /tmp/tmp_current_paragraph<cr> :r /tmp/tmp_current_paragraph<cr>
" i<cr>
"}}}
let salut="coucou11"
endif "@# fin de code d√©sactiv√© #############################################]]]]

if va12 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[
" F9 - La dict√©e, c'est tr√®s tr√®s bien aussi, pour le paragraphe en cours: "{{{
noremap <F9> vip :w! /tmp/tmp_vim_block<cr> :!espeak -v fr -s 200 -f /tmp/tmp_vim_block &<cr>


" Pareil, en anglais:
noremap <S-F9> vip :w! /tmp/tmp_vim_block<cr> :!espeak -v en -s 200 -f /tmp/tmp_vim_block &<cr>

"}}}
let salut="coucou12"
endif "@# fin de code d√©sactiv√© #############################################]]]]

if va13 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[
" copi√© depuis /usr/share/doc/hibernate/examples/hibernate.vim.gz "{{{
   augroup filetypedetect
       au BufNewFile,BufRead hibernate.conf set filetype=hibernate
       au BufNewFile,BufRead common.conf set filetype=hibernate
       au BufNewFile,BufRead suspend2.conf set filetype=hibernate
       au BufNewFile,BufRead disk.conf set filetype=hibernate
       au BufNewFile,BufRead ram.conf set filetype=hibernate
       au BufNewFile,BufRead .vimrc set syntax=vim
   augroup END

"}}}
let salut="coucou13"
endif "@# fin de code d√©sactiv√© #############################################]]]]

if va14 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[
" F7 - horodatage: "{{{
"###################################################################################

" mapper F7 avec l'insertion de timestamp, comme dans le bon vieux ultraedit:
"brouillons: "{{{
"map <F7> :r !date +\%d/\%m/\%Y\ \%T <Enter>
"07/10/2013 09:51:06
"map <F7> :r !date +\%d_\%m_\%Y__\%T \| sed -e 's/\:/_/g' <Enter>
"23_12_2013__15_48_43
"map <F7> :r !date +\%Y_\%m_\%d__\%T \| sed -e 's/\:/_/g' <Enter>
"2013_12_29__20_29_38

" Je mets la date en ISO 8601, plut√¥t:
"r !date +\%Y_\%m_\%d__\%T
"2014_01_01__21:55:01
"r !date +\%Y-\%m-\%d_\%T
"2014-01-01_21:55:51
"map <F7> :r !date +\%Y-\%m-\%d_\%T \| sed -e 's/\:/h/' \| sed -e 's/\:/m/' <Enter>
"non, plut√¥t en ISO underscor√©, comme dans le .bashrc:
"map <F7> :r !date +\%Y_\%m_\%d__\%T \| sed -e 's/\:/_/g' <Enter>
"map <F7> :r!date +\%Y_\%m_\%d__\%T \| sed -e 's/\:/h/' \| sed -e 's/\:/m/'<Enter>
"2014_01_03__14h45m36
"2014_01_07__16h34m19
"}}}
noremap  <F7>      :r !date +\%Y_\%m_\%d__\%T \| sed -e 's/\:/_/g'<cr>A<space>
inoremap <F7> <Esc>:r !date +\%Y_\%m_\%d__\%T \| sed -e 's/\:/_/g'<cr>A<space>
"###################################################################################
"}}}

" mapper F2 avec la ligne courante √† faire tourner en tant que commande vi (:) "{{{
" map <F2> <Esc>V<Left><Home>:<S-Ins><Enter>
" => marche pas...
" nnoremap <F2> <Esc>V<Left><Home>:<S-Ins><CR>
" %s/nnoremap/ouais√ßaamarch√©/gc
"
"
"}}}


" F11 - recherche d'√©tiquettes √† faire, en cours, etc. "{{{
"mapper F11 avec la recherche de la pr√©c√©dente occurrence de _______________ENCOURS_______________ ou @# ou _______________TODO__________________
nnoremap <F11>          ?\<_______________ENCOURS_______________\\|@#\\|_______________TODO__________________<cr>
inoremap <F11>     <Esc>?\<_______________ENCOURS_______________\\|@#\\|_______________TODO__________________<cr>i

"mapper Shift-F11 avec la m√™me chose, dans l'autre sens:
nnoremap <S-F11>        /\<_______________ENCOURS_______________\\|@#_______________TODO__________________<cr>
inoremap <S-F11>   <Esc>/\<_______________ENCOURS_______________\\|@#_______________TODO__________________<cr>i

" "mapper Ctrl-F11 avec la recherche de la pr√©c√©dente occurrence de @#
" nnoremap <C-F11>        ?@#<cr>
" inoremap <C-F11>   <Esc>?@#<cr>i
"
" "mapper Ctrl-Shift-F11 avec la m√™me chose, dans l'autre sens:
" nnoremap <C-S-F11>      /@#<cr>
" inoremap <C-S-F11>   <Esc>/@#<cr>i
"}}}


" F12 - derni√®re macro invoqu√©e: "{{{
"mapper F12 avec la derni√®re macro:
noremap  <F12>      @@
inoremap <F12> <ESC>@@i
"}}}


" ! - Highlighter^Wsurligner toutes les occurrences du mot sous le curseur: "{{{
"http://vim.wikia.com/wiki/Auto_highlight_current_word_when_idle "{{{
"
"created 2003 ¬∑ complexity basic ¬∑ author mosh ¬∑ version 6.0
"Vim can easily highlight all search pattern matches and search for the current word (the word under the cursor). This tip shows how to automatically highlight all occurrences of the current word without searching. That can be useful when examining unfamiliar source code: just move the cursor to a variable, and all occurrences of the variable will be highlighted.
"
"
" Highlight all instances of word under cursor, when idle.
" Useful when studying strange source code.
" Type z/ to toggle highlighting on/off.
function! AutoHighlightToggle()
  let @/ = ''
  if exists('#auto_highlight')
    au! auto_highlight
    augroup! auto_highlight
    setl updatetime=4000
    echo 'Highlight current word: off'
    return 0
  else
    augroup auto_highlight
      au!
      au CursorHold * let @/ = '\V\<'.escape(expand('<cword>'), '\').'\>'
    augroup end
    setl updatetime=500
    echo 'Highlight current word: ON'
    return 1
  endif
endfunction
" on fait √ßa avec... ! (pas loin de *)
noremap ! :if AutoHighlightToggle()<Bar>set hls<Bar>endif<CR>
" non, plut√¥t avec... ¬µ (maj - *)
" => marche pas
"map <S-*> :if AutoHighlightToggle()<Bar>set hls<Bar>endif<CR>
" ni <C-*> ni <S-C-*> ni <S-*> ... donc retour au !

"}}}

" "Autre solution pour highlighter toutes les occurrences du mot sous le curseur: (bof, comment√©) "{{{
" "https://vi.stackexchange.com/questions/17493/how-to-highlight-match-but-not-search-the-word-under-cursor
"
" "You indicate that you were trying to get the mapping to work with <cword>. Though the answer you accepted is just fine I'm surprised no one answered with a corrected use of that.
" "Normally the string on the RHS of a mapping is executed literally as an Ex command. No pre- expansion/evaluation/processing of the string occurs. So :match in
" "nnoremap <F5> :match StatusLineTerm /.expand(<cword>)./
" "(along the lines of your attempt) will try to literally match the string '.expand(<cword>).'
" "If we want the string or some portion of it to be expanded/evaluated we have to do it ourselves by passing it to the :exec command as an expression:
" "exec 'match StatusLineTerm /' . expand('<cword>') . '/'
" "Note that we surround with quotes any parts that we want to use literally and append them with .. The rest is evaluated. (Also note that <cword> is a special string and needs to be quoted before being passed to expand().)
" "So, the mapping you were originally going for is:
" "nnoremap <F5> :exec 'match StatusLineTerm /' . expand('<cword>') . '/'<CR>
"
" " on fait √ßa avec... ! (pas loin de *)
" " nnoremap ! :windo exec 'match StatusLineTerm /' . expand('<cword>') . '/'<CR>
" " => fonctionne pas
" " Autre essai:
" " nnoremap ! :let tt=expand('<cword>') windo exec 'match StatusLineTerm /' . tt . '/'<CR>
"
" " Pas mieux, encore autre chose, avec une fonction:
" function! HighlightCurrentWord(text)
"   windo exec 'match StatusLineTerm /' . a:text . '/'
" endfunction
" nnoremap ! :call HighlightCurrentWord(expand('<cWORD>'))<cr>
"
"}}}

"}}}


"quelques conseils de http://vim.wikia.com/wiki/Using_standard_editor_shortcuts_in_Vim; fait un peu (beaucoup!) de m√©nage, quand m√™me: "{{{

"set smartindent
set tabstop=4
set shiftwidth=4
"set expandtab

"set mouse=a
"set nu

"noremap <C-a> GVgg
"noremap <C-n> :enew
"noremap <C-o> :e . <Enter>
"noremap <C-s> :w <Enter>
"noremap <C-c> y
"noremap <C-v> p
"noremap <C-x> d
"noremap <C-z> u
"noremap <C-t> :tabnew <Enter>
"noremap <C-i> >>
"noremap <C-w> :close <Enter>
"noremap <C-W> :q! <Enter>
"noremap <C-f> /
"noremap <C-h> :%s/
"noremap <S-t> vat
"noremap <S-T> vit
"noremap <S-{> vi{
"noremap <S-(> vi(
"noremap <S-[> vi[
"}}}

let salut="coucou14"
endif "@# fin de code d√©sactiv√© #############################################]]]]

if va15 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[

" Raccourcis pour quitter et sauver comme tout le monde: "{{{
" Pour sauvegarder "comme tout le monde" avec un Ctrl-S
nnoremap <c-s>      :w<CR>
inoremap <c-s> <Esc>:w<CR>a
onoremap <c-s> <Esc>:w<CR><Insert><Insert>
" Dans tmux, voil√† ce que donne Ctrl-S avec Ctrl-V avant: 
nnoremap <>       :w<CR>
inoremap <>  <Esc>:w<CR>a
onoremap <>  <Esc>:w<CR><Insert><Insert>
" => √ßa ne fonctionne point...
nnoremap <> :w<CR>
inoremap <> <Esc>:w<CR>a
" => √ßa ne fonctionne point non plus...



" Pour quitter "comme tout le monde" avec un Ctrl-Q, poil au...
if empty($TMUX)
	nnoremap <c-q>      :q<CR>
	inoremap <c-q> <Esc>:q<CR>
	nnoremap <>       :q<CR>
	inoremap <>  <Esc>:q<CR>
" => √ßa ne fonctionne point non plus dans tmux...
else
	nnoremap          :q<CR>
	inoremap          :q<CR>
endif


"}}}


"Je me fais des raccourcis pour les Fn:
"noremap <F1>
"noremap <F2>
"noremap <F3>
"noremap <F4>


" Pour faire tourner le paragraphe ou le f√©chier courant: "{{{

" TODO il y a beaucoup de redondances: factoriser, faire des fonctions. Penser √† quelque chose de g√©n√©rique, un genre de wrapper peut-√™tre.
" Brouillon d'id√©es:{{{

function! SaveCurrentLineToTmpCodeFile()
  " ...
endfunction

function! SaveCurrentParagraphToTmpCodeFile()
  " ...
endfunction

function! RunTmpCodeFile()
  try
    execute 'wincmd ' . a:direction
    " ...
  catch
    echohl ErrorMsg | echo 'E11: Invalid in command-line window; <CR> executes, CTRL-C quits: wincmd k' | echohl None
  endtry
endfunction

function! PasteOutputFromRanTmpCodeFile()
  " ...
endfunction

"}}}


"pour sauver et faire tourner le fichier courant par rebol^W n'importe quoi, pourvu que le chieboum soit bien fait:
"to save and run the current file by rebol^W interpreter^W anything, as long as the shebang is correct:
"noremap <F5> :w<cr> :!rebol -qs %<cr>
" *** ENLEV√â POUR VIMSPECTOR( ***
noremap  <F5>      :w<cr> :!./%<cr>
inoremap <F5> <esc>:w<cr> :!./%<cr>i
" *** ENLEV√â POUR VIMSPECTOR) ***
"Utile pour un script Rebol existant, qu'on n'a nulle intention de modifier, et qui n'a aucun chieboum:
noremap <s-F5>     :!rebol -qs %<cr>


""pour faire tourner la s√©lection courante par rebol:
""to interpret the current visual selection by rebol interpreter:
"map <F6> :w! tmp_vim_block<cr> :!echo "rebol []" > tmp_vim_block.rr && cat tmp_vim_block.rr tmp_vim_block > tmp_vim_block.r && rebol -qs tmp_vim_block.r && rm tmp_vim_block.rr tmp_vim_block.r tmp_vim_block<cr>

"mieux:
"even better:

"pour faire tourner le paragraphe courant par rebol:
"to interpret the current paragraph by rebol interpreter:
noremap <F6>        mzvip :w! /tmp/tmp_vim_block<cr>:!echo "rebol []" > /tmp/tmp_vim_block.rr && echo 'prin rejoin [newline "=>"         {;==== Rebol code evaluation output: ========= }] ' >> /tmp/tmp_vim_block.rr && echo 'print "{{{"' >> /tmp/tmp_vim_block.rr && cat /tmp/tmp_vim_block.rr /tmp/tmp_vim_block > /tmp/tmp_vim_block.r && echo 'prin {;==========================================}' >> /tmp/tmp_vim_block.r && echo 'print " }}}" wait 0.1 print rejoin [newline {... Entr√©e pour continuer}] input' >> /tmp/tmp_vim_block.r && rebol -qs /tmp/tmp_vim_block.r<cr>`z
inoremap <F6> <ESC> mzvip :w! /tmp/tmp_vim_block<cr>:!echo "rebol []" > /tmp/tmp_vim_block.rr && echo 'prin rejoin [newline "=>"         {;==== Rebol code evaluation output: ========= }] ' >> /tmp/tmp_vim_block.rr && echo 'print "{{{"' >> /tmp/tmp_vim_block.rr && cat /tmp/tmp_vim_block.rr /tmp/tmp_vim_block > /tmp/tmp_vim_block.r && echo 'prin {;==========================================}' >> /tmp/tmp_vim_block.r && echo 'print " }}}" wait 0.1 print rejoin [newline {... Entr√©e pour continuer}] input' >> /tmp/tmp_vim_block.r && rebol -qs /tmp/tmp_vim_block.r<cr>`zi
"(des vieilleries:) "{{{
" noremap  <F6>       mzvip :w! /tmp/tmp_vim_block<cr>:!echo "rebol []" > /tmp/tmp_vim_block.rr && echo 'prin rejoin [newline "=>" newline {;======== code evaluation output: ========= }] ' >> /tmp/tmp_vim_block.rr && echo 'print "{{{"' >> /tmp/tmp_vim_block.rr && cat /tmp/tmp_vim_block.rr /tmp/tmp_vim_block > /tmp/tmp_vim_block.r && echo 'prin {;==========================================}' >> /tmp/tmp_vim_block.r && echo 'print " }}}" wait 0.1 print rejoin [newline {... Entr√©e pour continuer}] input' >> /tmp/tmp_vim_block.r && rebol -qs /tmp/tmp_vim_block.r<cr>`z
"map <F6> vip :w! tmp_vim_block<cr> :!echo "rebol []" > tmp_vim_block.rr && cat tmp_vim_block.rr tmp_vim_block > tmp_vim_block.r && rebol -qs tmp_vim_block.r && rm tmp_vim_block.rr tmp_vim_block.r tmp_vim_block<cr>
"map <F6> vip :w! /tmp/tmp_vim_block<cr>:!echo "rebol []" > /tmp/tmp_vim_block.rr && echo 'print rejoin [newline "=>" newline {;======== code evaluation output: =========} ]' >> /tmp/tmp_vim_block.rr  && cat /tmp/tmp_vim_block.rr /tmp/tmp_vim_block > /tmp/tmp_vim_block.r && echo "print {;==========================================} wait 0.5 print rejoin [newline newline newline {Entr√©e pour continuer}] input" >> /tmp/tmp_vim_block.r && rebol -qs /tmp/tmp_vim_block.r<cr>}k
"map <F6> vip :w! /tmp/tmp_vim_block<cr>:!echo "rebol []" > /tmp/tmp_vim_block.rr && echo 'prin rejoin [newline "=>" newline {;======== code evaluation output: ========= } ]' >> /tmp/tmp_vim_block.rr && echo " ; {{{" >> /tmp/tmp_vim_block.rr  && cat /tmp/tmp_vim_block.rr /tmp/tmp_vim_block > /tmp/tmp_vim_block.r && echo "prin {;==========================================}  >> /tmp/tmp_vim_block.r && echo '}}}"' >> /tmp/tmp_vim_block.r && echo "wait 0.5 print rejoin [newline newline newline {Entr√©e pour continuer}] input" >> /tmp/tmp_vim_block.r && rebol -qs /tmp/tmp_vim_block.r"<cr>}k
"KK! map <F6> vip :w! /tmp/tmp_vim_block<cr>:!echo "rebol []" > /tmp/tmp_vim_block.rr && \ echo 'prin rejoin [newline "=>" newline {;======== code evaluation output: ========= } ]' >> /tmp/tmp_vim_block.rr && echo "{{{" >> /tmp/tmp_vim_block.rr  && cat /tmp/tmp_vim_block.rr /tmp/tmp_vim_block > /tmp/tmp_vim_block.r && echo "prin {;==========================================} > /tmp/tmp_vim_block.r && echo 'print "}}}"' > /tmp/tmp_vim_block.r print rejoin [newline newline newline {Entr√©e pour continuer}] input" >> /tmp/tmp_vim_block.r && rebol -qs /tmp/tmp_vim_block.r<cr>}k
"map <F6> vip :w! /tmp/tmp_vim_block<cr>:!echo "rebol []" > /tmp/tmp_vim_block.rr && echo 'prin rejoin [newline "=>" newline {;======== code evaluation output: ========= } ]' >> /tmp/tmp_vim_block.rr && echo "{{{" >> /tmp/tmp_vim_block.rr  && cat /tmp/tmp_vim_block.rr /tmp/tmp_vim_block > /tmp/tmp_vim_block.r && echo "prin {;==========================================} && echo "}}}" wait 0.5 print rejoin [newline newline newline {Entr√©e pour continuer}] input" >> /tmp/tmp_vim_block.r && rebol -qs /tmp/tmp_vim_block.r<cr>}k
"map <F6> vip :w! /tmp/tmp_vim_block<cr>:!echo "rebol []" > /tmp/tmp_vim_block.rr && echo 'print rejoin [newline "=>" newline {;======== code evaluation output: =========} ]' >> /tmp/tmp_vim_block.rr  && cat /tmp/tmp_vim_block.rr /tmp/tmp_vim_block > /tmp/tmp_vim_block.r && echo "print {;==========================================} wait 0.5 print rejoin [newline newline newline {Entr√©e pour continuer}] input" >> /tmp/tmp_vim_block.r && rebol -qs /tmp/tmp_vim_block.r<cr>}k
"map <F6> vip :w! /tmp/tmp_vim_block<cr>:!echo "rebol []" > /tmp/tmp_vim_block.rr && echo 'prin rejoin [newline "=>" newline {;======== code evaluation output: ========= }] ' >> /tmp/tmp_vim_block.rr && echo 'print "{{{"' >> /tmp/tmp_vim_block.rr && cat /tmp/tmp_vim_block.rr /tmp/tmp_vim_block > /tmp/tmp_vim_block.r && echo 'prin {;==========================================}' >> /tmp/tmp_vim_block.r && echo 'print " }}}" wait 0.1 print rejoin [newline newline {... Entr√©e pour continuer}] input' >> /tmp/tmp_vim_block.r && rebol -qs /tmp/tmp_vim_block.r<cr>}k
"}}}

" Pour faire √† la mode, et faire du javascript (√† reculons...), faire tourner le paragraphe courant par javascript:
nnoremap <s-F6>       mzvip :w! /tmp/tmp_vim_block<cr>:! js /tmp/tmp_vim_block && echo "Entr√©e pour poursuivre..." && read<cr>`z
inoremap <s-F6> <ESC> mzvip :w! /tmp/tmp_vim_block<cr>:! js /tmp/tmp_vim_block && echo "Entr√©e pour poursuivre..." && read<cr>`zi


" Pour faire tourner le paragraphe courant par python3:
nnoremap <c-F6>       mzvip :w! /tmp/tmp_vim_block<cr>:!echo 'print("\n=>\n\# ======== Python code evaluation output: ========= {{{")' > /tmp/tmp_vim_block.pyy && cat /tmp/tmp_vim_block.pyy /tmp/tmp_vim_block > /tmp/tmp_vim_block.py && echo 'print("\# ========================================== }}}\n... Entr√©e pour continuer")' >> /tmp/tmp_vim_block.py && echo 'input()' >> /tmp/tmp_vim_block.py && python3 /tmp/tmp_vim_block.py\|\|read<cr>`z
inoremap <c-F6> <ESC> mzvip :w! /tmp/tmp_vim_block<cr>:!echo 'print("\n=>\n\# ======== Python code evaluation output: ========= {{{")' > /tmp/tmp_vim_block.pyy && cat /tmp/tmp_vim_block.pyy /tmp/tmp_vim_block > /tmp/tmp_vim_block.py && echo 'print("\# ========================================== }}}\n... Entr√©e pour continuer")' >> /tmp/tmp_vim_block.py && echo 'input()' >> /tmp/tmp_vim_block.py && python3 /tmp/tmp_vim_block.py\|\|read<cr>`zi

"Pour faire tourner le paragraphe courant par un compilateur C:
" FIXME logique des raccourcis pourrie. Plut√¥t demander quel langage au d√©but, en gardant le m√™me pour faire, par exemple: F6 P (pour python) Entr√©e, et apr√®s F6 Entr√©e Entr√©e. √Ä r√©fl√©chir, puis refaire les raccourcis de mani√®re logique, en faisant tourner ligne, paragraphe, en collant ou pas la sortie apr√®s.
noremap  <s-c-F6>       mzvip :w! /tmp/tmp_vim_block.c<cr>: !gcc -g -Wall -std=c99 /tmp/tmp_vim_block.c -o /tmp/tmp_vim_block && /tmp/tmp_vim_block > /tmp/tmp_vim_block.ccc   ; echo "... Entr√©e pour continuer" && read<cr>`z
inoremap <s-c-F6> <ESC> mzvip :w! /tmp/tmp_vim_block.c<cr>: !gcc -g -Wall -std=c99 /tmp/tmp_vim_block.c -o /tmp/tmp_vim_block && /tmp/tmp_vim_block ; echo "... Entr√©e pour continuer" && read<cr>`zi


" pour faire tourner le paragraphe courant par bash:
noremap  <F8>          mzvip :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && echo "... Entr√©e pour continuer" && read <cr>`z
inoremap <F8>     <esc>mzvip :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && echo "... Entr√©e pour continuer" && read <cr>`zi

" pour faire tourner le paragraphe courant par bash et coller la sortie apr√®s:
" noremap  <F8>          mzvip :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && read <cr>`z
" inoremap <F8>     <esc>mzvip :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && read <cr>`zi
nnoremap <C-F8>        mzvip :w! /tmp/tmp_vim_block<cr> A<cr># => {{{<esc> :exec 'r!bash /tmp/tmp_vim_block'<cr><cr>i<cr># }}}<cr><cr><esc>`z<cr>
inoremap <C-F8>   <esc>mzvip :w! /tmp/tmp_vim_block<cr> A<cr># => {{{<esc> :exec 'r!bash /tmp/tmp_vim_block'<cr><cr>i<cr># }}}<cr><cr><esc>`z<cr>i


" pour faire tourner la ligne courante par bash:
noremap  <S-F8>        mzV   :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && read <cr>`z
inoremap <S-F8>   <esc>mzV   :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && read <cr>`zi

" pour faire tourner la ligne courante par bash et coller la sortie apr√®s:
nnoremap <C-S-F8>      mzV   :w! /tmp/tmp_vim_block<cr> o<cr># => {{{<esc> :exec 'r!bash /tmp/tmp_vim_block'<cr><cr>i<cr># }}}<cr><esc>`z
inoremap <C-S-F8> <esc>mzV   :w! /tmp/tmp_vim_block<cr> o<cr># => {{{<esc> :exec 'r!bash /tmp/tmp_vim_block'<cr><cr>i<cr># }}}<cr><esc>`zi




" Fl√ªte, F8 ne semble pas compris dans tmux:
" Voil√† ce que donne le C-V:
" [19~

" Pareil, mais pour dans tmux:
" pour faire tourner le paragraphe courant par bash:
noremap  <[19~>      mzvip :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && read <cr>`z
inoremap <[19~> <esc>mzvip :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && read <cr>`zi

" Fl√ªte, S-F8 ne semble pas non plus compris dans tmux:
" Voil√† ce que donne le C-V:
" [19;2~
" pour faire tourner la ligne courante par bash:
noremap  <[19;2~>      mzV :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && read <cr>`z
inoremap <[19;2~> <esc>mzV :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && read <cr>`zi



noremap <[19;2~>      mzV :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && read <cr>`z
noremap <[19;2~> <esc>mzV :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && read <cr>`zi

"}}}
let salut="coucou15"
endif "@# fin de code d√©sactiv√© #############################################]]]]


if va16 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[

"Et un raccourci pour s√©lectionner un Paragraphe: "{{{
noremap <C-S-p> vip
"(enlev√© <S-p> qui fait paste avant)
"Un autre raccourci, qui utilise le symbole ¬ß (touche !):
noremap  ¬ß vip
"inoremap <C-¬ß> <esc>vipi "     => marche pas...
"}}}


" pour ouvrir l'URL (la phrase) sous le curseur par le navigateur: "{{{
"noremap  <C-F8>       mzvis :w! /tmp/tmp_vim_block<cr> :!$BROWSER /tmp/tmp_vim_block && read <cr>`z
"inoremap <C-F8> <esc> mzvis :w! /tmp/tmp_vim_block<cr> :!$BROWSER /tmp/tmp_vim_block && read <cr>`zi
"noremap  <C-F8>       mzvis :w! /tmp/tmp_vim_block<cr> :!$BROWSER /tmp/tmp_vim_block && read <cr>`z
"inoremap <C-F8> <esc> mzvis :w! /tmp/tmp_vim_block<cr> :!$BROWSER /tmp/tmp_vim_block && read <cr>`zi
" Meuh non, bien plus simple: simplement gx et √ßa ouvre le navigateur d√©fini ainsi:
let g:netrw_browsex_viewer= "$BROWSER"
"let g:netrw_browsex_viewer= "xdg-open"
"}}}



" Pour s√©lectionner divers bidules par des double (non, d√©j√† fait) "{{{
"<LeftMouse>     - Left mouse button press
"<RightMouse>    - Right mouse button press
"<MiddleMouse>   - Middle mouse button press
"<LeftRelease>   - Left mouse button release
"<RightRelease>  - Right mouse button release
"<MiddleRelease> - Middle mouse button release
"<LeftDrag>      - Mouse drag while Left mouse button is pressed
"<RightDrag>     - Mouse drag while Right mouse button is pressed
"<MiddleDrag>    - Mouse drag while Middle mouse button is pressed
"<2-LeftMouse>   - Left mouse button double-click
"<2-RightMouse>  - Right mouse button double-click
"<3-LeftMouse>   - Left mouse button triple-click
"<3-RightMouse>  - Right mouse button triple-click
"<4-LeftMouse>   - Left mouse button quadruple-click
"<4-RightMouse>  - Right mouse button quadruple-click
"<X1Mouse>       - X1 button press
"<X2Mouse>       - X2 button press
"<X1Release>     - X1 button release
"<X2Release>     - X2 button release
"<X1Drag>        - Mouse drag while X1 button is pressed
"<X2Drag>        - Mouse drag while X2 button is pressed
"}}}

"  - Right mouse button triple-click => s√©lectionne d√©j√† une ligne, je laisse.

"pour s√©lectionner une phraSe:
nnoremap <3-LeftMouse> vis

"pour s√©lectionner un Paragraphe (comme ctrl-P):
nnoremap <4-LeftMouse> vip


" Un raccourci similaire √† *, mais avec shift, √ßa fait ¬µ, qui ouvre une autre fen√™tre puis fait un *: "{{{
" => tr√®s utile pour les tags
" => mince, pas pu faire :map <S-*> :split <cr>*
"                  ni:   :map <¬µ> :split <cr>*
"donc je fais avec F3, et vers le haut, c'est plus commode, avec #:
noremap <F3>      :split<cr>#
" Pareil, en mode insertion aussi:
inoremap <F3> <Esc>:split<cr>#i
"Pareil, en faisant une division verticale:
noremap <S-F3> :vsplit<cr>#
"=> ne fonctionne pas... 2023_08_04__11_54_09 => si, √ßa refonctionne (hors screen...)
"}}}

"R√©ticule; "{{{
""Pour avoir un r√©ticule amusant (et utile):
"set cursorcolumn
"set cursorline
"
""Pour mettre du gris√© dans les 2 axes du r√©ticule (car le soulignement de l'axe horizontal g√™ne quelque peu la lecture):
"hi CursorLine cterm=NONE
""hi CursorLine ctermbg=Cyan
"hi CursorLine ctermbg=Grey
""hi CursorColumn ctermbg=Cyan
"
"=> En fait, d√®s qu'on est dans un ssh quelconque, ou une console, ce r√©ticule est giga-chiasseur: zou, je le zappe.

"Voici une version plus discr√®te, et basculable par <leader>r (pour R√©ticule)
" hi CursorColumn cterm=NONE ctermbg=Grey guibg=Grey40
" hi CursorColumn cterm=underline ctermfg=11
hi CursorLine   cterm=NONE ctermbg=Grey
hi link CursorColumn CursorLine

nnoremap <Leader>r        :set cursorline! cursorcolumn!<cr>
inoremap <Leader>r <Esc>mz:set cursorline! cursorcolumn!<cr>`zi
" Plut√¥t avec F2 (car le d√©lai apr√®s Leader est bien trop court (d√ª √† la modif pour avoir kj qui fasse Esc...)):
nnoremap <F2>        :set cursorline! cursorcolumn!<cr>
inoremap <F2> <Esc>mz:set cursorline! cursorcolumn!<cr>`zi


"}}}

" Pour scroller plus confortablement, mappons Fn+Ctrl+fl√®ches avec C-D et C-U: "{{{
"noremap <C-S-PageDown> <C-D>
"noremap <C-S-PageUp> <C-U>
"inoremap <C-S-PageDown> <p>
"inoremap <C-S-PageUp> <p>
"  2018_10_13__11_44_06 => ne fonctionne pas.
"}}}

" Contenu de ~/dev/postgresql/src/tools/editors/vim.samples: "{{{
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" These settings are appropriate for editing PostgreSQL code with vim
" You would copy this into your .vimrc or equivalent
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if match(getcwd(), "/pgsql") >=0 ||  match(getcwd(), "/postgresql") >= 0
      set cinoptions=(0
      set tabstop=4
      set shiftwidth=4
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"}}}

" Incr√©menter et d√©cr√©menter un nombre sous le curseur: "{{{
" normalement, c'est <C-A>,<C-X>, mais dans un screen c'est peu ais√©:
"Mieux, A augmente et Q (juste en-dessous sur mon AZERTY)" diminue, avec Alt:
nnoremap <A-a> <C-a>
nnoremap <A-q> <C-x>
inoremap <A-a> <C-a>
inoremap <A-q> <C-x>

" √áa ne fonctionne point ainsi dans un screen: je tente de red√©finir les choses en guettant ce qui se passe dans un:
" sed -n l
nnoremap √°      <C-a>
nnoremap √±      <C-x>
inoremap √° <Esc><C-a>i
inoremap √± <Esc><C-x>i

" Bac √† sable: 35

"}}}


" Mes macros pratiques, que je conserve: "{{{
" @S Soulignements => pour mettre 32 fois _ sur une ligne de type _____________________________________QUELQUECHOSE
let @s = '[1~32r_[1~'

" Une tentative rat√©e pour ne souligner que les 32 premiers caract√®res du mot (et non de la ligne) courant:
" nnoremap √† b32r_

"}}}




" Pour fermer les ([{"' automagiquement:
inoremap ( ()<Left>
inoremap [ []<Left>
inoremap { {}<Left>
"inoremap " ""<Left>
" " √©tait (annul√©, √ßa met souvent le oua√Ø ...) => de nouveau annul√©
"inoremap ' ''<Left> (annul√©, √ßa met le oua√Ø dans l'apostrophage...)
inoremap < <><Left>







""2020_11_12__15_59_26 => J'annule tout √ßa: "{{{
""
""" 2020_10_13__11_41_18
""" En lisant √ßa: https://realpython.com/vim-and-python-a-match-made-in-heaven/
""" Pour Vundle:
"""set nocompatible              " required  <= inutile, c'est d√©j√† mentionn√© plus haut
""filetype off                  " required
"""
""" set the runtime path to include Vundle and initialize
""set rtp+=~/.vim/bundle/Vundle.vim
""call vundle#begin()
"""
""" alternatively, pass a path where Vundle should install plugins
"""call vundle#begin('~/some/path/here')
"""
""" let Vundle manage Vundle, required
""Plugin 'gmarik/Vundle.vim'
"""
""" add all your plugins here (note older versions of Vundle
""" used Bundle instead of Plugin)
"""
""Plugin 'tmhedberg/SimpylFold'
""Plugin 'vim-scripts/indentpython.vim'
""Plugin 'scrooloose/nerdtree'
""" ...
""" All of your Plugins must be added before the following line
""call vundle#end()            " required
""filetype plugin indent on    " required
"}}}



"Pro Tip #5: Try this if you want to see the docstrings for folded code:
let g:SimpylFold_docstring_preview=1

"To add the proper PEP 8 indentation, add the following to your .vimrc:
"au BufNewFile,BufRead *.py set tabstop=4 softtabstop=4 shiftwidth=4 textwidth=79 expandtab autoindent fileformat=unix
" textwidth=79 me GONFLE gravement.
au BufNewFile,BufRead *.py set tabstop=4 softtabstop=4 shiftwidth=4 expandtab autoindent fileformat=unix
"
"For full stack development, you can use another au command for each filetype:
au BufNewFile,BufRead *.js,*.html,*.css set tabstop=2 softtabstop=2 shiftwidth=2

"Flagging Unnecessary Whitespace
"You also want to avoid extraneous whitespace. You can have VIM flag that for you so that it‚Äôs easy to spot and then remove:
"au BufRead,BufNewFile *.py,*.pyw,*.c,*.h match BadWhitespace /\s\+$/

"Auto-Complete

"The best plugin for Python auto-complete is YouCompleteMe. Again, use Vundle to install:
"Bundle 'Valloric/YouCompleteMe'
    "=> bof, non, mon autocompl√©tion est d√©j√† Parfaite.


"""python with virtualenv support
""py << EOF
""import os
""import sys
""if 'VIRTUAL_ENV' in os.environ:
""  project_base_dir = os.environ['VIRTUAL_ENV']
""  activate_this = os.path.join(project_base_dir, 'bin/activate_this.py')
""  execfile(activate_this, dict(__file__=activate_this))
""EOF
"" => ? Marche pas.





" Un moignon de plugin pour corriger la faute d'orthographe pr√©c√©dente par la premi√®re suggestion et revenir au m√™me endroit en faisant <espace>sp  => "{{{
" Voil√† mon premier plugin, √† ce stade (oui, c'est pas un plugin, c'est quelques lignes dans mon .vimrc):

function! FixLastSpellingError()
 normal! mm[s1z=`m
endfunction

nnoremap <leader>sp :call FixLastSpellingError()<cr>
nnoremap <leader>sop :source %<cr>

"}}}



"En suivant les conseils de https://riptutorial.com/ vim.pdf : "{{{
"2020_11_29__18_28_55

" Automatically source .vimrc after saving
" Add this to your $MYVIMRC : "{{{

" Source vim configuration file whenever it is saved
if has ('autocmd')         " Remain compatible with earlier versions
    augroup Reload_Vimrc   " Group name. Always use a unique name!
    autocmd!
                           " Clear any preexisting autocommands from this group
    autocmd! BufWritePost $MYVIMRC source % | echom "Reloaded " . $MYVIMRC | redraw
    autocmd! BufWritePost $MYGVIMRC if has('gui_running') | so % | echom "Reloaded " . $MYGVIMRC | endif | redraw
    augroup END
endif " has autocmd

" Features:
"    ‚Ä¢ echom tells the user what has happened (and also logs to :messages ).
"    ‚Ä¢ $MYVIMRC and $MYGVIMRC handle platform-specific names for the configuration files,
"    ‚Ä¢ and only match the actual configuration files (ignoring copies in other directories, or a
"     fugitive://diff)
"    ‚Ä¢ has() will prevent an error if using incompatible versions, such as vim-tiny .
"    ‚Ä¢ autocmd! avoids buildup of multiple identical autocommands if this file is sourced again. (It
"     clears all commands in the named group, so the group name is important.)
"}}}

"}}}


"Num√©rotation des lignes: "{{{
set nu

" Pratique, pour n'avoir que la ligne courante num√©rot√©e, et les autres lignes num√©rot√©e en relatif.
set relativenumber
"}}}


"Ouverture d'une fen√™tre d'exploration de fichiers netrw √† gauche: "{{{
"Lexplore
" => marche pas... Pagrave.
"}}}


" D√©finition de r√©pertoires pour les sauvegardes, les fontchiers temporaires, et les fontchiers d'annulation: "{{{
" selon le conseil de https://medium.com/@Aenon/vim-swap-backup-undo-git-2bf353caa02f:
set backupdir=.backup/,~/.backup/,/tmp//
set directory=.swp/,~/.swp/,/tmp//
set undodir=.undo/,~/.undo/,/tmp//
"}}}


" Installation de vimspector "{{{
"let g:vimspector_enable_mappings = 'HUMAN'
" => annul√©, je pr√©f√®re mon F5 tout b√™te
"Voici les raccourcis "humains" de vimspector:
"  nnoremap <F5>         <Plug>VimspectorContinue
"  nnoremap <leader><F5> <Plug>VimspectorLaunch
"  nnoremap <F3>         <Plug>VimspectorStop
"  nnoremap <F4>         <Plug>VimspectorRestart
"  nnoremap <F6>         <Plug>VimspectorPause
"  nnoremap <F9>         <Plug>VimspectorToggleBreakpoint
"  nnoremap <leader><F9> <Plug>VimspectorToggleConditionalBreakpoint
"  nnoremap <F8>         <Plug>VimspectorAddFunctionBreakpoint
"  nnoremap <leader><F8> <Plug>VimspectorRunToCursor
"  nnoremap <F10>        <Plug>VimspectorStepOver
"  nnoremap <F11>        <Plug>VimspectorStepInto
"  nnoremap <F12>        <Plug>VimspectorStepOut
" => du coup, il faut que je red√©finisse mes raccourcis...
" => non: quand on r√©ussit √† lancer le d√©bogueur python, les raccourcis de vimspector fonctionnent.


" Activation des raccourcis
function! Vimspector_human_keybindings ()
 let g:vimspector_enable_mappings = 'HUMAN'
endfunction
function! Vimspector_vscode_keybindings ()
  let g:vimspector_enable_mappings = 'VISUAL_STUDIO'
endfunction
"}}}


" T√©, un truc marrant pour remapper <Esc> dans vim => kj : "{{{
" https://vi.stackexchange.com/questions/16963/remap-esc-key-in-vim
" TL;DR
" It's actually nice to remap esc to the home row. Here's how you decide what to map it to: Pick a hand and roll your 4 fingers across your desktop as fast as you can in whichever direction is fastest. Use that to choose what keys to remap.
" For me it's more natural to roll from pinky to index finger. Therefore I chose to use kj. Also, I did a grep -rHin kj ~/src (recursive grep on the parent directory of all my source code) and found no matches.
" esc in insert & visual mode
inoremap kj <esc>
vnoremap kj <esc>

" esc in command mode
cnoremap kj <C-C>
" Note: In command mode mappings to esc run the command for some odd
" historical vi compatibility reason. We use the alternate method of
" existing which is Ctrl-C

" Note: If you do need to type a literal kj (or whatever your mapping is) just type them with 2 seconds in between. (You'll see the cursor hesitate to move after the 1st char. Wait for it to move before typing the 2nd.)
"
" You can shorten this delay by setting a shorter timeout to timeoutlen. For example, to have a timeout of 500ms add the following to your vimrc:
"
" set timeoutlen=500
"
" I have been using vim for 19 years. I was horrified when Apple updated their MacBook Pros to have a touch bar and no physical esc key. I saw a post that suggested mapping jj and jk to <Esc> and hated it. But I patiently jotted down on an index card every time it annoyed me. About 15 minutes later I reviewed my notes and came up with the TL;DR above to address the following:
"     I tend to hit esc allot when I'm not in insert mode just to "be sure" and jj would drop me 2 lines.
"     jk is a no-op (down, up) but kj is more natural for my hands.
"     I also need to use esc to exit command mode without completing the command.
" It's my hope that I can finally break my habit of hitting esc in other applications and closing windows when I'm several minutes into writing. I'd much rather insert stray kj characters than lose my work!


" Alors, je vais tenter d'adapter √ßa en restant AUSSI dans la position des fl√®ches:
inoremap <silent> <Up><Left> <esc>
vnoremap <silent> <Up><Left> <esc>

" Mouais, il faut que ce soit VRAIMENT tr√®s rapide, pour √™tre confortable:
set timeoutlen=50
" FIXME chiotte, cela rend les combinaisons avec la touche <Leader> quasiment impossibles √† faire...

"}}}


" Retour √† la ligne visuel (wrap): "{{{

" le plus souvent, le wrap m'emmerdoie, pour des sources bien indent√©s notamment; donc j'√¥te:
set nowrap

"mais des fois, il rend service..
set wrap

" pour ne pas wrapper en coupant les mots:
set linebreak
" pour wrapper en respectant l'indentation:
set breakindent

" Bascule le retour √† la ligne visuel (wrap) avec le raccourci Alt-Z (comme vsc...): "{{{
noremap  <A-z>           :set invwrap<cr>
inoremap <A-z> <Esc>mz   :set invwrap<cr>`zi

" Avec majuscule en plus: √ßa le fait dans toutes les fen√™tres:
noremap  <S-A-z>         :windo set invwrap<cr>
inoremap <S-A-z>    <Esc>:windo set invwrap<cr>i

"}}}

"}}}


" Cohabitation avec un multiplexeur de terminaux, comme screen ou tmux: "{{{

" 2023_10_01__20_32_50
" Alors, maintenant, pour vivre avec tmux (selon config/.vim/pack/plugins/start/vim-tmux-navigator/README.md): "{{{

" Je colle ici le contenu du greffon: "{{{
" 2023_08_28__12_36_18

" Maps <C-h/j/k/l> to switch vim splits in the given direction. If there are
" no more windows in that direction, forwards the operation to tmux.
" Additionally, <C-\> toggles between last active vim splits/tmux panes.

if exists("g:loaded_tmux_navigator") || &cp || v:version < 700
  " finish " comment√©: √ßa arr√™tait tout mon .vimrc... _______________TODO__________________2023_10_03__21_53_23
endif
let g:loaded_tmux_navigator = 1

function! s:VimNavigate(direction)
  try
    execute 'wincmd ' . a:direction
  catch
    echohl ErrorMsg | echo 'E11: Invalid in command-line window; <CR> executes, CTRL-C quits: wincmd k' | echohl None
  endtry
endfunction

if !get(g:, 'tmux_navigator_no_mappings', 0)
  noremap <silent> <A-h>     :<C-U>TmuxNavigateLeft<cr>
  noremap <silent> <A-j>     :<C-U>TmuxNavigateDown<cr>
  noremap <silent> <A-k>     :<C-U>TmuxNavigateUp<cr>
  noremap <silent> <A-l>     :<C-U>TmuxNavigateRight<cr>
"   noremap <silent> <A-\> :<C-U>TmuxNavigatePrevious<cr>
  noremap <silent> <A-Left>  :<C-U>TmuxNavigateLeft<cr>
  noremap <silent> <A-Down>  :<C-U>TmuxNavigateDown<cr>
  noremap <silent> <A-Up>    :<C-U>TmuxNavigateUp<cr>
  noremap <silent> <A-Right> :<C-U>TmuxNavigateRight<cr>
" 2023_11_29__22_02_12 Mince, ces 4 derni√®res lignes ne fonctionnent pas; rempla√ßons les A-* par les codes captur√©s par vim √† l'int√©rieur d'une session tmux, avec C-V:
  noremap <silent> h  :<C-U>TmuxNavigateLeft<cr>
  noremap <silent> j  :<C-U>TmuxNavigateDown<cr>
  noremap <silent> k  :<C-U>TmuxNavigateUp<cr>
  noremap <silent> l  :<C-U>TmuxNavigateRight<cr>
endif

if empty($TMUX)
  command! TmuxNavigateLeft call s:VimNavigate('h')
  command! TmuxNavigateDown call s:VimNavigate('j')
  command! TmuxNavigateUp call s:VimNavigate('k')
  command! TmuxNavigateRight call s:VimNavigate('l')
  command! TmuxNavigatePrevious call s:VimNavigate('p')
  " finish " comment√©: √ßa arr√™tait tout mon .vimrc... _______________TODO__________________2023_10_03__21_53_23
endif
let salut="coucouroucoucou"

command! TmuxNavigateLeft call s:TmuxAwareNavigate('h')
command! TmuxNavigateDown call s:TmuxAwareNavigate('j')
command! TmuxNavigateUp call s:TmuxAwareNavigate('k')
command! TmuxNavigateRight call s:TmuxAwareNavigate('l')
command! TmuxNavigatePrevious call s:TmuxAwareNavigate('p')

if !exists("g:tmux_navigator_save_on_switch")
  let g:tmux_navigator_save_on_switch = 0
endif

if !exists("g:tmux_navigator_disable_when_zoomed")
  let g:tmux_navigator_disable_when_zoomed = 0
endif

if !exists("g:tmux_navigator_preserve_zoom")
  let g:tmux_navigator_preserve_zoom = 0
endif

if !exists("g:tmux_navigator_no_wrap")
  let g:tmux_navigator_no_wrap = 0
endif

let s:pane_position_from_direction = {'h': 'left', 'j': 'bottom', 'k': 'top', 'l': 'right'}

function! s:TmuxOrTmateExecutable()
  return (match($TMUX, 'tmate') != -1 ? 'tmate' : 'tmux')
endfunction

function! s:TmuxVimPaneIsZoomed()
  return s:TmuxCommand("display-message -p '#{window_zoomed_flag}'") == 1
endfunction

function! s:TmuxSocket()
  " The socket path is the first value in the comma-separated list of $TMUX.
  return split($TMUX, ',')[0]
endfunction

function! s:TmuxCommand(args)
  let cmd = s:TmuxOrTmateExecutable() . ' -S ' . s:TmuxSocket() . ' ' . a:args
  let l:x=&shellcmdflag
  let &shellcmdflag='-c'
  let retval=system(cmd)
  let &shellcmdflag=l:x
  return retval
endfunction

function! s:TmuxNavigatorProcessList()
  echo s:TmuxCommand("run-shell 'ps -o state= -o comm= -t ''''#{pane_tty}'''''")
endfunction
command! TmuxNavigatorProcessList call s:TmuxNavigatorProcessList()

let s:tmux_is_last_pane = 0
augroup tmux_navigator
  au!
  autocmd WinEnter * let s:tmux_is_last_pane = 0
augroup END

function! s:NeedsVitalityRedraw()
  return exists('g:loaded_vitality') && v:version < 704 && !has("patch481")
endfunction

function! s:ShouldForwardNavigationBackToTmux(tmux_last_pane, at_tab_page_edge)
  if g:tmux_navigator_disable_when_zoomed && s:TmuxVimPaneIsZoomed()
    return 0
  endif
  return a:tmux_last_pane || a:at_tab_page_edge
endfunction

function! s:TmuxAwareNavigate(direction)
  let nr = winnr()
  let tmux_last_pane = (a:direction == 'p' && s:tmux_is_last_pane)
  if !tmux_last_pane
    call s:VimNavigate(a:direction)
  endif
  let at_tab_page_edge = (nr == winnr())
  " Forward the switch panes command to tmux if:
  " a) we're toggling between the last tmux pane;
  " b) we tried switching windows in vim but it didn't have effect.
  if s:ShouldForwardNavigationBackToTmux(tmux_last_pane, at_tab_page_edge)
    if g:tmux_navigator_save_on_switch == 1
      try
        update " save the active buffer. See :help update
      catch /^Vim\%((\a\+)\)\=:E32/ " catches the no file name error
      endtry
    elseif g:tmux_navigator_save_on_switch == 2
      try
        wall " save all the buffers. See :help wall
      catch /^Vim\%((\a\+)\)\=:E141/ " catches the no file name error
      endtry
    endif
    let args = 'select-pane -t ' . shellescape($TMUX_PANE) . ' -' . tr(a:direction, 'phjkl', 'lLDUR')
    if g:tmux_navigator_preserve_zoom == 1
      let l:args .= ' -Z'
    endif
    if g:tmux_navigator_no_wrap == 1
      let args = 'if -F "#{pane_at_' . s:pane_position_from_direction[a:direction] . '}" "" "' . args . '"'
    endif
    silent call s:TmuxCommand(args)
    if s:NeedsVitalityRedraw()
      redraw!
    endif
    let s:tmux_is_last_pane = 1
  else
    let s:tmux_is_last_pane = 0
  endif
endfunction


"}}}

" 2023_08_28__12_36_18
let g:tmux_navigator_no_mappings = 1
if empty($TMUX)
 " RAS...
else
 noremap <silent> <A-Left>  :<C-U>TmuxNavigateLeft<cr>
 noremap <silent> <A-Down>  :<C-U>TmuxNavigateDown<cr>
 noremap <silent> <A-Up>    :<C-U>TmuxNavigateUp<cr>
 noremap <silent> <A-Right> :<C-U>TmuxNavigateRight<cr>
" noremap <silent> {Previous-Mapping} :<C-U>TmuxNavigatePrevious<cr>
 noremap <silent> <A-h>     :<C-U>TmuxNavigateLeft<cr>
 noremap <silent> <A-j>     :<C-U>TmuxNavigateDown<cr>
 noremap <silent> <A-k>     :<C-U>TmuxNavigateUp<cr>
 noremap <silent> <A-l>     :<C-U>TmuxNavigateRight<cr>
" *Note* Each instance of `{Left-Mapping}` or `{Down-Mapping}` must be replaced
" in the above code with the desired mapping. Ie, the mapping for `<ctrl-h>` =>
" Left would be created with `noremap <silent> <c-h> :<C-U>TmuxNavigateLeft<cr>`.
endif

"}}}
" # => √ßa ne fonctionne point...


" " Screen-ify an external command.
" function InScreen(command)
"   return g:GNU_Screen_used ? 'screen '.a:command : a:command
" endfunction
" Test:
" map <C-j> :r !echo "coucou"<CR>

"}}}



" Surround the visual selection in parenthesis/brackets/etc.: "{{{
vnoremap ( <esc>`>a)<esc>`<i(<esc>
" vnoremap ) <esc>`>a)<esc>`<i(<esc>
vnoremap [ <esc>`>a]<esc>`<i[<esc>
vnoremap ] <esc>`>a]<esc>`<i[<esc>
vnoremap { <esc>`>a}<esc>`<i{<esc>
" vnoremap } <esc>`>a}<esc>`<i{<esc>
vnoremap " <esc>`>a"<esc>`<i"<esc>
vnoremap ' <esc>`>a'<esc>`<i'<esc>
vnoremap ` <esc>`>a`<esc>`<i`<esc>
" => invalid√© ) et }, pour pouvoir continuer √† s√©lectionner une phrase ou un paragraphe

" FIXME double emploi avec ce qui est horodat√© l√†?  2023_10_09__23_58_39 " Pour entourer une s√©lection avec des {}:
" vnoremap { yc{}<Esc>P
" vnoremap } yc{}<Esc>P
" FIXME double emploi avec ce qui est horodat√© l√†?  2023_10_09__23_58_39

"}}}

" Une macro pour entourer de parenth√®ses la prochaine variable shell qui ne l'est pas d√©j√†:{{{

" let @a= '/kulviw}'
" (ne fonctionne pas)

" TODO voir le .vimrc chez Spie, o√π √ßa fonctionne correctement

" 2023_12_24__13_34_53 mince, pas vu...
" Refait, de t√™te:
nnoremap <C-F12>      /\$[A-Za-z]<cr> i{<esc>ea}<esc>
inoremap <C-F12> <esc>/\$[A-Za-z]<cr> i{<esc>ea}<esc>

" }}}


" Pour ouvrir une URL avec gx: (pas la peine, √ßa fonctionne sans ceci) "{{{
" function! OpenURLUnderCursor()
"   let s:uri = expand('<cWORD>')
"   let s:uri = substitute(s:uri, '?', '\\?', '')
"   let s:uri = shellescape(s:uri, 1)
"   if s:uri != ''
"     silent exec "!open '".s:uri."'"
"     redraw!
"   endif
" endfunction
" nnoremap gx :call OpenURLUnderCursor()<CR>
"
" " If you‚Äôre on Linux, try changing !open to !gio.

"}}}



" Je remets tous mes greffons par ici: "{{{

" Pour √©diter rapidos du HTML et CSS, plugin https://github.com/mattn/emmet-vim/:
" Plugin 'mattn/emmet-vim' (non, marche pas ainsi)


" vim-plug:
" call plug#begin('~/.vim/plugged')
" call plug#begin()
"   Plug 'preservim/nerdtree'
"   Plug 'iberianpig/ranger-explorer.vim'
" call plug#end()

" paquets vim (pack ages):
packadd! vimspector
packadd! vim-tmux-navigator





"}}}
let salut="coucou16"
endif "@# fin de code d√©sactiv√© #############################################]]]]

if va17 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[
" Raccourcis clavier pour les greffons: "{{{

" NERDTree: "{{{
" A pour Arborescence
noremap <leader>a   :NERDTreeFocus<cr>
" let NERDTreeMapCloseChildren='h'
let NERDTreeMapCloseDir='h'
" let NERDTreeMapUpdir='h'
" let NERDTreeMapActivateNode='l'
let NERDTreeShowHidden=1
let NERDTreeMapPreview='l'
let NERDTreeMapActivateNode='l'
" => √ßa ne fonctionne pas...

" Exit Vim if NERDTree is the only window remaining in the only tab.
autocmd BufEnter * if tabpagenr('$') == 1 && winnr('$') == 1 && exists('b:NERDTree') && b:NERDTree.isTabTree() | quit | endif
" Close the tab if NERDTree is the only window remaining in it.
autocmd BufEnter * if winnr('$') == 1 && exists('b:NERDTree') && b:NERDTree.isTabTree() | quit | endif

" Pour √©viter le message de NERDTree pour les gros r√©pertoires:
let g:NERDTreeNotificationThreshold = 5000

"}}}

"}}}



" Pour ouvrir avec le navigateur par d√©faut avec gx "{{{
" let g:netrw_http_cmd  = "$BROWSER"
" => ez, √ßa ne fonctionne pas, √ßa ouvre aussi un truc tmp
nmap gx :!open <c-r><c-a><cr>

"}}}
let salut="coucou17"
endif "@# fin de code d√©sactiv√© #############################################]]]]

if va18 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[
" Bonjour matinal: "{{{
command! Bonjour :r !echo -e "________________________________________________________________________________\n$(date +\%d_\%m_\%Y__\%T | sed -e 's/\:/_/g')                    $HOSTNAME\n$(acpi -i)"
nnoremap <c-b>      :Bonjour<cr>
vnoremap <c-b>      :Bonjour<cr>
cnoremap <c-b>      :Bonjour<cr>
inoremap <c-b> <Esc>:Bonjour<cr>a

"}}}

let salut="Coucou final, .vimrc charg√©!"
endif "@# fin de code d√©sactiv√© #############################################]]]]

" Poubelle: "{{{

" Un vestige inconnu: "{{{
" let c='a'
" while c <= 'z'
"   exec "set <A-".c.">=\e".c
"   exec "imap \e".c." <A-".c.">"
"   let c = nr2char(1+char2nr(c))
" endw
"}}}

" Changed default required by SuSE security team--be aware if enabling this
" that it potentially can open for malicious users to do harmful things.
set modelines=0


" get easier to use and more user friendly vim defaults
" /etc/vimrc ends here

"}}}
" echo salut


" Faire un redo qui soit plus proche du undo (U) => √à
" nnoremap √® :redo<cr>
" => ach non, √ßa bloque Alt-H...
"                                                => _
nnoremap _ :redo<cr>




" TODO FIXME !!
" Fini: "{{{
" x # ^W marche pas en mode insertion!!! => dans gvim, √ßa fonctionne; mais pas dans vim => ay√©, 2023_09_06__18_40_13, √ßa fonctionne (pourquoi?...)
" x √® et √© merdoient en mode insertion!!! => √©√©√®√® => au_quai
" x # BkSp marche pas en mode insertion!!! => au_quai

" set foldmarker=[[[[,]]]]
"}}}

" # let salut="coucou6"
" # endif "@# fin de code d√©sactiv√© #############################################]]]]

" Terrain de jeu pour des essais: "{{{
" https://loremipsum.io/generator/?n=5&t=p
" set syLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Dictumst quisque sagittis purus sit amet volutpat consequat mauris nunc. Risus in hendrerit gravida rutrum quisque non tellus orci. Quam viverra orci sagittis eu volutpat odio facilisis mauris sit. Mauris augue neque gravida in fermentum. Blandit libero volutpat sed cras ornare arcu dui vivamus arcu. Senectus et netus et malesuada. Proin gravida hendrerit lectus a. Dui ut ornare lectus sit amet est placerat in. Ut faucibus pulvinar elementum integer. Massa massa ultricies mi quis hendrerit dolor. Dui nunc mattis enim ut tellus elementum sagittis. Risus commodo viverra maecenas accumsan lacus vel facilisis volutpat est. Cras semper auctor neque vitae tempus. Neque egestas congue quisque egestas diam in arcu cursus.
" Lorem ipsum
" Lorem ipsum dol()or sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Dictumst quisque sagittis purus sit amet volutpat consequat mauris nunc. Risus in hendrerit gravida rutrum quisque non tellus orci. Quam viverra orci sagittis eu volutpat odio facilisis mauris sit. Mauris augue neque gravida in fermentum. Blandit libero volutpat sed cras ornare arcu dui vivamus arcu. Senectus et netus et malesuada. Proin gravida hendrerit lectus a. Dui ut ornare lectus sit amet est placerat in. Ut faucibus pulvinar elementum integer. Massa massa ultricies mi quis hendrerit dolor. Dui nunc mattis enim ut tellus elementum sagittis. Risus commodo viverra maecenas accumsan lacus vel facilisis volutpat est. Cras semper auctor neque vitae tempus. Neque egestas congue[ quisque egestas diam in arcu cursus.
" em ipsum dol()or sit amet, consect
" Lorem ipsum

"32
"}}}

set syntax=vim "Juste pour d√©boguer le pr√©sent f√©chier! Commenter d√®s que c'est fini.
syntax on
" _______________TODO__________________2023_10_03__21_53_23

