let va1="oui"
let va2="oui"
let va3="oui"
let va4="oui"
let va5="oui"
let va55="oui"
" C'est √† ce va55 que se situe le probl√®me qui emp√™che de faire √® en mode insertion
let va6="oui"
let va7="oui"
let va8="oui"
let va9="oui"
let va10="oui"
let va11="oui"
let va12="oui"
let va13="oui"
let va14="oui"
let va15="oui"
let va16="oui"
let va17="oui"
  let va18="oui"
" Les touches de fonctions avec des raccourcis (√† maintenir):
" F1  F2  F3  F4  F5  F6  F7  F8  F9  F10  F11  F12  F13  F14  F15  F16  F17  F18  F19  F20
" -   -   |   |   |   |   |   |   |    |    |    |   -    -    -    -    -    -    -    -
" F2  \_ bascule le viseur/r√©ticule
" F3      \_ ouvre une fen√™tre au-dessus avec l'occurrence pr√©c√©dente du mot sous le curseur
" F4          \_ fait le diff entre la ligne courante et la suivante
" F5              \_ sauver et faire tourner le fichier courant par rebol, ou plut√¥t par le shebang
" F6                  \_ faire tourner le paragraphe courant par rebol
" ctrl-F6             \_ faire tourner le paragraphe courant par python3
" shift-F6            \_ faire tourner le paragraphe courant par javascript
" ctrl-shift-F6       \_ faire tourner le paragraphe courant par une compilation de C et une ex√©cution
" F7                      \_ insertion de timestamp, comme dans le bon vieux ultraedit
" F8                          \_ faire tourner le paragraphe courant par bash
" shift-F8                    \_ faire tourner la ligne courante par bash
" F9                              \_ dict√©e du paragraphe en cours
" shift-F9                        \_ shift => idem en anglais
" F10                                  \_ correction orthographique du paragraphe courant
" F11                                       \_ aller √† l'√©tiquette _______________ENCOURS_______________ pr√©c√©dente
" F12                                            \_ derni√®re macro


" Pour le d√©bogage du pr√©sent f√©chier:{{{ [[[[
" il faut faire:
" set foldmarker=[[[[,]]]]


" }}} ]]]]

" Ces tests if va* == "oui", c'est pour d√©boguer le contenu de ce f√©chier, en invalidant de grosses portions de ce f√©chier de temps √† autre.
if va1 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[
" Trucs bateau:
" Des trucs assez bateau:{{{

" get easier to use and more user friendly vim defaults
" CAUTION: This option breaks some vi compatibility.
"          Switch it off if you prefer real vi compatibility
set nocompatible

syntax on
" set noautoindent
set autoindent
set noerrorbells

set ignorecase
set ruler
set showmatch
set showmode

set hlsearch
set incsearch
set scrolloff=5
set mouse=a
set infercase


" changes special characters in search patterns (default)
" set magic
set esckeys            " Required to be able to use keypad keys and map missed escape sequences


" Complete longest common string, then each full match
" enable this for bash compatible behaviour
" set wildmode=longest,full


set history=10000
set encoding=utf-8
set fileencoding=utf-8


" Je ne sais trop ce que c'est que ceci:
set keymodel=startsel,stopsel


"Pour ne pas recommencer la recherche au d√©but/fin du fichier:
"set nowrapscan
"Pour PAS ne pas recommencer la recherche au d√©but/fin du fichier:
set wrapscan



" Pour ne pas √™tre emb√™t√© avec les messages de tampons non sauv√©s, quand on va d'un tampon √† un autre (en suivant le conseil de iggredible):
" Before you start, make sure you have the set hidden option in vimrc. Without it, whenever you switch buffers and your current buffer is not saved, Vim will prompt you to save the file (you don't want that if you want to move quickly). I haven't covered vimrc yet. If you don't have a vimrc, create one. It is usually placed in your home directory and is named .vimrc. I have mine on ~/.vimrc. To see where you should create your vimrc, check out :h vimrc. Inside it, add:
set hidden


" }}}

" Des fonctions de d√©bogage: {{{

function! DebugPauseWaitForKeyPress()
  " Fonction utilitaire √† la c.n pour attendre un pressage de touche:
  echo "Touche quelconque pour continuer..."
  let c = getchar()
endfunction

" }}}
let salut="coucou1"
endif "@# fin de code d√©sactiv√© #############################################]]]]

" De vieux trucs avec des clefs:
if va2 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[
" Un tas de trucs h√©rit√©s d'un pass√© lointain, avec des machins li√©s au type de terminal: {{{

" Try to get the correct main terminal type {{{
if &term =~ "xterm"
    let myterm = "xterm"
else
    let myterm =  &term
endif
let myterm = substitute(myterm, "cons[0-9][0-9].*$",  "linux", "")
let myterm = substitute(myterm, "vt1[0-9][0-9].*$",   "vt100", "")
let myterm = substitute(myterm, "vt2[0-9][0-9].*$",   "vt220", "")
let myterm = substitute(myterm, "\\([^-]*\\)[_-].*$", "\\1",   "")
" }}}



" Here we define the keys of the NumLock in keyboard transmit mode of xterm {{{
" which misses or hasn't activated Alt/NumLock Modifiers.  Often not defined
" within termcap/terminfo and we should map the character printed on the keys.
if myterm == "xterm" || myterm == "kvt" || myterm == "gnome"
    " keys in insert/command mode.
    map! <ESC>Oo  :
    map! <ESC>Oj  *
    map! <ESC>Om  -
    map! <ESC>Ok  +
    map! <ESC>Ol  ,
    map! <ESC>OM  
    map! <ESC>Ow  7
    map! <ESC>Ox  8
    map! <ESC>Oy  9
    map! <ESC>Ot  4
    map! <ESC>Ou  5
    map! <ESC>Ov  6
    map! <ESC>Oq  1
    map! <ESC>Or  2
    map! <ESC>Os  3
    map! <ESC>Op  0
    map! <ESC>On  .
    " keys in normal mode
    map <ESC>Oo  :
    map <ESC>Oj  *
    map <ESC>Om  -
    map <ESC>Ok  +
    map <ESC>Ol  ,
    map <ESC>OM  
    map <ESC>Ow  7
    map <ESC>Ox  8
    map <ESC>Oy  9
    map <ESC>Ot  4
    map <ESC>Ou  5
    map <ESC>Ov  6
    map <ESC>Oq  1
    map <ESC>Or  2
    map <ESC>Os  3
    map <ESC>Op  0
    map <ESC>On  .
endif
" }}}

" xterm but without activated keyboard transmit mode {{{
" and therefore not defined in termcap/terminfo.
if myterm == "xterm" || myterm == "kvt" || myterm == "gnome"
    " keys in insert/command mode.
    map! <Esc>[H  <Home>
    map! <Esc>[F  <End>
    " Home/End: older xterms do not fit termcap/terminfo.
    map! <Esc>[1~ <Home>
    map! <Esc>[4~ <End>
    " Up/Down/Right/Left
    map! <Esc>[A  <Up>
    map! <Esc>[B  <Down>
    map! <Esc>[C  <Right>
    map! <Esc>[D  <Left>
    " KP_5 (NumLock off)
    map! <Esc>[E  <Insert>
    " PageUp/PageDown
    map <ESC>[5~ <PageUp>
    map <ESC>[6~ <PageDown>
    map <ESC>[5;2~ <PageUp>
    map <ESC>[6;2~ <PageDown>
    map <ESC>[5;5~ <PageUp>
    map <ESC>[6;5~ <PageDown>
    " keys in normal mode
    map <ESC>[H  0
    map <ESC>[F  $
    " Home/End: older xterms do not fit termcap/terminfo.
    map <ESC>[1~ 0
    map <ESC>[4~ $
    " Up/Down/Right/Left
    map <ESC>[A  k
    map <ESC>[B  j
    map <ESC>[C  l
    map <ESC>[D  h
    " KP_5 (NumLock off)
    map <ESC>[E  i
    " PageUp/PageDown
    map <ESC>[5~ 
    map <ESC>[6~ 
    map <ESC>[5;2~ 
    map <ESC>[6;2~ 
    map <ESC>[5;5~ 
    map <ESC>[6;5~ 
endif
" }}}

" xterm/kvt but with activated keyboard transmit mode. {{{
" Sometimes not or wrong defined within termcap/terminfo.
if myterm == "xterm" || myterm == "kvt" || myterm == "gnome"
    " keys in insert/command mode.
    map! <Esc>OH <Home>
    map! <Esc>OF <End>
    map! <ESC>O2H <Home>
    map! <ESC>O2F <End>
    map! <ESC>O5H <Home>
    map! <ESC>O5F <End>
    " Cursor keys which works mostly
    " map! <Esc>OA <Up>
    " map! <Esc>OB <Down>
    " map! <Esc>OC <Right>
    " map! <Esc>OD <Left>
    map! <Esc>[2;2~ <Insert>
    map! <Esc>[3;2~ <Delete>
    map! <Esc>[2;5~ <Insert>
    map! <Esc>[3;5~ <Delete>
    map! <Esc>O2A <PageUp>
    map! <Esc>O2B <PageDown>
    map! <Esc>O2C <S-Right>
    map! <Esc>O2D <S-Left>
    map! <Esc>O5A <PageUp>
    map! <Esc>O5B <PageDown>
    map! <Esc>O5C <S-Right>
    map! <Esc>O5D <S-Left>
    " KP_5 (NumLock off)
    map! <Esc>OE <Insert>
    " keys in normal mode
    map <ESC>OH  0
    map <ESC>OF  $
    map <ESC>O2H  0
    map <ESC>O2F  $
    map <ESC>O5H  0
    map <ESC>O5F  $
    " Cursor keys which works mostly
    " map <ESC>OA  k
    " map <ESC>OB  j
    " map <ESC>OD  h
    " map <ESC>OC  l
    map <Esc>[2;2~ i
    map <Esc>[3;2~ x
    map <Esc>[2;5~ i
    map <Esc>[3;5~ x
    map <ESC>O2A  ^B
    map <ESC>O2B  ^F
    map <ESC>O2D  b
    map <ESC>O2C  w
    map <ESC>O5A  ^B
    map <ESC>O5B  ^F
    map <ESC>O5D  b
    map <ESC>O5C  w
    " KP_5 (NumLock off)
    map <ESC>OE  i
endif
" }}}


" tmux stuff:{{{
" https://stackoverflow.com/questions/15445481/mapping-arrow-keys-when-running-tmux

" Vim knows that xterm-like terminals (identified by TERM starting with xterm, or a particular response to the t_RV sequence, if it is defined) support extended sequences for certain modified keys, but it does not assume this for screen TERMs (which you should be using under tmux).
" 
" You can, however tell Vim about these sequences and enable them if TMUX is present, and TERM starts with screen (the first lines enable (better) mouse support under tmux, which you might also like):

if &term =~ '^screen' && exists('$TMUX')
    set mouse+=a
    " tmux knows the extended mouse mode
    set ttymouse=xterm2
    " tmux will send xterm-style keys when xterm-keys is on
    execute "set <xUp>=\e[1;*A"
    execute "set <xDown>=\e[1;*B"
    execute "set <xRight>=\e[1;*C"
    execute "set <xLeft>=\e[1;*D"
    execute "set <xHome>=\e[1;*H"
    execute "set <xEnd>=\e[1;*F"
    execute "set <Insert>=\e[2;*~"
    execute "set <Delete>=\e[3;*~"
    execute "set <PageUp>=\e[5;*~"
    execute "set <PageDown>=\e[6;*~"
    execute "set <xF1>=\e[1;*P"
    execute "set <xF2>=\e[1;*Q"
    execute "set <xF3>=\e[1;*R"
    execute "set <xF4>=\e[1;*S"
    execute "set <F5>=\e[15;*~"
    execute "set <F6>=\e[17;*~"
    execute "set <F7>=\e[18;*~"
    execute "set <F8>=\e[19;*~"
    execute "set <F9>=\e[20;*~"
    execute "set <F10>=\e[21;*~"
    execute "set <F11>=\e[23;*~"
    execute "set <F12>=\e[24;*~"
endif

" As the comment indicates, you also need to have the window‚Äôs xterm-keys option enabled. You can do this for all your windows like this (in your ~/.tmux.conf):

" set-option -gw xterm-keys on



" }}}



" Tentative (annul√©e) pour faire fonctionner <C-j> dans vim dans screen: {{{
" En suivant les conseils de https://vim.fandom.com/wiki/GNU_Screen_integration :
" if match($TERM, "screen")!=-1
"   " On est dans un screen
"   set term=xterm
"   map [1~ <Home>
"   " Tentative de remapper Ctrl-j:
"   "noremap   <C-j>
"   " => ne fonctionne pas
"   let g:GNU_Screen_used = 1
" else
"   " Hors screen
"   map OH <Home>
"   let g:GNU_Screen_used = 0
" endif
" }}}


if myterm == "linux"
    " keys in insert/command mode.
    map! <Esc>[G  <Insert>
    " KP_5 (NumLock off)
    " keys in normal mode
    " KP_5 (NumLock off)
    map <ESC>[G  i
endif

" This escape sequence is the well known ANSI sequence for
" Remove Character Under The Cursor (RCUTC[tm])
map! <Esc>[3~ <Delete>
map  <ESC>[3~    x


" }}}
let salut="coucou2"
endif "@# fin de code d√©sactiv√© #############################################]]]]

if va3 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[

" Leader key: {{{

" La leader key: espace, au lieu de l'abscon et malpratique \:
nnoremap <Space> <Nop>
let mapleader = " "         " map leader to Space
let mapleader = "\<Space>"  " map leader to Space

" => non, plut√¥t la touche Caps_Lock, mais uniquement en mode normal:
" tentatives: {{{
" let mapleader = "\<Caps_Lock>"
" => ne fonctionne pas

" Suggestion de ChatGPT:{{{
" let mapleader = "\<Caps_Lock>"
" augroup leader_capslock
  " autocmd!
  " autocmd InsertEnter * let leader_save = mapleader | let mapleader = "\<Nop>"
  " autocmd InsertLeave * let mapleader = leader_save
" augroup END
" 
" let g:leader_capslock_active = 0
" 
" function! ToggleLeaderCapslock()
  " if g:leader_capslock_active
    " let mapleader = "\<Nop>"
  " else
    " let mapleader = "\<Caps_Lock>"
  " endif
  " let g:leader_capslock_active = !g:leader_capslock_active
  " echo "Leader CapsLock " . (g:leader_capslock_active ? "activated" : "deactivated")
" endfunction
" 
" nnoremap <silent> <leader> :call ToggleLeaderCapslock()<CR>
" }}}
" => ne fonctionne pas

" Suggestion de ChatGPT:{{{

" augroup leader_capslock
  " autocmd!
  " autocmd InsertEnter * silent !toggle_caps_lock.sh
  " autocmd InsertLeave * silent !toggle_caps_lock.sh
" augroup END
" 
" let mapleader = "\<Leader>"


" }}}
" => ne fonctionne pas

" Suggestion de ChatGPT:{{{

" function! ToggleCapsLock()
  " let caps_state = system('xset q | grep "Caps Lock:" | awk "{print $NF}"')
  " if caps_state =~ "on"
    " call feedkeys("\<Esc>:echo 'Caps on!'\<CR>", 'n')
  " else
    " call feedkeys("\<Esc>:echo 'Caps off!'\<CR>", 'n')
  " endif
" endfunction
" 
" }}}
" nnoremap <Caps_Lock> :call ToggleCapsLock()<CR>
" }}}
" let mapleader = "\<Leader>"



" test:
" nnoremap <Leader>b :echo "Hello, Caps_Lock!"<CR>


" set timeoutlen=500          " Set timeout length to 500 ms
set showcmd "Vim, by default, shows no feedback for this timeout length. Add set showcmd to your vimrc and it will show your leader key in the bottom right corner for the duration of the timeout.

" Nota Bene: pour highlighter les mots sous le curseur avec 123456789,
" il faut faire <leader>m
" puis <leader>1 ou 2 ... sur le mot choisi
" }}}



" Remplacement pour windo, qui a l'inconv√©nient de revenir √† la fen√™tre initiale:{{{

" 2024_03_25__12_12_58
" https://vim.fandom.com/wiki/Windo_and_restore_current_window
" 
" The :windo, :bufdo, :argdo and :tabdo commands are great. However, they have one side-effect that I don't like: they change the current window/buffer/tab and make it the last one. Toward that end, I have the following commands defined in my environment: 

" Just like windo, but restore the current window when done.
function! WinDo(command)
  let currwin=winnr()
  execute 'windo ' . a:command
  execute currwin . 'wincmd w'
endfunction
com! -nargs=+ -complete=command Windo call WinDo(<q-args>)

" Just like Windo, but disable all autocommands for super fast processing.
com! -nargs=+ -complete=command Windofast noautocmd call WinDo(<q-args>)

" Just like bufdo, but restore the current buffer when done.
function! BufDo(command)
  let currBuff=bufnr("%")
  execute 'bufdo ' . a:command
  execute 'buffer ' . currBuff
endfunction
com! -nargs=+ -complete=command Bufdo call BufDo(<q-args>)



"Using them is no different from using the standard :windo or :bufdo, except that when you're done, you're right back where you were.
" 
" Examples:
" 
" :Windofast set nu
" 
" Turns on line-numbers in all windows ‚Äì quickly (because no autocommands trigger) ‚Äì and leaves your cursor exactly where it was so that you may continue with what you were doing.
" 
" Here's another example, one that I have defined permanently:
" 
" function! SetAutoSaveAndRestore( enable )
  " augroup SaveAndRestoreAll
    " au!
    " if a:enable
      " au FocusLost * silent! Windo call UpdateIfPossible()
      " au FocusGained * silent! checktime
    " endif
  " augroup END
" endfunction
" " Automatically write all changed buffers every time we move out of the Vim window
" call SetAutoSaveAndRestore( 1 )
" 
" " Writes out the current file if it isn't read-only, has changed and has a name.
" " Useful from the autocommand that saves all files upon Vim's losing focus.
" function! UpdateIfPossible()
  " if expand('%') == ''
    " return
  " elseif &ro || !&modified
    " return
  " endif
  " update
" endfunction
" 
" Whenever the Vim window is left (to go to an IDE for concurrent development, for example), all modified and writable files are saved. Conversely, the call to 'checktime' automatically updates the contents of any files that may have been modified with the latest version on disk.
" 
" The above should be combined with 'autoread' and 'autowrite' for best results.


" }}}

" Lecture automatique des fichiers ouverts: {{{
" Autoread file par d√©faut
set autoread | au CursorHold * checktime | call feedkeys("lh")
" }}}


" Pour rigoler: {{{

" √áa met en verlan toutes les fen√™tres de tous les onglets:
" nnoremap <C-F1> :tabdo windo set rl!<CR>
" inoremap <C-F1> :tabdo windo set rl!<CR>

" Moins dr√¥le: juste pour l'onglet courant:
nnoremap <C-F1> :Windofast set rl!<CR>
inoremap <C-F1> :Windofast set rl!<CR>

" }}}

" Pour les folds^Wreplis ch√©ris: {{{

set foldmethod=marker
set fdc=5
set foldclose=all

" pour se d√©placer dans les replis: {{{
" https://stackoverflow.com/questions/9403098/is-it-possible-to-jump-to-the-next-closed-fold-in-vim
"
" In Vim, I often find myself wanting to do a quick zk or zj to jump to the previous or next fold in a file. The problem is, I frequently want to skip all the open folds, and just jump to the nearest closed fold.
" Is there a way to do this? I see no built-in keymap in the help.
"
"=>
" Let me propose the following implementation of the described behavior.
nnoremap <silent> <leader>zj :call NextClosedFold('j')<cr>
nnoremap <silent> <leader>zk :call NextClosedFold('k')<cr>

function! NextClosedFold(dir)
    let cmd = 'norm!z'..a:dir
    let view = winsaveview()
    let [l0, l, open] = [0, view.lnum, 1]
    while l != l0 && open
        exe cmd
        let [l0, l] = [l, line('.')]
        let open = foldclosed(l) < 0
    endwhile
    if open
        call winrestview(view)
    endif
endfunction

" If it is desirable for the mappings to accept a count for the number of repetitions of the corresponding movement, one can implement a simple function for repeating any given command:

function! RepeatCmd(cmd) range abort
    let n = v:count < 1 ? 1 : v:count
    while n > 0
        exe a:cmd
        let n -= 1
    endwhile
endfunction

" and then redefine the above mappings as follows:
nnoremap <silent> <leader>zj :<c-u>call RepeatCmd('call NextClosedFold("j")')<cr>
nnoremap <silent> <leader>zk :<c-u>call RepeatCmd('call NextClosedFold("k")')<cr>

" }}}

"Pour √¥ter les /* */ disgr√¢cieux de mes folds {{{ }}} ou [ ]
set commentstring=%s

" }}}

" Pour commenter des lignes: {{{

" pour commenter une ligne de code Rebol et passer √† la suivante:
noremap ; ^i;<Space><Esc><Down>

" pour commenter une ligne de code, genre shell script, par # , puis passer √† la suivante:
"noremap &; <Home>i#<Esc><Down>
" => marche pas...
noremap ¬£ ^i#<Space><Esc><Down>

" _______________JEANSUIL√Ä_____________ rationaliser cette partie avec vimrc_spi
" pour faire la m√™me chose, MAIS en mettant le '# ' au d√©but de la ligne, et non pas devant le premier caract√®re non blanc:
noremap ¬§ 0i#<Space><Esc><Down>
" Idem, de 2023 dans vimrc_spi: {{{
" " pour commenter de la m√™me mani√®re, mais en #ant √ßa tout √† gauche, et non pas juste avant le texte:
" " map <A-¬£> <Home>i#<Space><Esc><Down>
" " C'est Alt-$:
" noremap $ <Home>i#<Space><Esc><Down>
" }}}

" pour commenter une ligne de code SQL et passer √† la suivante:
noremap - ^i--<Space><Esc><Down><Home>

" pour commenter une ligne de code vim et passer √† la suivante:
noremap " ^i"<Space><Esc><Down><Home>
" Idem, de 2023 dans vimrc_spi: {{{
" noremap " ^i"<Space><Esc><Down>
" " }}}

" enfin, pour d√©commenter une ligne en supprimant les 2 premiers caract√®res (√ßa laissera une espace pour le SQL: bof, osef):
noremap ¬µ ^<Del><Del><Down><Home>
" Idem, de 2023 dans vimrc_spi: {{{
" " pour d√©commenter une ligne de code comment√©e par le ¬£ pr√©c√©dent, puis passer √† la suivante:
" map ¬µ ^xx<Down>
" }}}


" 2023_07_25__18_32_28 je fais plut√¥t une fonction, pour trouver s'il n'y a pas des espaces en d√©but de ligne et pr√©server ainsi une indentation:
"function! CommentLine(commentstring)
"    "check if at beginning of line or after a space
"    if strpart(getline('.'), 0, col('.')-1) =~ '^\s*$'
"    return "w
"endfunction

" " Plut√¥t, je recopie un plugin, commentary: {{{ "" => annul√©
"
" " https://github.com/tpope/vim-commentary/blob/master/plugin/commentary.vim
"
"
" " commentary.vim - Comment stuff out
" " Maintainer:   Tim Pope <http://tpo.pe/>
" " Version:      1.3
" " GetLatestVimScripts: 3695 1 :AutoInstall: commentary.vim
"
" if exists("g:loaded_commentary") || v:version < 703
"   finish
" endif
" let g:loaded_commentary = 1
"
" function! s:surroundings() abort
"   return split(get(b:, 'commentary_format', substitute(substitute(substitute(
"         \ &commentstring, '^$', '%s', ''), '\S\zs%s',' %s', '') ,'%s\ze\S', '%s ', '')), '%s', 1)
" endfunction
"
" function! s:strip_white_space(l,r,line) abort
"   let [l, r] = [a:l, a:r]
"   if l[-1:] ==# ' ' && stridx(a:line,l) == -1 && stridx(a:line,l[0:-2]) == 0
"     let l = l[:-2]
"   endif
"   if r[0] ==# ' ' && (' ' . a:line)[-strlen(r)-1:] != r && a:line[-strlen(r):] == r[1:]
"     let r = r[1:]
"   endif
"   return [l, r]
" endfunction
"
" function! s:go(...) abort
"   if !a:0
"     let &operatorfunc = matchstr(expand('<sfile>'), '[^. ]*$')
"     return 'g@'
"   elseif a:0 > 1
"     let [lnum1, lnum2] = [a:1, a:2]
"   else
"     let [lnum1, lnum2] = [line("'["), line("']")]
"   endif
"
"   let [l, r] = s:surroundings()
"   let uncomment = 2
"   let force_uncomment = a:0 > 2 && a:3
"   for lnum in range(lnum1,lnum2)
"     let line = matchstr(getline(lnum),'\S.*\s\@<!')
"     let [l, r] = s:strip_white_space(l,r,line)
"     if len(line) && (stridx(line,l) || line[strlen(line)-strlen(r) : -1] != r)
"       let uncomment = 0
"     endif
"   endfor
"
"   if get(b:, 'commentary_startofline')
"     let indent = '^'
"   else
"     let indent = '^\s*'
"   endif
"
"   let lines = []
"   for lnum in range(lnum1,lnum2)
"     let line = getline(lnum)
"     if strlen(r) > 2 && l.r !~# '\\'
"       let line = substitute(line,
"             \'\M' . substitute(l, '\ze\S\s*$', '\\zs\\d\\*\\ze', '') . '\|' . substitute(r, '\S\zs', '\\zs\\d\\*\\ze', ''),
"             \'\=substitute(submatch(0)+1-uncomment,"^0$\\|^-\\d*$","","")','g')
"     endif
"     if force_uncomment
"       if line =~ '^\s*' . l
"         let line = substitute(line,'\S.*\s\@<!','\=submatch(0)[strlen(l):-strlen(r)-1]','')
"       endif
"     elseif uncomment
"       let line = substitute(line,'\S.*\s\@<!','\=submatch(0)[strlen(l):-strlen(r)-1]','')
"     else
"       let line = substitute(line,'^\%('.matchstr(getline(lnum1),indent).'\|\s*\)\zs.*\S\@<=','\=l.submatch(0).r','')
"     endif
"     call add(lines, line)
"   endfor
"   call setline(lnum1, lines)
"   let modelines = &modelines
"   try
"     set modelines=0
"     silent doautocmd User CommentaryPost
"   finally
"     let &modelines = modelines
"   endtry
"   return ''
" endfunction
"
" function! s:textobject(inner) abort
"   let [l, r] = s:surroundings()
"   let lnums = [line('.')+1, line('.')-2]
"   for [index, dir, bound, line] in [[0, -1, 1, ''], [1, 1, line('$'), '']]
"     while lnums[index] != bound && line ==# '' || !(stridx(line,l) || line[strlen(line)-strlen(r) : -1] != r)
"       let lnums[index] += dir
"       let line = matchstr(getline(lnums[index]+dir),'\S.*\s\@<!')
"       let [l, r] = s:strip_white_space(l,r,line)
"     endwhile
"   endfor
"   while (a:inner || lnums[1] != line('$')) && empty(getline(lnums[0]))
"     let lnums[0] += 1
"   endwhile
"   while a:inner && empty(getline(lnums[1]))
"     let lnums[1] -= 1
"   endwhile
"   if lnums[0] <= lnums[1]
"     execute 'normal! 'lnums[0].'GV'.lnums[1].'G'
"   endif
" endfunction
"
" command! -range -bar -bang Commentary call s:go(<line1>,<line2>,<bang>0)
" xnoremap <expr>   <Plug>Commentary     <SID>go()
" nnoremap <expr>   <Plug>Commentary     <SID>go()
" nnoremap <expr>   <Plug>CommentaryLine <SID>go() . '_'
" onoremap <silent> <Plug>Commentary        :<C-U>call <SID>textobject(get(v:, 'operator', '') ==# 'c')<CR>
" nnoremap <silent> <Plug>ChangeCommentary c:<C-U>call <SID>textobject(1)<CR>
" nmap <silent> <Plug>CommentaryUndo :echoerr "Change your <Plug>CommentaryUndo map to <Plug>Commentary<Plug>Commentary"<CR>
"
" if !hasmapto('<Plug>Commentary') || maparg('gc','n') ==# ''
"   xmap gc  <Plug>Commentary
"   nmap gc  <Plug>Commentary
"   omap gc  <Plug>Commentary
"   nmap gcc <Plug>CommentaryLine
"   nmap gcu <Plug>Commentary<Plug>Commentary
" endif
"
" " vim:set et sw=2:
"
" }}}

" }}}


" Syntaxe: {{{

"syntaxe Rebol:
set syntax=rebol
"aussit√¥t d√©sactiv√©e:
set syntax=none
"=> c'est pour avoir les compl√©tions judicieuses, les mots avec des - vus comme un seul mot (ce qui est commode), mais sans avoir les couleurs (qui n'aident pas forc√©ment beaucoup).

" }}}


" Couleurs pour vimdiff: {{{

" Des couleurs de vimdiff un peu plus humainement lisibles pour un presse-b!t3:
highlight DiffAdd    ctermbg=6
highlight DiffChange ctermbg=2
highlight DiffDelete ctermbg=6
highlight DiffText   ctermfg=1 ctermbg=2 cterm=bold

" Toujours dans le cadre d'un vimdiff, passer √† la ligne et ne pas coloriser la syntaxe:
if &diff
    syntax off
    " essay√© tout √ßa, sans succ√®s: {{{
    "execute 'set wrap'
    ""set wrap
    "execute 'windo set wrap'
    "autocmd FilterWritePre * if &diff | setlocal wrap< | endif
    " }}}
    set wrap
    " Pour ignorer les espaces (utile quand collage de codes divers...)
    " set diffopt+=iwhite
    " \_ c'est parfois aussi tr√®s emb√™tant: √† basculer, au besoin
    " set diffexpr=""
endif

" }}}

" Toujours pour vimdiff, remappage des raccourcis pour Patcher des diffs et pour les Getter en allant, apr√®s, √† la diff suivante:{{{

" Pour vimdiff, faire aller √† la diff suivante quand on fait un dp ou un dg:
nnoremap dp :diffput<cr>]c
nnoremap dg :diffget<cr>]c

" }}}

" Toujours pour vimdiff, remappage de raccourcis pour naviguer entre les  diffs:{{{


nnoremap <Leader>j ]c
nnoremap <Leader>k [c
" Mieux?:
nnoremap <A-PageUp>   ]c
nnoremap <A-PageDown> [c

" }}}


" Remappage de touches diverses: {{{

" Pour coller rapidement en passant par xclip, au lieu d'avoir des caract√®res √† la noix quand on colle: {{{
nnoremap <C-Insert>         :r !xclip -o<cr>
inoremap <C-Insert>  <Esc>mz:r !xclip -o<cr>`za
" vnoremap <C-Insert>        x:r !xclip -o<cr>
" non, ce dernier est stupide, dans la mesure o√π la s√©lection (chez un vim
" bien √©lev√©) est d√©j√† dans le presse-papiers de X...


" Voici les traficougnages sans noms que j'ai faits pour avoir le presse-papiers de X en mettant un xclip √† la rache chez Spie sur Suse avec ce p. de vim sans X...:{{{

" " Mapper Ctrl-Insert avec copier vers xclip: uniquement si l'on n'est PAS dans gvim:
" if has('gui_running')
  " " RAS... (je sais pas √©crire une n√©gation...)
" else
  " " vnoremap <C-Ins> "*y
  " " vnoremap <C-Insert>:w !xclip -i<cr>
  " " nnoremap <C-Insert>V:w !xclip -i<cr>
  " " => marche pas...
  " " Inspiration depuis latitude:
  " " nnoremap <S-Insert>        :r !xclip -r -o<cr>
  " " inoremap <S-Insert>   <Esc>:r !xclip -r -o<cr>a
  " " => annul√©, √ßa mettait le oua√Ø dans gvim...
" 
" 
" 
  " " vnoremap <C-Insert>        y :execute 'xclip -i < echo '.shellescape(@", 1)
  " " vnoremap <silent> <C-Insert> y:execute '! echo '.shellescape(@", 1).' | xclip -i'
  " " vnoremap <C-Insert> y:! 'echo '.shellescape(@", 1).' | xclip -i'<cr>
  " " vnoremap <C-Insert> y:silent exec ":!xclip -i <".shellescape(@", 1)<cr>
  " " vnoremap <C-Insert> :w !cat > $HOME/totoxclip<cr>
  " "let coucou="coucouroucoucou"
  " " Avec Ctrl-V, C-Insert donne √ßa:
  " " [2;5
  " " vnoremap [2;5~ :w !xclip -i<cr>
  " " vnoremap <silent> [2;5~ y:! bash -c 'echo "0" \| xclip -i'<cr>
  " " vnoremap [2;5~ y :execute 'xclip -i < echo '.shellescape(@", 1)
  " " y :execute 'xclip -i < echo '.shellescape(@", 1)
  " " vnoremap [2;5~ :w !eval 'xclip -i "'"$(cat)"'"'<cr>
  " " y:! bash -c 'echo "0" \| xclip -i'<cr>
  " " vnoremap [2;5~ y:execute '! xclip -i < echo '.shellescape(@", 1)
  " " vnoremap [2;5~ y:execute '! xclip -i < echo '.shellescape(@")<cr>
  " " vnoremap [2;5~ y:execute '! echo '.shellescape(@").'! | xclip -i'<cr>
  " " function! CopySelectionToXClipBoard()
    " " yank
    " " ...
  " " endfunction
  " "Selon du stackoverflow.com: #{{{
  " set clipboard=unnamedplus
  " function! ClipboardYank()
    " " call system('xclip -i -selection clipboard', @@)
    " call system('xclip -i', @@)
  " endfunction
  " let vlcb = 0
  " let vlce = 0
  " function! ClipboardPaste(mode)
    " if (a:mode == "v")
      " call cursor(g:vlcb[0], g:vlcb[1]) | execute "normal! v" | call cursor(g:vlce[0], g:vlce[1])
    " endif
    " " let @@ = system('xclip -o -selection clipboard')
    " let @@ = system('xclip -o')
  " endfunction
  " " Replace currently selected text with default register without yanking it
  " vnoremap <silent>p   "_dP
  " vnoremap <silent>y   y: call ClipboardYank()<CR>
  " nnoremap <silent>yy  yy: call ClipboardYank()<CR>
  " nnoremap <silent><S-y> yy: call ClipboardYank()<CR>
  " " nnoremap <silent>wx icocowwww<Esc>
  " vnoremap <silent>d   d: call ClipboardYank()<CR>
  " nnoremap <silent>dd  dd: call ClipboardYank()<CR>
  " nnoremap <silent><S-d>  dd: call ClipboardYank()<CR>
  " nnoremap <silent>p   :call ClipboardPaste("n")<CR>p
  " vnoremap p           :<C-U>let vlcb = getpos("'<")[1:2] \| let vlce = getpos("'>")[1:2] \| call ClipboardPaste("v")<CR>p
  " " au_quai jusqu'ici
" 
  " " " √ßa fonctionne!
  " " J'ajoute les raccourcis C-Insert et autres:
  " " <C-Insert>
  " vnoremap <silent>[2;5~    y: call ClipboardYank()<CR>
  " inoremap <silent>[2;5~    y: call ClipboardYank()<CR>a
  " " _______________ENCOURS_______________QUELQUECHOSE
" 
  " " Annulation de tout!
  " " unmap <silent>wx
  " " unmap <S-Insert>
  " " unmap <S-Insert>
  " " unmap <S-Insert>
  " " unmap <S-Insert>
  " unmap <silent>d
  " unmap <silent>dd
  " unmap <silent><S-d>
  " unmap <silent>p
  " " _______________ENCOURS_______________QUELQUECHOSE
" 
" 
" 
  " " #}}}
" endif

" }}}

" }}}


" T√©, pour naviguer dans les tampons (buffers): {{{
nnoremap <Leader>b :buffers<cr>:buffer<Space>
" }}}


" }}}
let salut="coucou3"
endif "@# fin de code d√©sactiv√© #############################################]]]]

" Ctrl-fl√®ches et Ctrl-jk pour d√©placer les lignes: 
if va4 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[
" Ctrl-fl√®ches et Ctrl-jk pour d√©placer les lignes: {{{

"Ctrl-jk pour faire pareil: (marche pas...) => 2020_07_09__12_13_32 en fait, si on met les lignes map <S-C-k> avant, ce sont elles qui prennent le pas sur les lignes map <C-k>, curieusement. √áa ne le fait pas pour les <C-Fl√®ches, c'est √©trange.
" => 2023_07_25__18_21_51 √ßa fonctionne. => 2023_07_26__13_01_35 √ßa fonctionne, mais pas dans un screen... => 2023_08_30__18_23_19 √ßa fonctionne, mais pas dans un tmux...
"Ctrl-jk pour faire pareil: (marche pas...) => 2020_07_09__12_13_32 en fait, si on met les lignes map <S-C-k> avant, ce sont elles qui prennent le pas sur les lignes map <C-k>, curieusement. √áa ne le fait pas pour les <C-Fl√®ches, c'est √©trange.
" let g:C_Ctrl_j = 'off'

" nnoremap < > <C-j>
" nnoremap <> <C-k>
nnoremap <C-j>      ddp
noremap  <C-j>      ddp
inoremap <C-j> <Esc>ddpa
nnoremap <C-k>      ddkP
noremap  <C-k>      ddkP
inoremap <C-k> <Esc>ddkPa

if empty($TMUX)
  " nnoremap <A-j> :echo "Pas dans TMUX!"<cr>
  " nnoremap <C-j> :echo "Pas dans TMUX!"<cr>
  nnoremap <C-j>  ddp
else
  " nnoremap <A-j> :echo " dans TMUX!"<cr>
  " nnoremap <C-j> :echo " dans TMUX!"<cr>
  " noremap <C- > :echo "Dans TMUX!"<cr>
  " let g:C_Ctrl_j = 'off'
endif

" Idem, de 2023 dans vimrc_spi: {{{
" map <C-j> ddp
" map <C-k> ddkP
" inoremap <C-j> <Esc>ddpa
" inoremap <C-k> <Esc>ddkPa
" }}}

"map   ddp
"map    ddkP
" => ne fonctionne pas...

"Ctrl-fl√®ches pour d√©placer les lignes, comme dans oOo: {{{
"nnoremap <C-Up> ddkp <CR>    "DONE marche pas => si, ainsi:
"map <C-Up> ddkP
"map <C-Down> ddp
"inoremap <C-Up>   <Esc>ddkPa
"inoremap <C-Down> <Esc>ddpa

" Autre version, trouv√©e dans http://www.billodom.com/talks/vim-key-mapping.pdf: plus efficace, marche avec des s√©lections, en les gardant:
"nnoremap <silent> <C-Up> :move -2<CR>
"nnoremap <silent> <C-Down> :move +<CR>
"xnoremap <silent> <C-Up> :move '<-2<CR>gv
"xnoremap <silent> <C-Down> :move '>+<CR>gv
"imap <silent> <C-Up> <C-O><C-Up>
"imap <silent> <C-Down> <C-O><C-Down>
"smap <silent> <C-Up> <C-G><C-Up><C-G>
"smap <silent> <C-Down> <C-G><C-Down><C-G>

"Encore une autre version, en essayant d'am√©liorer, pour faire comme avant, notamment en bougeant les blocs z:
"nnoremap <C-Up> ddkp <CR>    "DONE marche pas => si, ainsi:
"map <C-Up> ddkP
"map <C-Down> ddp
"inoremap <C-Up>   <Esc>ddkPa
"inoremap <C-Down> <Esc>ddpa

nnoremap <silent> <C-Up>        ddkP
inoremap <silent> <C-Up>   <Esc>ddkPa
snoremap <silent> <C-Up>   <Esc>ddkPa
" _______________JEANSUIL√Ä_____________ c'est quoi, snoremap?
xnoremap <silent> <C-Up>        :move '<-2<CR>gv
nnoremap <silent> <C-Down>      ddp
inoremap <silent> <C-Down> <Esc>ddpa
snoremap <silent> <C-Down> <Esc>ddpa
xnoremap <silent> <C-Down>      :move '>+<CR>gv

" }}}


" }}}

" Shift-Ctrl-fl√®ches et Shift-Ctrl-jk pour d√©filer: {{{
" Shift-Ctrl-fl√®ches pour d√©filer (scroller) de 10 lignes (pass√© de 5 √† 7 √† 10):
noremap  <S-C-Up>        10<C-y>
inoremap <S-C-Up>   <Esc>10<C-y>a
noremap  <S-C-Down>      10<C-e>
inoremap <S-C-Down> <Esc>10<C-e>a

" Shift-Ctrl-jk pour d√©filer (scroller) de 10 lignes (pass√© de 3 √† 5 √† 10):
noremap  <S-C-k>        10<C-y>
inoremap <S-C-k>   <Esc>10<C-y>a
noremap  <S-C-j>        10<C-e>
inoremap <S-C-j>   <Esc>10<C-e>a

" }}}
let salut="coucou4"
endif "@# fin de code d√©sactiv√© #############################################]]]]

if va5 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[
" Navigation entre fen√™tres avec Alt-fl√®ches et Alt-hjkl: {{{

" Pour vivre avec tmux, voir 2023_10_01__20_32_50


" " Alt-fl√®ches pour naviguer entre les fen√™tres, √† la mode de chez terminator: {{{
" " 2023_08_28__12_36_18 Annul√©, pour le tmux_navigator, voir √† cet autre horodatage
" noremap  <A-Up>         :wincmd k<cr>
" noremap  <A-Down>       :wincmd j<cr>
" noremap  <A-Left>       :wincmd h<cr>
" noremap  <A-Right>      :wincmd l<cr>
" inoremap <A-Up>    <esc>:wincmd k<cr>a
" inoremap <A-Down>  <esc>:wincmd j<cr>a
" inoremap <A-Left>  <esc>:wincmd h<cr>a
" inoremap <A-Right> <esc>:wincmd l<cr>a
"
" "Alt-hjkl pour naviguer de m√™me:
" noremap <A-k>           :wincmd k<cr>
" noremap <A-j>           :wincmd j<cr>
" noremap <A-h>           :wincmd h<cr>
" noremap <A-l>           :wincmd l<cr>
" " inoremap <A-k>   <Esc>mz:wincmd k<cr>`za
" " inoremap <A-j>   <Esc>mz:wincmd j<cr>`za
" " inoremap <A-h>   <Esc>mz:wincmd h<cr>`za
" " inoremap <A-l>   <Esc>mz:wincmd l<cr>`za
" " => annul√© les 4 derni:wincmd h
" " res lignes, car voil√† ce qu'elles induisaient, m:wincmd j
" " me si l'on n'√©tait pas dans un screen...
" 2023_08_28__12_36_18

" Idem, de 2023 dans vimrc_spi: {{{
" " Sur Suse:
" map k :wincmd k<cr>
" map j :wincmd j<cr>
" map h :wincmd h<cr>
" map l :wincmd l<cr>
" 
" " Sur Suse dans un screen:
" " map [1;3A :wincmd k<cr>
" " map [1;3B :wincmd j<cr>
" " map [1;3D :wincmd h<cr>
" " map [1;3C :wincmd l<cr>

" if empty($TMUX)
"     " Touches captur√©es dans vim SANS tmux avec C-V:
"     " 
"     "  
"     " 
"     " 
"     noremap  <A-Up>         :TmuxNavigateUp<cr>
"     noremap  <A-Down>       :TmuxNavigateDown<cr>
"     noremap  <A-Left>       :TmuxNavigateLeft<cr>
"     noremap  <A-Right>      :TmuxNavigateRight<cr>
"     inoremap <A-Up>    <esc>:TmuxNavigateUp<cr>a
"     inoremap <A-Down>  <esc>:TmuxNavigateDown<cr>a
"     inoremap <A-Left>  <esc>:TmuxNavigateLeft<cr>a
"     inoremap <A-Right> <esc>:TmuxNavigateRight<cr>a
"     "Alt-hjkl pour naviguer de m√™me:
"     noremap  <A-k>          :TmuxNavigateUp<cr>
"     noremap  <A-j>          :TmuxNavigateDown<cr>
"     noremap  <A-h>          :TmuxNavigateLeft<cr>
"     noremap  <A-l>          :TmuxNavigateRight<cr>
"     inoremap <A-k>   <Esc>mz:TmuxNavigateUp<cr>`za
"     inoremap <A-j>   <Esc>mz:TmuxNavigateDown<cr>`za
"     inoremap <A-h>   <Esc>mz:TmuxNavigateLeft<cr>`za
"     inoremap <A-l>   <Esc>mz:TmuxNavigateRight<cr>`za
" else
"     " Touches captur√©es dans vim dans tmux avec C-V:
"     " k
"     " j
"     " h
"     " l
"     " Ah b√© si je refais √ßa, c'est diff√©rent: ???
"     " √™
"     " √´
"     " √®
"     " √¨
"     " => √† ne SURTOUT pas mettre en inoremap...
"     " TODO v√©rifier que tout aille bien avec les fl√®ches
"     noremap  k          :TmuxNavigateUp<cr>
"     noremap  j          :TmuxNavigateDown<cr>
"     noremap  h          :TmuxNavigateLeft<cr>
"     noremap  l          :TmuxNavigateRight<cr>
"     inoremap k     <esc>:TmuxNavigateUp<cr>a
"     inoremap j     <esc>:TmuxNavigateDown<cr>a
"     inoremap h     <esc>:TmuxNavigateLeft<cr>a
"     inoremap l     <esc>:TmuxNavigateRight<cr>a
"     "Alt-hjkl pour naviguer de m√™me:
"     noremap  k          :TmuxNavigateUp<cr>
"     noremap  j          :TmuxNavigateDown<cr>
"     noremap  h          :TmuxNavigateLeft<cr>
"     noremap  l          :TmuxNavigateRight<cr>
"     inoremap k   <Esc>mz:TmuxNavigateUp<cr>`za
"     inoremap j   <Esc>mz:TmuxNavigateDown<cr>`za
"     inoremap h   <Esc>mz:TmuxNavigateLeft<cr>`za
"     inoremap l   <Esc>mz:TmuxNavigateRight<cr>`za
"     "Alt-hjkl pour naviguer de m√™me, avec l'autre mappage dans tmux (??), SANS le mode insertion:
"     noremap  √™            :TmuxNavigateUp<cr>
"     noremap  √´            :TmuxNavigateDown<cr>
"     noremap  √®            :TmuxNavigateLeft<cr>
"     noremap  √¨            :TmuxNavigateRight<cr>
" endif



" Pareil, avec les touches telles que re√ßues dans le xterm en regardant avec
" sed -n l
"  nnoremap √´ :wincmd k<cr>
"  nnoremap √™ :wincmd j<cr>
"  nnoremap √® :wincmd h<cr>
"  nnoremap √¨ :wincmd l<cr>
" Cela ne fonctionne pas en mode insertion, bien s√ªr.
" => mais si!! √áa prend le pas et √ßa marque :wincmd h quand on tape sur la touche e avec accent grave!! => annul√©!


" # => √ßa ne fonctionne point...


" }}}
let salut="coucou5"
endif "@# fin de code d√©sactiv√© #############################################]]]]


if va55 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[
" # Autre essai, selon https://www.codeography.com/2013/06/19/navigating-vim-and-tmux-splits : {{{

if exists('$TMUX')
  function! TmuxOrSplitSwitch(wincmd, tmuxdir)
    let previous_winnr = winnr()
    silent! execute "wincmd " . a:wincmd
    if previous_winnr == winnr()
      call system("tmux select-pane -" . a:tmuxdir)
      redraw!
    endif
  endfunction

  let previous_title = substitute(system("tmux display-message -p '#{pane_title}'"), '\n', '', '')
  let &t_ti = "\<Esc>]2;vim\<Esc>\\" . &t_ti
  let &t_te = "\<Esc>]2;". previous_title . "\<Esc>\\" . &t_te

  nnoremap <silent> <A-h>          :call TmuxOrSplitSwitch('h', 'L')<cr>
  nnoremap <silent> <A-j>          :call TmuxOrSplitSwitch('j', 'D')<cr>
  nnoremap <silent> <A-k>          :call TmuxOrSplitSwitch('k', 'U')<cr>
  nnoremap <silent> <A-l>          :call TmuxOrSplitSwitch('l', 'R')<cr>

" C'est √† la ligne suivante que se situe le probl√®me qui emp√™che de faire √® en mode insertion ###
  inoremap <silent> <A-h>     <esc>:call TmuxOrSplitSwitch('h', 'L')<cr>a
  inoremap <silent> <A-j>     <esc>:call TmuxOrSplitSwitch('j', 'D')<cr>a
  inoremap <silent> <A-k>     <esc>:call TmuxOrSplitSwitch('k', 'U')<cr>a
  inoremap <silent> <A-l>     <esc>:call TmuxOrSplitSwitch('l', 'R')<cr>a


  nnoremap <silent> <A-Left>       :call TmuxOrSplitSwitch('h', 'L')<cr>
  nnoremap <silent> <A-Down>       :call TmuxOrSplitSwitch('j', 'D')<cr>
  nnoremap <silent> <A-Up>         :call TmuxOrSplitSwitch('k', 'U')<cr>
  nnoremap <silent> <A-Right>      :call TmuxOrSplitSwitch('l', 'R')<cr>

  inoremap <silent> <A-Left>  <esc>:call TmuxOrSplitSwitch('h', 'L')<cr>a
  inoremap <silent> <A-Down>  <esc>:call TmuxOrSplitSwitch('j', 'D')<cr>a
  inoremap <silent> <A-Up>    <esc>:call TmuxOrSplitSwitch('k', 'U')<cr>a
  inoremap <silent> <A-Right> <esc>:call TmuxOrSplitSwitch('l', 'R')<cr>a

else
  "2023_12_16__19_47_21 
  " D√©plac√© vers .vim/vimrc_else.vim
  " => rapatri√©, avec des tests infructueux pour essayer avec Meta au lieu de Alt, en appelant la fonction Bonjour, pour voir:
  " nnoremap <M-h>                   :Bonjour h<cr>
  nnoremap <A-h>                   :wincmd h<cr>
  nnoremap <A-j>                   :wincmd j<cr>
  nnoremap <A-k>                   :wincmd k<cr>
  nnoremap <A-l>                   :wincmd l<cr>

  nnoremap <A-Left>                :wincmd h<cr>
  nnoremap <A-Down>                :wincmd j<cr>
  nnoremap <A-Up>                  :wincmd k<cr>
  nnoremap <A-Right>               :wincmd l<cr>


" C'est √† la ligne suivante que se situe le probl√®me qui emp√™che de faire √® en mode insertion ###
  " inoremap <M-h>              <esc>:Bonjour h<cr>a
  inoremap <A-h>              <esc>:wincmd h<cr>a
  inoremap <A-j>              <esc>:wincmd j<cr>a
  inoremap <A-k>              <esc>:wincmd k<cr>a
  inoremap <A-l>              <esc>:wincmd l<cr>a

  inoremap <A-Left>           <esc>:wincmd h<cr>a
  inoremap <A-Down>           <esc>:wincmd j<cr>a
  inoremap <A-Up>             <esc>:wincmd k<cr>a
  inoremap <A-Right>          <esc>:wincmd l<cr>a

" source $HOME/.vim/vimrc_else.vim
endif


" }}}

" }}}
" }}}
let salut="coucou55"
endif "@# fin de code d√©sactiv√© #############################################]]]]

if va6 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[
""""""""""""""""""""""""""""""""""""""""""""""""""
" Compl√©tion par tabulation: √† partir d'un vimrc trouv√© sur la Toile: {{{
""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""
" Fichier .vimrc de Nicolas Gressier
" Cr√©√© le 11 mai 2006
" Yoshidu62@gmail.com
" Mise √† jour : 03/06/2009
" Version 2.6
""""""""""""""""""""""""""""""""""""""""""""""""""
"Compl√©tion par tabulation: {{{
""""""""""""""""""""""""""""""""""""""""""""""""""
function! CleverTab()
    "check if at beginning of line of after a space
    if strpart(getline('.'), 0, col('.')-1) =~ '^\s*$'
    return "\<Tab>"
    else
    "use know-word completion
    "return "\<C-N>"
    "use know-word completion, mais plut√¥t √† l'envers
    return "\<C-P>"
    endif
endfunction

function! CleverTabShift()
    "check if at beginning of line or after a space
    if strpart(getline('.'), 0, col('.')-1) =~ '^\s*$'
    return "\<S-Tab>"
    else
    "use known-word completion, √† l'endroit
    return "\<C-N>"
    endif
endfunction

"Mapping sur la touche Tab
inoremap <Tab> <C-R>=CleverTab()<CR>

"et pareil sur la combinaison de touches Shift Tab:
inoremap <S-Tab> <C-R>=CleverTabShift()<CR>
" }}}

" }}}
let salut="coucou6"
endif "@# fin de code d√©sactiv√© #############################################]]]]

if va7 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[
" Ctrl-Tab pour naviguer entre les fen√™tres (bof, peu usit√©, abandonn√© le 2022_03_24__18_26_16 avec un " devant): {{{

" " MARCHE PAS :
" map <C-Tab> <C-w><C-w>
" 2023_08_03__18_30_38 => si, √ßa fonctionne, mais √ßa n'est pas ce que je souhaite


" "Marche =>
" " http://stackoverflow.com/questions/2686766/mapping-c-tab-in-my-vimrc-fails-in-ubuntu
" " ...
" " Put this in your .vimrc:

" " !! Important - instead of XXXX you must type CTRL-V and then Esc OR copy-paste the whole text and run %s/\(set <F1[34]>=\)XXXX/\=submatch(1) . "\33"/g which is copy-pastable (insert it with <CTRL-R> +).
" set timeout timeoutlen=1000 ttimeoutlen=100
" set <F13>=[27;5;9~
" "nnoremap <F13> gt
" map <F13> <C-w><C-w>
" set <F14>=[27;6;9~
" "nnoremap <F14> gT
" "map <F14> :tabNext<CR>
" map <F14> <C-w><S-w>
" "And restart vim.
" "Done.
" " Pareil, pour le mode insertion (c'est quand m√™me commode):
" inoremap <F13> <Esc><C-w><C-w>a
" inoremap <F14> <Esc><C-w><S-w>a

" }}}
let salut="coucou7"
endif "@# fin de code d√©sactiv√© #############################################]]]]

if va8 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[

" Pour naviguer dans les onglets (bof => non, retent√© le 2022_03_24__18_26_16): {{{

noremap      <C-tab>            :tabnext<cr>
noremap      <C-S-tab>          :tabprevious<cr>
"noremap     <C-tab>            :tabnext<cr>
"""map       <C-w>              :tabclose<cr> "Surtout pas! Quand on commence √† jouer avec les fen√™tres, √ßa interf√®re, mal!
inoremap     <C-S-tab>  <ESC>   :tabprevious<cr>a
inoremap     <C-tab>    <ESC>   :tabnext<cr>a

if empty($TMUX)
" Ceci ne fonctionne pas dans tmux, √ßa dit que "E73: La pile des marqueurs est vide"
" Donc on met √ßa dans un if
  noremap  <C-t>           :tabnew<cr>
  inoremap <C-t>      <ESC>:tabnew<cr>
else
  noremap                :tabnew<cr>
  inoremap          <ESC>:tabnew<cr>
endif

" Idem, de 2023 dans vimrc_spi: {{{
" "# 2023_06_29__08_46_13 Fonctionne avec gvim, mais point avec vim...
" noremap      <C-tab>            :tabnext<cr>
" nmap     <C-tab>            :tabnext<cr>
" nnoremap <C-tab>            :tabnext<cr>
" inoremap <C-tab> <ESC>      :tabnext<cr>a
" imap     <C-tab> <ESC>      :tabnext<cr>a
" map      <C-S-tab>          :tabprevious<cr>
" nmap     <C-S-tab>          :tabprevious<cr>
" nnoremap <C-S-tab> <ESC>    :tabprevious<cr>
" inoremap <C-S-tab> <ESC>    :tabprevious<cr>a
" }}}

" Idem, de 2023 dans vimrc_spi: {{{

" " Sur la Suse:
" " Voil√† ce que donne Ctrl-Tab dans vim:
" " [27;5;9~
" map      [27;5;9~         :tabnext<cr>
" nmap     [27;5;9~         :tabnext<cr>
" nnoremap [27;5;9~         :tabnext<cr>
" inoremap [27;5;9~         :tabnext<cr>a
" imap     [27;5;9~  <ESC>  :tabnext<cr>a
" " Et voil√† ce que donne Shift-Ctrl-Tab dans vim:
" " [27;6;9~
" map      [27;6;9~  <ESC>  :tabprevious<cr>
" nmap     [27;6;9~  <ESC>  :tabprevious<cr>
" nnoremap [27;6;9~  <ESC>  :tabprevious<cr>
" inoremap [27;6;9~  <ESC>  :tabprevious<cr>a

" }}}
" 2024_03_25__14_01_26

"Alt-+- pour retailler les fen√™tres:
nnoremap <A-=> <C-W>=
nnoremap  <A-+> :vertical resize +5<cr>
nnoremap  <A--> :vertical resize -5<cr>
" map  <A-kPlus> :vertical resize +5<cr>
" map  <A-kPlus> :vertical resize +5<cr>
" noremap <A-kPlus>  :vertical resize +5<cr>
" noremap <A-kPlus>  :vertical resize +5<cr>
" => les vertical resize ne fonctionnent pas _______________TODO__________________ faire fonctionner, un beau jour


" Bof: je pr√©f√®re naviguer dans les onglets avec Ctrl-PgUp/Dn: => 2022_03_25__21_10_28 marde, √ßa ne fonctionne pas.
if empty($TMUX)
    nnoremap     <C-PageUp>         :tabprevious<cr>
    inoremap     <C-PageUp>    <ESC>:tabprevious<cr>a
    nnoremap     <C-PageDown>       :tabnext<cr>
    inoremap     <C-PageDown>  <ESC>:tabnext<cr>a
else
    " Dans vim dans tmux, C-V donne √ßa:
    " Ctrl-PgDn:
    " [6;5~
    " Ctrl-PgUp:
    " [5;5~
    " Ctrl-Tab:
    " 	
    " Maj-Ctrl-Tab:
    " 	
    nnoremap  [5;5~       :tabprevious<cr>
    inoremap  [5;5~  <ESC>:tabprevious<cr>a
    nnoremap  [6;5~       :tabnext<cr>
    inoremap  [6;5~  <ESC>:tabnext<cr>a
endif

if empty($TMUX)
  " Navigation entre les onglets en mode vimesque:
  nnoremap <S-A-l>         :tabnext<cr>
  inoremap <S-A-l>  mz<Esc>:tabnext<cr>`za
  nnoremap <S-A-h>         :tabprevious<cr>
  inoremap <S-A-h>  mz<Esc>:tabprevious<cr>`za
else
  nnoremap √å               :tabnext<cr>
  inoremap √å        mz<Esc>:tabnext<cr>`za
  nnoremap √à               :tabprevious<cr>
  inoremap √à        mz<Esc>:tabprevious<cr>`za
endif




" Poubelle:
"     nmap      <C-PageUp>         :tabprevious<cr>
"     nmap      <C-PageUp>         :tabprevious<cr>
"     noremap      <C-PageDown>       :tabnext<cr>
"     nnoremap     <C-PageDown>       :tabnext<cr>
"     ""noremap      <C-t>              :tabnew<cr>
"     ""nnoremap <C-t>                  :tabnew<cr>
"     ""inoremap <C-t>             <ESC>:tabnew<cr>i
"     """map <C-w>                      :tabclose<cr> "Surtout pas! Quand on commence √† jouer avec les fen√™tres, √ßa interf√®re, mal!

" Idem, de 2023 dans vimrc_spi: {{{
" "map      <C-PageDown>       :tabnext<cr>
" "nmap     <C-PageDown>       :tabnext<cr>
" "nnoremap <C-PageDown>       :tabnext<cr>
" "inoremap <C-PageDown> <ESC> :tabnext<cr>i
" map      <C-PageUp>         :tabprevious<cr>
" nmap     <C-PageUp>         :tabprevious<cr>
" nnoremap <C-PageUp>         :tabprevious<cr>
" inoremap <C-PageUp> <ESC>   :tabprevious<cr>i
" 
" map      <C-t>              :tabnew<cr>
" nnoremap <C-t>              :tabnew<cr>
" inoremap <C-t> <ESC>        :tabnew<cr>i
" 
" map      <C-t>              :tabnew<cr>
" nmap     <C-t>              :tabnew<cr>
" imap     <C-t> <ESC>        :tabnew<cr>i
" "map <C-w> :tabclose<cr> "Surtout pas! Quand on commence √† jouer avec les fen√™tres, √ßa interf√®re, mal!
" }}}

" _______________JEANSUIL√Ä_____________


"2023_07_18__23_02_42 solution plus VIMesque:
nnoremap H gT
nnoremap L gt

" }}}
let salut="coucou8"
endif "@# fin de code d√©sactiv√© #############################################]]]]

if va9 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[
" 2024_03_28__10_04_16 
"Alt-+- pour retailler les fen√™tres: (ne fonctionne pas) {{{
"noremap  <A-+> :vertical resize +5<cr>
"noremap  <A--> :vertical resize -5<cr>
"noremap  <A-kPlus> :vertical resize +5<cr>
"noremap  <A-kMinus> :vertical resize -5<cr>
" 2024_03_28__10_04_16 
" }}}
let salut="coucou9"
endif "@# fin de code d√©sactiv√© #############################################]]]]

if va10 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[
" Autocmd: {{{
" _______________ENCOURS_______________
" Only do this part when compiled with support for autocommands. {{{
if has("autocmd")
  " When editing a file, always jump to the last known cursor position.
  " Don't do it when the position is invalid or when inside an event handler
  " (happens when dropping a file on gvim).
  autocmd BufReadPost *
    \ if line("'\"") > 0 && line("'\"") <= line("$") |
    \   exe "normal g`\"" |
    \ endif
endif " has("autocmd")

" }}}

" }}}
let salut="coucou10"
endif "@# fin de code d√©sactiv√© #############################################]]]]

if va11 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[
" F10 - La correction orthographique, c'est tr√®s tr√®s bien {{{
noremap ,c :w<CR>:!aspell -c %<CR>:e %<CR>
" Pour le paragraphe en cours:
noremap <F10> vip :w! /tmp/tmp_current_paragraph<cr>dip<up>:!aspell -c /tmp/tmp_current_paragraph<cr> :r /tmp/tmp_current_paragraph<cr>
" i<cr>
" }}}
let salut="coucou11"
endif "@# fin de code d√©sactiv√© #############################################]]]]

if va12 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[
" F9 - La dict√©e, c'est tr√®s tr√®s bien aussi, pour le paragraphe en cours: {{{
noremap <F9> vip :w! /tmp/tmp_vim_block<cr> :!espeak -v fr -s 200 -f /tmp/tmp_vim_block &<cr>


" Pareil, en anglais:
noremap <S-F9> vip :w! /tmp/tmp_vim_block<cr> :!espeak -v en -s 200 -f /tmp/tmp_vim_block &<cr>

" }}}
let salut="coucou12"
endif "@# fin de code d√©sactiv√© #############################################]]]]

if va13 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[
" copi√© depuis /usr/share/doc/hibernate/examples/hibernate.vim.gz {{{
   augroup filetypedetect
       au BufNewFile,BufRead hibernate.conf set filetype=hibernate
       au BufNewFile,BufRead common.conf set filetype=hibernate
       au BufNewFile,BufRead suspend2.conf set filetype=hibernate
       au BufNewFile,BufRead disk.conf set filetype=hibernate
       au BufNewFile,BufRead ram.conf set filetype=hibernate
       au BufNewFile,BufRead .vimrc set syntax=vim
   augroup END

" }}}
let salut="coucou13"
endif "@# fin de code d√©sactiv√© #############################################]]]]

if va14 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[
" F7 - horodatage: {{{
"###################################################################################

" mapper F7 avec l'insertion de timestamp, comme dans le bon vieux ultraedit:
"brouillons: {{{
"map <F7> :r !date +\%d/\%m/\%Y\ \%T <Enter>
"07/10/2013 09:51:06
"map <F7> :r !date +\%d_\%m_\%Y__\%T \| sed -e 's/\:/_/g' <Enter>
"23_12_2013__15_48_43
"map <F7> :r !date +\%Y_\%m_\%d__\%T \| sed -e 's/\:/_/g' <Enter>
"2013_12_29__20_29_38

" Je mets la date en ISO 8601, plut√¥t:
"r !date +\%Y_\%m_\%d__\%T
"2014_01_01__21:55:01
"r !date +\%Y-\%m-\%d_\%T
"2014-01-01_21:55:51
"map <F7> :r !date +\%Y-\%m-\%d_\%T \| sed -e 's/\:/h/' \| sed -e 's/\:/m/' <Enter>
"non, plut√¥t en ISO underscor√©, comme dans le .bashrc:
"map <F7> :r !date +\%Y_\%m_\%d__\%T \| sed -e 's/\:/_/g' <Enter>
"map <F7> :r!date +\%Y_\%m_\%d__\%T \| sed -e 's/\:/h/' \| sed -e 's/\:/m/'<Enter>
"2014_01_03__14h45m36
"2014_01_07__16h34m19
" }}}
noremap  <F7>      :r !date +\%Y_\%m_\%d__\%T \| sed -e 's/\:/_/g'<cr>A<space>
inoremap <F7> <Esc>:r !date +\%Y_\%m_\%d__\%T \| sed -e 's/\:/_/g'<cr>A<space>
"2014_01_14__08_53_38
"###################################################################################
" }}}

" mapper F2 avec la ligne courante √† faire tourner en tant que commande vi (:) {{{
" map <F2> <Esc>V<Left><Home>:<S-Ins><Enter>
" => marche pas...
" nnoremap <F2> <Esc>V<Left><Home>:<S-Ins><CR>
" %s/nnoremap/ouais√ßaamarch√©/gc
"
"
" }}}


" F11 - recherche d'√©tiquettes √† faire, en cours, etc. {{{
"mapper F11 avec la recherche de la pr√©c√©dente occurrence de:
"    _______________ENCOURS_______________ 
" ou @# 
" ou _______________TODO__________________
" nnoremap <F11>     :silent!      ?\<_______________ENCOURS_______________\\|@#\\|_______________TODO__________________<cr>
" inoremap <F11>     :silent! <Esc>?\<_______________ENCOURS_______________\\|@#\\|_______________TODO__________________<cr>a
nnoremap <F11>                   ?\<_______________ENCOURS_______________\\|@#\\|_______________TODO__________________\\|_______________JEANSUIL√Ä_____________\\|\<__.*JEAN.*SUI.*L[A√Ä].*__<cr>zO
inoremap <F11>              <Esc>?\<_______________ENCOURS_______________\\|@#\\|_______________TODO__________________\\|_______________JEANSUIL√Ä_____________\\|\<__.*JEAN.*SUI.*L[A√Ä].*__<cr>a

"mapper Shift-F11 avec la m√™me chose, dans l'autre sens:
" nnoremap <S-F11>   :silent!      /\<_______________ENCOURS_______________\\|@#\\|_______________TODO__________________<cr>
" inoremap <S-F11>   :silent! <Esc>/\<_______________ENCOURS_______________\\|@#\\|_______________TODO__________________<cr>a
nnoremap <S-F11>                 /\<_______________ENCOURS_______________\\|@#\\|_______________TODO__________________\\|_______________JEANSUIL√Ä_____________\\|\<__.*JEAN.*SUI.*L[A√Ä].*__<cr>zO
inoremap <S-F11>            <Esc>/\<_______________ENCOURS_______________\\|@#\\|_______________TODO__________________\\|_______________JEANSUIL√Ä_____________\\|\<__.*JEAN.*SUI.*L[A√Ä].*__<cr>a



" Idem, de 2023 dans vimrc_spi: {{{
" "mapper F11 avec la recherche de la pr√©c√©dente occurrence de _______________ENCOURS_______________ et autres √©tiquettes usuelles
" " nnoremap <F11>          ?\<_______________ENCOURS_______________\\|@#\\|TODO\\|FIXME<cr>
" " inoremap <F11>     <Esc>?\<_______________ENCOURS_______________\\|@#\\|TODO\\|FIXME<cr>a
" nnoremap <F11>          ?\<_______________ENCOURS_______________\\|@#\\|_______________TODO__________________\\|_______________JEANSUIL√Ä_____________<cr>zO
" inoremap <F11>     <Esc>?\<_______________ENCOURS_______________\\|@#\\|_______________TODO__________________\\|_______________JEANSUIL√Ä_____________<cr>a
" 
" 
" "mapper Shift-F11 avec la m√™me chose, dans l'autre sens:
" " nnoremap <S-F11>        /\<_______________ENCOURS_______________\\|@#\\|TODO\\|FIXME<cr>
" " inoremap <S-F11>   <Esc>/\<_______________ENCOURS_______________\\|@#\\|TODO\\|FIXME<cr>a
" nnoremap <S-F11>      \<_______________ENCOURS_______________\\|@#\\|_______________TODO__________________\\|_______________JEANSUIL√Ä_____________<cr>zO
" inoremap <S-F11> <Esc>\<_______________ENCOURS_______________\\|@#\\|_______________TODO__________________\\|_______________JEANSUIL√Ä_____________<cr>a
" 
" 
" ""mapper Ctrl-F11 avec la recherche de la pr√©c√©dente occurrence de @#
" "nnoremap <C-F11>        ?@#<cr>
" "inoremap <C-F11>   <Esc>?@#<cr>a
" "
" ""mapper Ctrl-Shift-F11 avec la m√™me chose, dans l'autre sens:
" "nnoremap <C-S-F11>        /@#<cr>
" "inoremap <C-S-F11>   <Esc>/@#<cr>a
" " => inutile, F11 fait √ßa tout seul
" " => plut√¥t, on va mapper pour chercher les TODO et FIXME (F11 est plus confortable pour seulement les encours et @#)
" nnoremap <C-F11>        ?@#\\|TODO\\|FIXME<cr>
" inoremap <C-F11>   <Esc>?@#\\|TODO\\|FIXME<cr>a
" " et dans l'autre sens:
" nnoremap <C-S-F11>      /@#\\|TODO\\|FIXME<cr>
" inoremap <C-S-F11> <Esc>/@#\\|TODO\\|FIXME<cr>a
" 
" 
" "mapper Alt-F11 avec 32 fois souligner, pour annuler un tag _______________ENCOURS_______________truc ou _______________TODO__________________machin, juste apr√®s avoir fait un F11 pour y arriver:
" nnoremap <A-F11>        32r_<Esc>
" 
" " }}}



" Aller au tag actue*l*, aller *L*√†: mapper Ctrl-L pour aller *L*√†:
nnoremap   <C-l>   :silent!       /\<__.*JEAN.*SUI.*L[A√Ä].*__<cr>zO$
inoremap   <C-l>   :silent! <Esc> /\<__.*JEAN.*SUI.*L[A√Ä].*__<cr>$a

" avec Maj enfonc√©e, dans *L*'autre sens:
nnoremap  <S-C-l>   :silent!       ?\<__.*JEAN.*SUI.*L[A√Ä].*__<cr>zO$
inoremap  <S-C-l>   :silent! <Esc> ?\<__.*JEAN.*SUI.*L[A√Ä].*__<cr>$a
" _______________TODO__________________ ajouter le message:
" echo "=> on est L√†√†√†√†"<cr>
" nnoremap   <C-l>   :silent!      ?\<___?JEAN.*SUI.*L[A√Ä]?___?<cr>zO :ec "=> on est L√†"
  " \_ le echo, ech, echom ne fonctionne point du tout.

" Idem, de 2023 dans vimrc_spi: {{{
" nnoremap <C-L>      \<_______________JEANSUIL√Ä_____________<cr>zO
" inoremap <C-L> <Esc>\<_______________JEANSUIL√Ä_____________<cr>a
" }}}
" }}}


" F12 - derni√®re macro invoqu√©e: {{{
"mapper F12 avec la derni√®re macro:
noremap  <F12>      @@
inoremap <F12> <ESC>@@a
" }}}


" ! - Highlighter^Wsurligner toutes les occurrences du mot sous le curseur: {{{
"http://vim.wikia.com/wiki/Auto_highlight_current_word_when_idle {{{
"
"created 2003 ¬∑ complexity basic ¬∑ author mosh ¬∑ version 6.0
"Vim can easily highlight all search pattern matches and search for the current word (the word under the cursor). This tip shows how to automatically highlight all occurrences of the current word without searching. That can be useful when examining unfamiliar source code: just move the cursor to a variable, and all occurrences of the variable will be highlighted.
"
"
" Highlight all instances of word under cursor, when idle.
" Useful when studying strange source code.
" Type z/ to toggle highlighting on/off.
function! AutoHighlightToggle()
  let @/ = ''
  if exists('#auto_highlight')
    au! auto_highlight
    augroup! auto_highlight
    setl updatetime=4000
    echo 'Highlight current word: off'
    return 0
  else
    augroup auto_highlight
      au!
      au CursorHold * let @/ = '\V\<'.escape(expand('<cword>'), '\').'\>'
    augroup end
    setl updatetime=500
    echo 'Highlight current word: ON'
    return 1
  endif
endfunction
" on fait √ßa avec... ! (pas loin de *)
noremap ! :if AutoHighlightToggle()<Bar>set hls<Bar>endif<CR>
" non, plut√¥t avec... ¬µ (maj - *)
" => marche pas
"map <S-*> :if AutoHighlightToggle()<Bar>set hls<Bar>endif<CR>
" ni <C-*> ni <S-C-*> ni <S-*> ... donc retour au !

" }}}

" "Autre solution pour highlighter toutes les occurrences du mot sous le curseur: (bof, comment√©) {{{
" "https://vi.stackexchange.com/questions/17493/how-to-highlight-match-but-not-search-the-word-under-cursor
"
" "You indicate that you were trying to get the mapping to work with <cword>. Though the answer you accepted is just fine I'm surprised no one answered with a corrected use of that.
" "Normally the string on the RHS of a mapping is executed literally as an Ex command. No pre- expansion/evaluation/processing of the string occurs. So :match in
" "nnoremap <F5> :match StatusLineTerm /.expand(<cword>)./
" "(along the lines of your attempt) will try to literally match the string '.expand(<cword>).'
" "If we want the string or some portion of it to be expanded/evaluated we have to do it ourselves by passing it to the :exec command as an expression:
" "exec 'match StatusLineTerm /' . expand('<cword>') . '/'
" "Note that we surround with quotes any parts that we want to use literally and append them with .. The rest is evaluated. (Also note that <cword> is a special string and needs to be quoted before being passed to expand().)
" "So, the mapping you were originally going for is:
" "nnoremap <F5> :exec 'match StatusLineTerm /' . expand('<cword>') . '/'<CR>
"
" " on fait √ßa avec... ! (pas loin de *)
" " nnoremap ! :windo exec 'match StatusLineTerm /' . expand('<cword>') . '/'<CR>
" " => fonctionne pas
" " Autre essai:
" " nnoremap ! :let tt=expand('<cword>') windo exec 'match StatusLineTerm /' . tt . '/'<CR>
"
" " Pas mieux, encore autre chose, avec une fonction:
" function! HighlightCurrentWord(text)
"   windo exec 'match StatusLineTerm /' . a:text . '/'
" endfunction
" nnoremap ! :call HighlightCurrentWord(expand('<cWORD>'))<cr>
"
" }}}

" "Encore une autre solution pour highlighter toutes les occurrences du mot sous le curseur: {{{

" D√©finition des couleurs:
" highlight HighlightCurrentWord guibg=#463626 ctermbg=94
" \_ moche
" highlight HighlightCurrentWord guibg=#463626 ctermbg=0
" \_ nulach
" => retour au d√©part
highlight HighlightCurrentWord guibg=#463626 ctermbg=9 ctermfg=0

augroup highlight_current_word
    au!
    au CursorMoved * call Highlight_current_word()
augroup END

" Il faut pouvoir toggler cela, faisons une variable:
let g:highlight_current_word = 1

function! Highlight_current_word()
  let exclude_ft = ["nerdtree", "fugitive", "fzf"]
    if index(exclude_ft, &filetype) == -1
      if g:highlight_current_word == 1
        try
            call matchdelete(481516)
        catch
        endtry
        let current_word = escape(expand("<cword>"), "\\/[]*~")
        call matchadd("HighlightCurrentWord", "\\<" . current_word ."\\>", 0, 481516)
      endif
    endif
endfunction

function! Toggle_highlightCurrentWord()
  if g:highlight_current_word == 1
    let g:highlight_current_word = 0
        try
            call matchdelete(481516)
        catch
        endtry
    echom "Current word not highlighted"
  else
    let g:highlight_current_word = 1
    call Highlight_current_word() 
    echom "Current word highlighted"
  endif
endfunction

" Pour basculer (toggler)√ßa, faisons avec Ctrl-F2, par exemple:
noremap <C-F2> :call Toggle_highlightCurrentWord()<cr>

" }}}
" }}}


"quelques conseils de http://vim.wikia.com/wiki/Using_standard_editor_shortcuts_in_Vim; fait un peu (beaucoup!) de m√©nage, quand m√™me: {{{

"set smartindent
set tabstop=4
set shiftwidth=4
"set expandtab

"set mouse=a
"set nu

"noremap <C-a> GVgg
"noremap <C-n> :enew
"noremap <C-o> :e . <Enter>
"noremap <C-s> :w <Enter>
"noremap <C-c> y
"noremap <C-v> p
"noremap <C-x> d
"noremap <C-z> u
"noremap <C-t> :tabnew <Enter>
"noremap <C-i> >>
"noremap <C-w> :close <Enter>
"noremap <C-W> :q! <Enter>
"noremap <C-f> /
"noremap <C-h> :%s/
"noremap <S-t> vat
"noremap <S-T> vit
"noremap <S-{> vi{
"noremap <S-(> vi(
"noremap <S-[> vi[
" }}}

let salut="coucou14"
endif "@# fin de code d√©sactiv√© #############################################]]]]

if va15 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[

" Raccourcis pour quitter et sauver comme tout le monde: {{{
" Pour sauvegarder "comme tout le monde" avec un Ctrl-S
nnoremap <c-s>      :w<CR>
inoremap <c-s> <Esc>:w<CR>a
onoremap <c-s> <Esc>:w<CR><Insert><Insert>
" Dans tmux, voil√† ce que donne Ctrl-S avec Ctrl-V avant: 
nnoremap <>       :w<CR>
inoremap <>  <Esc>:w<CR>a
onoremap <>  <Esc>:w<CR><Insert><Insert>
" => √ßa ne fonctionne point...
nnoremap <> :w<CR>
inoremap <> <Esc>:w<CR>a
" => √ßa ne fonctionne point non plus...


" Pour quitter "comme tout le monde" avec un Ctrl-Q, poil au...
if empty($TMUX)
    nnoremap <c-q>      :q<CR>
    inoremap <c-q> <Esc>:q<CR>
    nnoremap <>       :q<CR>
    inoremap <>  <Esc>:q<CR>
" => √ßa ne fonctionne point non plus dans tmux...
else
    nnoremap          :q<CR>
    inoremap          :q<CR>
endif

" Pour tout s√©lectionner "comme tout le monde" avec un Ctrl-A:
if empty($TMUX)
    nnoremap <c-a>      :silent! mzggVG<Esc>`z
    inoremap <c-a> <Esc>mzggVG<Esc>`za
    nnoremap <>       :silent! mzggVG<Esc>`z
    inoremap <>  <Esc>mzggVG<Esc>`za
" => TODO √ßa ne donne pas toujours satisfaction: @#√† peaufiner, au besoin
endif


" }}}


"Je me fais des raccourcis pour les Fn:
"noremap <F1>
"noremap <F2>
"noremap <F3>
"noremap <F4>


" Pour faire tourner le paragraphe ou le f√©chier courant: {{{

" TODO il y a beaucoup de redondances: factoriser, faire des fonctions. Penser √† quelque chose de g√©n√©rique, un genre de wrapper peut-√™tre.
" Brouillon d'id√©es:{{{

function! SaveCurrentLineToTmpCodeFile()
  " ...
endfunction

function! SaveCurrentParagraphToTmpCodeFile()
  " ...
endfunction

function! RunCurrentFile()
  " Ex√©cute le fichier qu'on est en train d'√©diter
  " echo "Le fichier qu'on est en train d'√©diter est" @%
  " call DebugPauseWaitForKeyPress()
  " echo "Son chemin est" expand('%:p:h')
  " call DebugPauseWaitForKeyPress()
  call RunFile( expand('%:p'))
endfunction


function! RunFile(file)
  " Ex√©cute le fichier pass√© en argument
  let full_file_path = shellescape(expand(a:file))
  echo "On va ex√©cuter le fichier" full_file_path
  " call DebugPauseWaitForKeyPress()
  execute '!'.full_file_path
  " call DebugPauseWaitForKeyPress()
  " echom "Voil√†, c'est fait."
endfunction


function! RunTmpCodeFile()
  try
    execute 'wincmd ' . a:direction
    " ...
  catch
    echohl ErrorMsg | echo 'E11: Invalid in command-line window; <CR> executes, CTRL-C quits: wincmd k' | echohl None
  endtry
endfunction

function! PasteOutputFromRanTmpCodeFile()
  " ...
endfunction



" }}}


"pour sauver et faire tourner le fichier courant par rebol^W n'importe quoi, pourvu que le chieboum soit bien fait:
"to save and run the current file by rebol^W interpreter^W anything, as long as the shebang is correct:
"noremap <F5> :w<cr> :!rebol -qs %<cr>
" *** ENLEV√â POUR VIMSPECTOR( ***
" noremap  <F5>      :w<cr> :!./%<cr>
noremap  <F5>      :call RunCurrentFile()<cr>
inoremap <F5> <esc>:w<cr> :!./%<cr>a
" *** ENLEV√â POUR VIMSPECTOR) ***
"Utile pour un script Rebol existant, qu'on n'a nulle intention de modifier, et qui n'a aucun chieboum:
noremap <s-F5>     :!rebol -qs %<cr>


""pour faire tourner la s√©lection courante par rebol:
""to interpret the current visual selection by rebol interpreter:
"map <F6> :w! tmp_vim_block<cr> :!echo "rebol []" > tmp_vim_block.rr && cat tmp_vim_block.rr tmp_vim_block > tmp_vim_block.r && rebol -qs tmp_vim_block.r && rm tmp_vim_block.rr tmp_vim_block.r tmp_vim_block<cr>

"mieux:
"even better:

"pour faire tourner le paragraphe courant par rebol:
"to interpret the current paragraph by rebol interpreter:
noremap <F6>        mzvip :w! /tmp/tmp_vim_block<cr>:!echo "rebol []" > /tmp/tmp_vim_block.rr && echo 'prin rejoin [newline "=>"         {;==== Rebol code evaluation output: ========= }] ' >> /tmp/tmp_vim_block.rr && echo 'print "{{{"' >> /tmp/tmp_vim_block.rr && cat /tmp/tmp_vim_block.rr /tmp/tmp_vim_block > /tmp/tmp_vim_block.r && echo 'prin {;==========================================}' >> /tmp/tmp_vim_block.r && echo 'print " }}}" wait 0.1 print rejoin [newline {... Entr√©e pour continuer}] input' >> /tmp/tmp_vim_block.r && rebol -qs /tmp/tmp_vim_block.r<cr>`z
inoremap <F6> <ESC> mzvip :w! /tmp/tmp_vim_block<cr>:!echo "rebol []" > /tmp/tmp_vim_block.rr && echo 'prin rejoin [newline "=>"         {;==== Rebol code evaluation output: ========= }] ' >> /tmp/tmp_vim_block.rr && echo 'print "{{{"' >> /tmp/tmp_vim_block.rr && cat /tmp/tmp_vim_block.rr /tmp/tmp_vim_block > /tmp/tmp_vim_block.r && echo 'prin {;==========================================}' >> /tmp/tmp_vim_block.r && echo 'print " }}}" wait 0.1 print rejoin [newline {... Entr√©e pour continuer}] input' >> /tmp/tmp_vim_block.r && rebol -qs /tmp/tmp_vim_block.r<cr>`za
"(des vieilleries:) {{{
" noremap  <F6>       mzvip :w! /tmp/tmp_vim_block<cr>:!echo "rebol []" > /tmp/tmp_vim_block.rr && echo 'prin rejoin [newline "=>" newline {;======== code evaluation output: ========= }] ' >> /tmp/tmp_vim_block.rr && echo 'print "{{{"' >> /tmp/tmp_vim_block.rr && cat /tmp/tmp_vim_block.rr /tmp/tmp_vim_block > /tmp/tmp_vim_block.r && echo 'prin {;==========================================}' >> /tmp/tmp_vim_block.r && echo 'print " }}}" wait 0.1 print rejoin [newline {... Entr√©e pour continuer}] input' >> /tmp/tmp_vim_block.r && rebol -qs /tmp/tmp_vim_block.r<cr>`z
"map <F6> vip :w! tmp_vim_block<cr> :!echo "rebol []" > tmp_vim_block.rr && cat tmp_vim_block.rr tmp_vim_block > tmp_vim_block.r && rebol -qs tmp_vim_block.r && rm tmp_vim_block.rr tmp_vim_block.r tmp_vim_block<cr>
"map <F6> vip :w! /tmp/tmp_vim_block<cr>:!echo "rebol []" > /tmp/tmp_vim_block.rr && echo 'print rejoin [newline "=>" newline {;======== code evaluation output: =========} ]' >> /tmp/tmp_vim_block.rr  && cat /tmp/tmp_vim_block.rr /tmp/tmp_vim_block > /tmp/tmp_vim_block.r && echo "print {;==========================================} wait 0.5 print rejoin [newline newline newline {Entr√©e pour continuer}] input" >> /tmp/tmp_vim_block.r && rebol -qs /tmp/tmp_vim_block.r<cr>}k
"map <F6> vip :w! /tmp/tmp_vim_block<cr>:!echo "rebol []" > /tmp/tmp_vim_block.rr && echo 'prin rejoin [newline "=>" newline {;======== code evaluation output: ========= } ]' >> /tmp/tmp_vim_block.rr && echo " ; {{{" >> /tmp/tmp_vim_block.rr  && cat /tmp/tmp_vim_block.rr /tmp/tmp_vim_block > /tmp/tmp_vim_block.r && echo "prin {;==========================================}  >> /tmp/tmp_vim_block.r && echo '}}}"' >> /tmp/tmp_vim_block.r && echo "wait 0.5 print rejoin [newline newline newline {Entr√©e pour continuer}] input" >> /tmp/tmp_vim_block.r && rebol -qs /tmp/tmp_vim_block.r"<cr>}k
"KK! map <F6> vip :w! /tmp/tmp_vim_block<cr>:!echo "rebol []" > /tmp/tmp_vim_block.rr && \ echo 'prin rejoin [newline "=>" newline {;======== code evaluation output: ========= } ]' >> /tmp/tmp_vim_block.rr && echo "{{{" >> /tmp/tmp_vim_block.rr  && cat /tmp/tmp_vim_block.rr /tmp/tmp_vim_block > /tmp/tmp_vim_block.r && echo "prin {;==========================================} > /tmp/tmp_vim_block.r && echo 'print "}}}"' > /tmp/tmp_vim_block.r print rejoin [newline newline newline {Entr√©e pour continuer}] input" >> /tmp/tmp_vim_block.r && rebol -qs /tmp/tmp_vim_block.r<cr>}k
"map <F6> vip :w! /tmp/tmp_vim_block<cr>:!echo "rebol []" > /tmp/tmp_vim_block.rr && echo 'prin rejoin [newline "=>" newline {;======== code evaluation output: ========= } ]' >> /tmp/tmp_vim_block.rr && echo "{{{" >> /tmp/tmp_vim_block.rr  && cat /tmp/tmp_vim_block.rr /tmp/tmp_vim_block > /tmp/tmp_vim_block.r && echo "prin {;==========================================} && echo "}}}" wait 0.5 print rejoin [newline newline newline {Entr√©e pour continuer}] input" >> /tmp/tmp_vim_block.r && rebol -qs /tmp/tmp_vim_block.r<cr>}k
"map <F6> vip :w! /tmp/tmp_vim_block<cr>:!echo "rebol []" > /tmp/tmp_vim_block.rr && echo 'print rejoin [newline "=>" newline {;======== code evaluation output: =========} ]' >> /tmp/tmp_vim_block.rr  && cat /tmp/tmp_vim_block.rr /tmp/tmp_vim_block > /tmp/tmp_vim_block.r && echo "print {;==========================================} wait 0.5 print rejoin [newline newline newline {Entr√©e pour continuer}] input" >> /tmp/tmp_vim_block.r && rebol -qs /tmp/tmp_vim_block.r<cr>}k
"map <F6> vip :w! /tmp/tmp_vim_block<cr>:!echo "rebol []" > /tmp/tmp_vim_block.rr && echo 'prin rejoin [newline "=>" newline {;======== code evaluation output: ========= }] ' >> /tmp/tmp_vim_block.rr && echo 'print "{{{"' >> /tmp/tmp_vim_block.rr && cat /tmp/tmp_vim_block.rr /tmp/tmp_vim_block > /tmp/tmp_vim_block.r && echo 'prin {;==========================================}' >> /tmp/tmp_vim_block.r && echo 'print " }}}" wait 0.1 print rejoin [newline newline {... Entr√©e pour continuer}] input' >> /tmp/tmp_vim_block.r && rebol -qs /tmp/tmp_vim_block.r<cr>}k
" }}}

" Pour faire √† la mode, et faire du javascript (√† reculons...), faire tourner le paragraphe courant par javascript:
nnoremap <s-F6>       mzvip :w! /tmp/tmp_vim_block<cr>:! js /tmp/tmp_vim_block && echo "Entr√©e pour poursuivre..." && read<cr>`z
inoremap <s-F6> <ESC> mzvip :w! /tmp/tmp_vim_block<cr>:! js /tmp/tmp_vim_block && echo "Entr√©e pour poursuivre..." && read<cr>`za


" Pour faire tourner le paragraphe courant par python3:
nnoremap <c-F6>       mzvip :w! /tmp/tmp_vim_block<cr>:!echo 'print("\n=>\n\# ======== Python code evaluation output: ========= {{{")' > /tmp/tmp_vim_block.pyy && cat /tmp/tmp_vim_block.pyy /tmp/tmp_vim_block > /tmp/tmp_vim_block.py && echo 'print("\# ========================================== }}}\n... Entr√©e pour continuer")' >> /tmp/tmp_vim_block.py && echo 'input()' >> /tmp/tmp_vim_block.py && python3 /tmp/tmp_vim_block.py\|\|read<cr>`z
inoremap <c-F6> <ESC> mzvip :w! /tmp/tmp_vim_block<cr>:!echo 'print("\n=>\n\# ======== Python code evaluation output: ========= {{{")' > /tmp/tmp_vim_block.pyy && cat /tmp/tmp_vim_block.pyy /tmp/tmp_vim_block > /tmp/tmp_vim_block.py && echo 'print("\# ========================================== }}}\n... Entr√©e pour continuer")' >> /tmp/tmp_vim_block.py && echo 'input()' >> /tmp/tmp_vim_block.py && python3 /tmp/tmp_vim_block.py\|\|read<cr>`za

"Pour faire tourner le paragraphe courant par un compilateur C:
" FIXME logique des raccourcis pourrie. Plut√¥t demander quel langage au d√©but, en gardant le m√™me pour faire, par exemple: F6 P (pour python) Entr√©e, et apr√®s F6 Entr√©e Entr√©e. √Ä r√©fl√©chir, puis refaire les raccourcis de mani√®re logique, en faisant tourner ligne, paragraphe, en collant ou pas la sortie apr√®s.
noremap  <s-c-F6>       mzvip :w! /tmp/tmp_vim_block.c<cr>: !gcc -g -Wall -std=c99 /tmp/tmp_vim_block.c -o /tmp/tmp_vim_block && /tmp/tmp_vim_block > /tmp/tmp_vim_block.ccc   ; echo "... Entr√©e pour continuer" && read<cr>`z
inoremap <s-c-F6> <ESC> mzvip :w! /tmp/tmp_vim_block.c<cr>: !gcc -g -Wall -std=c99 /tmp/tmp_vim_block.c -o /tmp/tmp_vim_block && /tmp/tmp_vim_block ; echo "... Entr√©e pour continuer" && read<cr>`za


" pour faire tourner le paragraphe courant par bash:
noremap  <F8>          mzvip :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && echo "... Entr√©e pour continuer" && read <cr>`z
inoremap <F8>     <esc>mzvip :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && echo "... Entr√©e pour continuer" && read <cr>`za

" pour faire tourner le paragraphe courant par bash et coller la sortie apr√®s:
" noremap  <F8>          mzvip :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && read <cr>`z
" inoremap <F8>     <esc>mzvip :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && read <cr>`za
" nnoremap <C-F8>        mzvip:w! /tmp/tmp_vim_block<cr> A<cr># => {{{<esc> :exec 'r!bash /tmp/tmp_vim_block'<cr><cr>i<cr># }}}<cr><cr><esc>`z
nnoremap <C-F8>    mzyip:redir! > /tmp/tmp_vim_block<cr>:echo @0<cr>:redir END<cr>}A<cr># => {{{<cr><cr># }}}<cr><esc>kk:exec 'r!bash /tmp/tmp_vim_block'<cr>A<cr><esc>`z}j0
" CETTE LIGNE CI-DESSUS FONCTIONNE TR√àS-TR√àS BIEN (enfin, presque; quand il y a des trucs interactifs, √ßa n'a pas l'air de trop le faire): TODO factoriser tout √ßa, et faire appel au code factoris√© (fonction? commande?)

inoremap <C-F8>   <esc>mzvip :w! /tmp/tmp_vim_block<cr>A<cr># => {{{<esc>:exec 'r!bash /tmp/tmp_vim_block'<cr><cr>a# }}}<cr><cr><esc>`z<cr>a


" pour faire tourner la ligne courante par bash:
noremap  <S-F8>        mzV   :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && read <cr>`z
inoremap <S-F8>   <esc>mzV   :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && read <cr>`za

" pour faire tourner la ligne courante par bash et coller la sortie apr√®s:
nnoremap <C-S-F8>      mzV   :w! /tmp/tmp_vim_block<cr>} o<cr># => {{{<esc> :exec 'r!bash /tmp/tmp_vim_block'<cr><cr>a<cr># }}}<cr><esc>`z
inoremap <C-S-F8> <esc>mzV   :w! /tmp/tmp_vim_block<cr>} o<cr># => {{{<esc> :exec 'r!bash /tmp/tmp_vim_block'<cr><cr>a<cr># }}}<cr><esc>`za




" Fl√ªte, F8 ne semble pas compris dans tmux:
" Voil√† ce que donne le C-V:
" [19~

" Pareil, mais pour dans tmux:
" pour faire tourner le paragraphe courant par bash:
noremap  <[19~>      mzvip :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && read <cr>`z
inoremap <[19~> <esc>mzvip :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && read <cr>`za

" Fl√ªte, S-F8 ne semble pas non plus compris dans tmux:
" Voil√† ce que donne le C-V:
" [19;2~
" pour faire tourner la ligne courante par bash:
noremap  <[19;2~>      mzV :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && read <cr>`z
inoremap <[19;2~> <esc>mzV :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && read <cr>`za



noremap <[19;2~>      mzV :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && read <cr>`z
noremap <[19;2~> <esc>mzV :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && read <cr>`zi

" }}}
let salut="coucou15"
endif "@# fin de code d√©sactiv√© #############################################]]]]


if va16 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[

"Et un raccourci pour s√©lectionner un Paragraphe: {{{
noremap <C-S-p> vip
"(enlev√© <S-p> qui fait paste avant)
"Un autre raccourci, qui utilise le symbole ¬ß (touche !):
noremap  ¬ß vip
"inoremap <C-¬ß> <esc>vipi "     => marche pas...
" }}}


" pour ouvrir l'URL (la phrase) sous le curseur par le navigateur: {{{
"noremap  <C-F8>       mzvis :w! /tmp/tmp_vim_block<cr> :!$BROWSER /tmp/tmp_vim_block && read <cr>`z
"inoremap <C-F8> <esc> mzvis :w! /tmp/tmp_vim_block<cr> :!$BROWSER /tmp/tmp_vim_block && read <cr>`za
"noremap  <C-F8>       mzvis :w! /tmp/tmp_vim_block<cr> :!$BROWSER /tmp/tmp_vim_block && read <cr>`z
"inoremap <C-F8> <esc> mzvis :w! /tmp/tmp_vim_block<cr> :!$BROWSER /tmp/tmp_vim_block && read <cr>`za
" Meuh non, bien plus simple: simplement gx et √ßa ouvre le navigateur d√©fini ainsi:
let g:netrw_browsex_viewer= "$BROWSER"
"let g:netrw_browsex_viewer= "xdg-open"
" }}}



" Pour s√©lectionner divers bidules par des double (non, d√©j√† fait) {{{
"<LeftMouse>     - Left mouse button press
"<RightMouse>    - Right mouse button press
"<MiddleMouse>   - Middle mouse button press
"<LeftRelease>   - Left mouse button release
"<RightRelease>  - Right mouse button release
"<MiddleRelease> - Middle mouse button release
"<LeftDrag>      - Mouse drag while Left mouse button is pressed
"<RightDrag>     - Mouse drag while Right mouse button is pressed
"<MiddleDrag>    - Mouse drag while Middle mouse button is pressed
"<2-LeftMouse>   - Left mouse button double-click
"<2-RightMouse>  - Right mouse button double-click
"<3-LeftMouse>   - Left mouse button triple-click
"<3-RightMouse>  - Right mouse button triple-click
"<4-LeftMouse>   - Left mouse button quadruple-click
"<4-RightMouse>  - Right mouse button quadruple-click
"<X1Mouse>       - X1 button press
"<X2Mouse>       - X2 button press
"<X1Release>     - X1 button release
"<X2Release>     - X2 button release
"<X1Drag>        - Mouse drag while X1 button is pressed
"<X2Drag>        - Mouse drag while X2 button is pressed
" }}}

"  - Right mouse button triple-click => s√©lectionne d√©j√† une ligne, je laisse.

"pour s√©lectionner une phraSe:
nnoremap <3-LeftMouse> vis

"pour s√©lectionner un Paragraphe (comme ctrl-P):
nnoremap <4-LeftMouse> vip


" Un raccourci similaire √† *, mais avec shift, √ßa fait ¬µ, qui ouvre une autre fen√™tre puis fait un *: {{{
" => tr√®s utile pour les tags
" => mince, pas pu faire :map <S-*> :split <cr>*
"                  ni:   :map <¬µ> :split <cr>*
"donc je fais avec F3, et vers le haut, c'est plus commode, avec #:
noremap <F3>      :split<cr>#
" Pareil, en mode insertion aussi:
inoremap <F3> <Esc>:split<cr>#a
"Pareil, en faisant une division verticale:
noremap <S-F3> :vsplit<cr>#
"=> ne fonctionne pas... 2023_08_04__11_54_09 => si, √ßa refonctionne (hors screen...)
" }}}

"R√©ticule; {{{
""Pour avoir un r√©ticule amusant (et utile):
"set cursorcolumn
"set cursorline
"
""Pour mettre du gris√© dans les 2 axes du r√©ticule (car le soulignement de l'axe horizontal g√™ne quelque peu la lecture):
"hi CursorLine cterm=NONE
""hi CursorLine ctermbg=Cyan
"hi CursorLine ctermbg=Grey
""hi CursorColumn ctermbg=Cyan
"
"=> En fait, d√®s qu'on est dans un ssh quelconque, ou une console, ce r√©ticule est giga-chiasseur: zou, je le zappe.

"Voici une version plus discr√®te, et basculable par <jeader>r (pour R√©ticule)
" hi CursorColumn cterm=NONE ctermbg=Grey guibg=Grey40
" hi CursorColumn cterm=underline ctermfg=11
hi CursorLine   cterm=NONE ctermbg=Grey
hi link CursorColumn CursorLine

" nnoremap <Leader>r        :set cursorline! cursorcolumn!<cr>
" inoremap <Leader>r <Esc>mz:set cursorline! cursorcolumn!<cr>`zi
" Plut√¥t avec F2 (car le d√©lai apr√®s Leader est bien trop court (d√ª √† la modif pour avoir kj qui fasse Esc...)):
nnoremap <S-F2>             :Windo set cursorline! cursorcolumn!<cr>
inoremap <S-F2>      <Esc>mz:Windo set cursorline! cursorcolumn!<cr>`za

nnoremap <F2>             :set cursorline! cursorcolumn!<cr>
inoremap <F2>      <Esc>mz:set cursorline! cursorcolumn!<cr>`za

" " Idem, de 2023 dans vimrc_spi: {{{
" " Un mapping pour switcher le r√©ticule:
" noremap  <F2>        :set cursorcolumn!<bar>set cursorline!<CR>
" inoremap <F2> <Esc>mz:set cursorcolumn!<bar>set cursorline!<CR>`za
" 
" }}}
" }}}

" Pour scroller plus confortablement, mappons Fn+Ctrl+fl√®ches avec C-D et C-U: {{{
"noremap <C-S-PageDown> <C-D>
"noremap <C-S-PageUp> <C-U>
"inoremap <C-S-PageDown> <p>
"inoremap <C-S-PageUp> <p>
"  2018_10_13__11_44_06 => ne fonctionne pas.
" }}}

" Contenu de ~/dev/postgresql/src/tools/editors/vim.samples: {{{
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" These settings are appropriate for editing PostgreSQL code with vim
" You would copy this into your .vimrc or equivalent
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if match(getcwd(), "/pgsql") >=0 ||  match(getcwd(), "/postgresql") >= 0
      set cinoptions=(0
      set tabstop=4
      set shiftwidth=4
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" }}}

" Incr√©menter et d√©cr√©menter un nombre sous le curseur: {{{

" normalement, c'est <C-A>,<C-X>, mais dans un screen c'est peu ais√©:
"Mieux, A augmente et Q (juste en-dessous sur mon AZERTY)" diminue, avec Alt:
nnoremap <A-a> <C-a>
nnoremap <A-q> <C-x>
inoremap <A-a> <C-a>
inoremap <A-q> <C-x>

" √áa ne fonctionne point ainsi dans un screen: je tente de red√©finir les choses en guettant ce qui se passe dans un:
" sed -n l
nnoremap √°      <C-a>
nnoremap √±      <C-x>
inoremap √° <Esc><C-a>a
inoremap √± <Esc><C-x>a

" Idem, de 2023 dans vimrc_spi: {{{
" Sur Suse:
nnoremap a <C-a>
nnoremap q <C-x>
inoremap a <C-a>
inoremap q <C-x>

" 32

"}}}
" Bac √† sable: 32

" }}}


" Mes macros pratiques, que je conserve: {{{
" @S Soulignements => pour mettre 32 fois _ sur une ligne de type
" _____________________________________QUELQUECHOSE
let @s = '[1~32r_[1~'

" Une tentative rat√©e pour ne souligner que les 32 premiers caract√®res du mot (et non de la ligne) courant:
" nnoremap √† b32r_

" }}}



" Pour fermer les ([{"' automagiquement:
inoremap ( ()<Left>
inoremap [ []<Left>
inoremap { {}<Left>
"inoremap " ""<Left>
" " √©tait (annul√©, √ßa met souvent le oua√Ø ...) => de nouveau annul√©
"inoremap ' ''<Left> (annul√©, √ßa met le oua√Ø dans l'apostrophage...)
inoremap < <><Left>


""2020_11_12__15_59_26 => J'annule tout √ßa: {{{
""
""" 2020_10_13__11_41_18
""" En lisant √ßa: https://realpython.com/vim-and-python-a-match-made-in-heaven/
""" Pour Vundle:
"""set nocompatible              " required  <= inutile, c'est d√©j√† mentionn√© plus haut
""filetype off                  " required
"""
""" set the runtime path to include Vundle and initialize
""set rtp+=~/.vim/bundle/Vundle.vim
""call vundle#begin()
"""
""" alternatively, pass a path where Vundle should install plugins
"""call vundle#begin('~/some/path/here')
"""
""" let Vundle manage Vundle, required
""Plugin 'gmarik/Vundle.vim'
"""
""" add all your plugins here (note older versions of Vundle
""" used Bundle instead of Plugin)
"""
""Plugin 'tmhedberg/SimpylFold'
""Plugin 'vim-scripts/indentpython.vim'
""Plugin 'scrooloose/nerdtree'
""" ...
""" All of your Plugins must be added before the following line
""call vundle#end()            " required
""filetype plugin indent on    " required
" }}}



"Pro Tip #5: Try this if you want to see the docstrings for folded code:
let g:SimpylFold_docstring_preview=1

"To add the proper PEP 8 indentation, add the following to your .vimrc:
"au BufNewFile,BufRead *.py set tabstop=4 softtabstop=4 shiftwidth=4 textwidth=79 expandtab autoindent fileformat=unix
" textwidth=79 me GONFLE gravement.
au BufNewFile,BufRead *.py set tabstop=4 softtabstop=4 shiftwidth=4 expandtab autoindent fileformat=unix
"
"For full stack development, you can use another au command for each filetype:
au BufNewFile,BufRead *.js,*.html,*.css set tabstop=2 softtabstop=2 shiftwidth=2

"Pour les fichiers shell:
au BufNewFile,BufRead *.sh set tabstop=2 softtabstop=2 shiftwidth=2 expandtab autoindent

"Pour les fichiers cobol:
" au BufNewFile,BufRead *.cbl set tabstop=4 softtabstop=4 shiftwidth=4 expandtab autoindent colorcolumn=7,72
" Mieux, pour ajouter des arr√™ts de tabulations; mais √ßa implique de devoir convertir les tabulations, amande au nez...
au BufNewFile,BufRead *.cbl set et vts=6,1,4,60 noexpandtab autoindent colorcolumn=7,8,12,72 
au BufNewFile,BufRead *.cbl :highlight ColorColumn ctermbg=7

"Flagging Unnecessary Whitespace
"You also want to avoid extraneous whitespace. You can have VIM flag that for you so that it‚Äôs easy to spot and then remove:
"au BufRead,BufNewFile *.py,*.pyw,*.c,*.h match BadWhitespace /\s\+$/




"Auto-Complete

"The best plugin for Python auto-complete is YouCompleteMe. Again, use Vundle to install:
"Bundle 'Valloric/YouCompleteMe'
    "=> bof, non, mon autocompl√©tion est d√©j√† Parfaite.


"""python with virtualenv support
""py << EOF
""import os
""import sys
""if 'VIRTUAL_ENV' in os.environ:
""  project_base_dir = os.environ['VIRTUAL_ENV']
""  activate_this = os.path.join(project_base_dir, 'bin/activate_this.py')
""  execfile(activate_this, dict(__file__=activate_this))
""EOF
"" => ? Marche pas.


" Un moignon de plugin pour corriger la faute d'orthographe pr√©c√©dente par la premi√®re suggestion et revenir au m√™me endroit en faisant <espace>sp  => {{{
" Voil√† mon premier plugin, √† ce stade (oui, c'est pas un plugin, c'est quelques lignes dans mon .vimrc):

function! FixLastSpellingError()
 normal! mm[s1z=`m
endfunction

nnoremap <leader>sp :call FixLastSpellingError()<cr>
nnoremap <leader>sop :source %<cr>

" }}}



"En suivant les conseils de https://riptutorial.com/ vim.pdf : {{{
"2020_11_29__18_28_55

" Automatically source .vimrc after saving
" Add this to your $MYVIMRC :{{{

" Source vim configuration file whenever it is saved
if has ('autocmd')         " Remain compatible with earlier versions
    augroup Reload_Vimrc   " Group name. Always use a unique name!
    autocmd!
                           " Clear any preexisting autocommands from this group
    autocmd! BufWritePost $MYVIMRC source % | echom "Reloaded " . $MYVIMRC | redraw
    autocmd! BufWritePost $MYGVIMRC if has('gui_running') | so % | echom "Reloaded " . $MYGVIMRC | endif | redraw
    augroup END
endif " has autocmd

" Features:
"    ‚Ä¢ echom tells the user what has happened (and also logs to :messages ).
"    ‚Ä¢ $MYVIMRC and $MYGVIMRC handle platform-specific names for the configuration files,
"    ‚Ä¢ and only match the actual configuration files (ignoring copies in other directories, or a
"     fugitive://diff)
"    ‚Ä¢ has() will prevent an error if using incompatible versions, such as vim-tiny .
"    ‚Ä¢ autocmd! avoids buildup of multiple identical autocommands if this file is sourced again. (It
"     clears all commands in the named group, so the group name is important.)
" }}}

" }}}


"Num√©rotation des lignes: {{{
set nu

" Pratique, pour n'avoir que la ligne courante num√©rot√©e, et les autres lignes num√©rot√©e en relatif.
" Ligne affich√©e relative:
set relativenumber

" Pour basculer toutes les num√©rotations de lignes de relatif √† absolu, dans toutes les fen√™tres ouvertes:
nnoremap <A-r> :Windo set relativenumber!<cr>

" Pour basculer toutes les num√©rotations de lignes, dans toutes les fen√™tres ouvertes:
nnoremap <A-n> :Windo set number!<cr>

" }}}


" Ouverture d'une fen√™tre d'exploration de fichiers netrw √† gauche: {{{
" Lexplore
" => marche pas... Pagrave.
" }}}


" D√©finition de r√©pertoires pour les sauvegardes, les fontchiers temporaires, et les fontchiers d'annulation: {{{
" selon le conseil de https://medium.com/@Aenon/vim-swap-backup-undo-git-2bf353caa02f:
set backupdir=.backup/,~/.backup/,/tmp//
set directory=.swp/,~/.swp/,/tmp//
set undodir=.undo/,~/.undo/,/tmp//
" }}}


" Installation de vimspector {{{
"let g:vimspector_enable_mappings = 'HUMAN'
" => annul√©, je pr√©f√®re mon F5 tout b√™te
"Voici les raccourcis "humains" de vimspector:
"  nnoremap <F5>         <Plug>VimspectorContinue
"  nnoremap <leader><F5> <Plug>VimspectorLaunch
"  nnoremap <F3>         <Plug>VimspectorStop
"  nnoremap <F4>         <Plug>VimspectorRestart
"  nnoremap <F6>         <Plug>VimspectorPause
"  nnoremap <F9>         <Plug>VimspectorToggleBreakpoint
"  nnoremap <leader><F9> <Plug>VimspectorToggleConditionalBreakpoint
"  nnoremap <F8>         <Plug>VimspectorAddFunctionBreakpoint
"  nnoremap <leader><F8> <Plug>VimspectorRunToCursor
"  nnoremap <F10>        <Plug>VimspectorStepOver
"  nnoremap <F11>        <Plug>VimspectorStepInto
"  nnoremap <F12>        <Plug>VimspectorStepOut
" => du coup, il faut que je red√©finisse mes raccourcis...
" => non: quand on r√©ussit √† lancer le d√©bogueur python, les raccourcis de vimspector fonctionnent.


" Activation des raccourcis
function! Vimspector_human_keybindings ()
 let g:vimspector_enable_mappings = 'HUMAN'
endfunction
function! Vimspector_vscode_keybindings ()
  let g:vimspector_enable_mappings = 'VISUAL_STUDIO'
endfunction
" }}}


" Faire un Esc plus ergonomique: {{{
" T√©, un truc marrant pour remapper <Esc> dans vim => kj:
" https://vi.stackexchange.com/questions/16963/remap-esc-key-in-vim
" TL;DR
" It's actually nice to remap esc to the home row. Here's how you decide what to map it to: Pick a hand and roll your 4 fingers across your desktop as fast as you can in whichever direction is fastest. Use that to choose what keys to remap.
" For me it's more natural to roll from pinky to index finger. Therefore I chose to use kj. Also, I did a grep -rHin kj ~/src (recursive grep on the parent directory of all my source code) and found no matches.
" esc in insert & visual mode
inoremap kj <esc>
vnoremap kj <esc>

" Idem, de 2023 dans vimrc_spi: {{{

inoremap kj         <Esc><Right>
inoremap <Up><Left> <Esc><Right>


" " De m√™me, faire un ii pour faire comme Insert-Insert:
" nnoremap ii         R
" " => ne fonctionne pas

" }}}

" esc in command mode
cnoremap kj <C-C>
" Note: In command mode mappings to esc run the command for some odd
" historical vi compatibility reason. We use the alternate method of
" existing which is Ctrl-C

" Note: If you do need to type a literal kj (or whatever your mapping is) just type them with 2 seconds in between. (You'll see the cursor hesitate to move after the 1st char. Wait for it to move before typing the 2nd.)
"
" You can shorten this delay by setting a shorter timeout to timeoutlen. For example, to have a timeout of 500ms add the following to your vimrc:
"
" set timeoutlen=500
"
" I have been using vim for 19 years. I was horrified when Apple updated their MacBook Pros to have a touch bar and no physical esc key. I saw a post that suggested mapping jj and jk to <Esc> and hated it. But I patiently jotted down on an index card every time it annoyed me. About 15 minutes later I reviewed my notes and came up with the TL;DR above to address the following:
"     I tend to hit esc allot when I'm not in insert mode just to "be sure" and jj would drop me 2 lines.
"     jk is a no-op (down, up) but kj is more natural for my hands.
"     I also need to use esc to exit command mode without completing the command.
" It's my hope that I can finally break my habit of hitting esc in other applications and closing windows when I'm several minutes into writing. I'd much rather insert stray kj characters than lose my work!


" Alors, je vais tenter d'adapter √ßa en restant AUSSI dans la position des fl√®ches:
inoremap <silent> <Up><Left> <esc>
vnoremap <silent> <Up><Left> <esc>


if va15 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[
" Mouais, il faut que ce soit VRAIMENT tr√®s rapide, pour √™tre confortable:
" Il faut que ce soit VRAIMENT tr√®s rapide pour que √ßa soit confortable:
set timeoutlen=50
" FIXME chiotte, cela rend les combinaisons avec la touche <Leader> quasiment impossibles √† faire...
" set timeoutlen=500

" En suivant le conseil de Beno√Æt_Castang, √ßa fonctionnerait sans timeoutlen ultracourt:
imap kj <Esc>
cmap kj <Esc>

" Oui, MAIS avec le Leader sur espace, en mode insertion, c'√©tait infernal... @#√† r√©soudre.
" }}}
endif "@# fin de code d√©sactiv√© #############################################]]]]


" Retour √† la ligne visuel (wrap): {{{

" le plus souvent, le wrap m'emmerdoie, pour des sources bien indent√©s notamment; donc j'√¥te:
set nowrap

"mais des fois, il rend service..
set wrap

" pour ne pas wrapper en coupant les mots:
set linebreak
" pour wrapper en respectant l'indentation:
set breakindent

" Idem, de 2023 dans vimrc_spi: {{{

" Pour les word wraps:
" set linebreak
set formatoptions=1
set lbr
set showbreak=\\__\ \ \ \ \ \ \ \

" Pour montrer les tabulations (superutile pour les Heredocs):
set list
set listchars=tab:¬≤¬≤
" set listchars=eol:$

" }}}


" Bascule le retour √† la ligne visuel (wrap) avec le raccourci Alt-Z (comme vsc...): {{{
noremap  <A-z>           :set invwrap<cr>
inoremap <A-z> <Esc>mz   :set invwrap<cr>`za

" Avec majuscule en plus: √ßa le fait dans toutes les fen√™tres:
noremap  <S-A-z>         :Windofast set invwrap<cr>
inoremap <S-A-z>    <Esc>:Windofast set invwrap<cr>a

" Idem, de 2023 dans vimrc_spi: {{{

" Retour √† la ligne comme chez vsc:
"nnoremap z      mz:windo set wrap!<cr>`z
"inoremap z <esc>mz:windo set wrap!<cr>`za
"" Idem, dans gvim:
"nnoremap √∫        mz:windo set wrap!<cr>`z
"inoremap √∫   <esc>mz:windo set wrap!<cr>`za
"
"=> plut√¥t, sans windo:
" Retour √† la ligne comme chez vsc:
nnoremap z      mz:set wrap!<cr>`z
inoremap z <esc>mz:set wrap!<cr>`za
" Idem, dans gvim:
nnoremap √∫        mz:set wrap!<cr>`z
inoremap √∫   <esc>mz:set wrap!<cr>`za


" Plut√¥t avec <leader> W (pour Wrapper:
nnoremap <leader>w      :windo set wrap!<cr>
inoremap <leader>w <esc>:windo set wrap!<cr>a


" }}}
" }}}

" }}}


" Cohabitation avec un multiplexeur de terminaux, comme screen ou tmux: {{{

" 2023_10_01__20_32_50
" Alors, maintenant, pour vivre avec tmux (selon config/.vim/pack/plugins/start/vim-tmux-navigator/README.md): {{{

" Je colle ici le contenu du greffon: {{{
" 2023_08_28__12_36_18

" Maps <C-h/j/k/l> to switch vim splits in the given direction. If there are
" no more windows in that direction, forwards the operation to tmux.
" Additionally, <C-\> toggles between last active vim splits/tmux panes.

if exists("g:loaded_tmux_navigator") || &cp || v:version < 700
  " finish " comment√©: √ßa arr√™tait tout mon .vimrc... _______________TODO__________________2023_10_03__21_53_23
endif
let g:loaded_tmux_navigator = 1

function! s:VimNavigate(direction)
  try
    execute 'wincmd ' . a:direction
  catch
    echohl ErrorMsg | echo 'E11: Invalid in command-line window; <CR> executes, CTRL-C quits: wincmd k' | echohl None
  endtry
endfunction

if !get(g:, 'tmux_navigator_no_mappings', 0)
  noremap <silent> <A-h>     :<C-U>TmuxNavigateLeft<cr>
  noremap <silent> <A-j>     :<C-U>TmuxNavigateDown<cr>
  noremap <silent> <A-k>     :<C-U>TmuxNavigateUp<cr>
  noremap <silent> <A-l>     :<C-U>TmuxNavigateRight<cr>
"   noremap <silent> <A-\> :<C-U>TmuxNavigatePrevious<cr>
  noremap <silent> <A-Left>  :<C-U>TmuxNavigateLeft<cr>
  noremap <silent> <A-Down>  :<C-U>TmuxNavigateDown<cr>
  noremap <silent> <A-Up>    :<C-U>TmuxNavigateUp<cr>
  noremap <silent> <A-Right> :<C-U>TmuxNavigateRight<cr>
" 2023_11_29__22_02_12 Mince, ces 4 derni√®res lignes ne fonctionnent pas; rempla√ßons les A-* par les codes captur√©s par vim √† l'int√©rieur d'une session tmux, avec C-V:
  noremap <silent> h  :<C-U>TmuxNavigateLeft<cr>
  noremap <silent> j  :<C-U>TmuxNavigateDown<cr>
  noremap <silent> k  :<C-U>TmuxNavigateUp<cr>
  noremap <silent> l  :<C-U>TmuxNavigateRight<cr>
endif

if empty($TMUX)
  command! TmuxNavigateLeft call s:VimNavigate('h')
  command! TmuxNavigateDown call s:VimNavigate('j')
  command! TmuxNavigateUp call s:VimNavigate('k')
  command! TmuxNavigateRight call s:VimNavigate('l')
  command! TmuxNavigatePrevious call s:VimNavigate('p')
  " finish " comment√©: √ßa arr√™tait tout mon .vimrc... _______________TODO__________________2023_10_03__21_53_23
endif
let salut="coucouroucoucou"

command! TmuxNavigateLeft call s:TmuxAwareNavigate('h')
command! TmuxNavigateDown call s:TmuxAwareNavigate('j')
command! TmuxNavigateUp call s:TmuxAwareNavigate('k')
command! TmuxNavigateRight call s:TmuxAwareNavigate('l')
command! TmuxNavigatePrevious call s:TmuxAwareNavigate('p')

if !exists("g:tmux_navigator_save_on_switch")
  let g:tmux_navigator_save_on_switch = 0
endif

if !exists("g:tmux_navigator_disable_when_zoomed")
  let g:tmux_navigator_disable_when_zoomed = 0
endif

if !exists("g:tmux_navigator_preserve_zoom")
  let g:tmux_navigator_preserve_zoom = 0
endif

if !exists("g:tmux_navigator_no_wrap")
  let g:tmux_navigator_no_wrap = 0
endif

let s:pane_position_from_direction = {'h': 'left', 'j': 'bottom', 'k': 'top', 'l': 'right'}

function! s:TmuxOrTmateExecutable()
  return (match($TMUX, 'tmate') != -1 ? 'tmate' : 'tmux')
endfunction

function! s:TmuxVimPaneIsZoomed()
  return s:TmuxCommand("display-message -p '#{window_zoomed_flag}'") == 1
endfunction

function! s:TmuxSocket()
  " The socket path is the first value in the comma-separated list of $TMUX.
  return split($TMUX, ',')[0]
endfunction

function! s:TmuxCommand(args)
  let cmd = s:TmuxOrTmateExecutable() . ' -S ' . s:TmuxSocket() . ' ' . a:args
  let l:x=&shellcmdflag
  let &shellcmdflag='-c'
  let retval=system(cmd)
  let &shellcmdflag=l:x
  return retval
endfunction

function! s:TmuxNavigatorProcessList()
  echo s:TmuxCommand("run-shell 'ps -o state= -o comm= -t ''''#{pane_tty}'''''")
endfunction
command! TmuxNavigatorProcessList call s:TmuxNavigatorProcessList()

let s:tmux_is_last_pane = 0
augroup tmux_navigator
  au!
  autocmd WinEnter * let s:tmux_is_last_pane = 0
augroup END

function! s:NeedsVitalityRedraw()
  return exists('g:loaded_vitality') && v:version < 704 && !has("patch481")
endfunction

function! s:ShouldForwardNavigationBackToTmux(tmux_last_pane, at_tab_page_edge)
  if g:tmux_navigator_disable_when_zoomed && s:TmuxVimPaneIsZoomed()
    return 0
  endif
  return a:tmux_last_pane || a:at_tab_page_edge
endfunction

function! s:TmuxAwareNavigate(direction)
  let nr = winnr()
  let tmux_last_pane = (a:direction == 'p' && s:tmux_is_last_pane)
  if !tmux_last_pane
    call s:VimNavigate(a:direction)
  endif
  let at_tab_page_edge = (nr == winnr())
  " Forward the switch panes command to tmux if:
  " a) we're toggling between the last tmux pane;
  " b) we tried switching windows in vim but it didn't have effect.
  if s:ShouldForwardNavigationBackToTmux(tmux_last_pane, at_tab_page_edge)
    if g:tmux_navigator_save_on_switch == 1
      try
        update " save the active buffer. See :help update
      catch /^Vim\%((\a\+)\)\=:E32/ " catches the no file name error
      endtry
    elseif g:tmux_navigator_save_on_switch == 2
      try
        wall " save all the buffers. See :help wall
      catch /^Vim\%((\a\+)\)\=:E141/ " catches the no file name error
      endtry
    endif
    let args = 'select-pane -t ' . shellescape($TMUX_PANE) . ' -' . tr(a:direction, 'phjkl', 'lLDUR')
    if g:tmux_navigator_preserve_zoom == 1
      let l:args .= ' -Z'
    endif
    if g:tmux_navigator_no_wrap == 1
      let args = 'if -F "#{pane_at_' . s:pane_position_from_direction[a:direction] . '}" "" "' . args . '"'
    endif
    silent call s:TmuxCommand(args)
    if s:NeedsVitalityRedraw()
      redraw!
    endif
    let s:tmux_is_last_pane = 1
  else
    let s:tmux_is_last_pane = 0
  endif
endfunction


" }}}

" 2023_08_28__12_36_18
let g:tmux_navigator_no_mappings = 1
if empty($TMUX)
 " RAS...
else
 noremap <silent> <A-Left>  :<C-U>TmuxNavigateLeft<cr>
 noremap <silent> <A-Down>  :<C-U>TmuxNavigateDown<cr>
 noremap <silent> <A-Up>    :<C-U>TmuxNavigateUp<cr>
 noremap <silent> <A-Right> :<C-U>TmuxNavigateRight<cr>
" noremap <silent> {Previous-Mapping} :<C-U>TmuxNavigatePrevious<cr>
 noremap <silent> <A-h>     :<C-U>TmuxNavigateLeft<cr>
 noremap <silent> <A-j>     :<C-U>TmuxNavigateDown<cr>
 noremap <silent> <A-k>     :<C-U>TmuxNavigateUp<cr>
 noremap <silent> <A-l>     :<C-U>TmuxNavigateRight<cr>
" *Note* Each instance of `{Left-Mapping}` or `{Down-Mapping}` must be replaced
" in the above code with the desired mapping. Ie, the mapping for `<ctrl-h>` =>
" Left would be created with `noremap <silent> <c-h> :<C-U>TmuxNavigateLeft<cr>`.
endif

" }}}
" # => √ßa ne fonctionne point...


" " Screen-ify an external command.
" function InScreen(command)
"   return g:GNU_Screen_used ? 'screen '.a:command : a:command
" endfunction
" Test:
" map <C-j> :r !echo "coucou"<CR>

" }}}



" Surround the visual selection in parenthesis/brackets/etc.: {{{
vnoremap ( <esc>`>a)<esc>`<i(<esc>
" vnoremap ) <esc>`>a)<esc>`<i(<esc>
vnoremap [ <esc>`>a]<esc>`<i[<esc>
vnoremap ] <esc>`>a]<esc>`<i[<esc>
vnoremap { <esc>`>a}<esc>`<i{<esc>
" vnoremap } <esc>`>a}<esc>`<i{<esc>
vnoremap " <esc>`>a"<esc>`<i"<esc>
vnoremap ' <esc>`>a'<esc>`<i'<esc>
vnoremap ` <esc>`>a`<esc>`<i`<esc>
" => invalid√© ) et }, pour pouvoir continuer √† s√©lectionner une phrase ou un paragraphe

" FIXME double emploi avec ce qui est horodat√© l√†?  2023_10_09__23_58_39 " Pour entourer une s√©lection avec des {}:
" vnoremap { yc{}<Esc>P
" vnoremap } yc{}<Esc>P
" FIXME double emploi avec ce qui est horodat√© l√†?  2023_10_09__23_58_39

" }}}

" Une macro pour entourer de parenth√®ses la prochaine variable shell qui ne l'est pas d√©j√†:{{{

" let @a= '/kulviw}'
" (ne fonctionne pas)


" 2023_12_24__13_34_53 mince, pas vu...
" Refait, de t√™te:
nnoremap <C-F12>        /\$[A-Za-z]<cr> i{<esc>ea}<esc>
inoremap <C-F12> <esc>mz/\$[A-Za-z]<cr> i{<esc>ea}<esc>'za

" Idem, de 2023 dans vimrc_spi: {{{
" TODO voir le .vimrc chez Spie, o√π √ßa fonctionne correctement
" " Pour entourer des $variables d'environnement par des {}:
" nnoremap  <C-F12>      /\$[a-zA-Z]<cr>li{<Esc>lea}<Esc>
" }}}
" }}}


" Pour ouvrir une URL avec gx: (pas la peine, √ßa fonctionne sans ceci) {{{
" function! OpenURLUnderCursor()
"   let s:uri = expand('<cWORD>')
"   let s:uri = substitute(s:uri, '?', '\\?', '')
"   let s:uri = shellescape(s:uri, 1)
"   if s:uri != ''
"     silent exec "!open '".s:uri."'"
"     redraw!
"   endif
" endfunction
" nnoremap gx :call OpenURLUnderCursor()<CR>
"
" " If you‚Äôre on Linux, try changing !open to !gio.

" }}}




" Je remets tous mes greffons par ici: {{{

" Pour √©diter rapidos du HTML et CSS, plugin https://github.com/mattn/emmet-vim/:
" Plugin 'mattn/emmet-vim' (non, marche pas ainsi)


" vim-plug:
" call plug#begin('~/.vim/plugged')
" call plug#begin()
"   Plug 'preservim/nerdtree'
"   Plug 'iberianpig/ranger-explorer.vim'
" call plug#end()

" paquets vim (pack ages):
packadd! vimspector
packadd! vim-tmux-navigator





" }}}
let salut="coucou16"
endif "@# fin de code d√©sactiv√© #############################################]]]]

if va17 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[
" Raccourcis clavier pour les greffons: {{{

" NERDTree: {{{
" A pour Arborescence
noremap <leader>a   :NERDTreeFocus<cr>
" let NERDTreeMapCloseChildren='h'
let NERDTreeMapCloseDir='h'
" let NERDTreeMapUpdir='h'
" let NERDTreeMapActivateNode='l'
let NERDTreeShowHidden=1
let NERDTreeMapPreview='l'
let NERDTreeMapActivateNode='l'
" => √ßa ne fonctionne pas...

" Exit Vim if NERDTree is the only window remaining in the only tab.
autocmd BufEnter * if tabpagenr('$') == 1 && winnr('$') == 1 && exists('b:NERDTree') && b:NERDTree.isTabTree() | quit | endif
" Close the tab if NERDTree is the only window remaining in it.
autocmd BufEnter * if winnr('$') == 1 && exists('b:NERDTree') && b:NERDTree.isTabTree() | quit | endif

" Pour √©viter le message de NERDTree pour les gros r√©pertoires:
let g:NERDTreeNotificationThreshold = 5000

" }}}

" }}}



" Pour ouvrir avec le navigateur par d√©faut avec gx {{{
" let g:netrw_http_cmd  = "$BROWSER"
" => ez, √ßa ne fonctionne pas, √ßa ouvre aussi un truc tmp
" nmap gx :!open <c-r><c-a><cr>

" }}}
let salut="coucou17"
endif "@# fin de code d√©sactiv√© #############################################]]]]

if va18 == "oui" "@# d√©but de code d√©sactiv√© #############################################[[[[
" Bonjour matinal: {{{
command! Bonjour :r !echo -e "________________________________________________________________________________\n$(date +\%d_\%m_\%Y__\%T | sed -e 's/\:/_/g')                    $HOSTNAME\n$(acpi -i)"
" nnoremap <c-b>      :Bonjour<cr>o
" vnoremap <c-b>      :Bonjour<cr>
" cnoremap <c-b>      :Bonjour<cr>
" \_ annul√©, cata, √ßa mettait la date quand on faisait PageUp...
inoremap <c-b> <Esc>:Bonjour<cr>o

" }}}

let salut="Coucou final, .vimrc charg√©!"
endif "@# fin de code d√©sactiv√© #############################################]]]]

" Poubelle: {{{

" Un vestige inconnu: {{{
" let c='a'
" while c <= 'z'
"   exec "set <A-".c.">=\e".c
"   exec "imap \e".c." <A-".c.">"
"   let c = nr2char(1+char2nr(c))
" endw
" }}}

" Changed default required by SuSE security team--be aware if enabling this
" that it potentially can open for malicious users to do harmful things.
set modelines=0


" get easier to use and more user friendly vim defaults
" /etc/vimrc ends here

" }}}
" echo salut



" Faire un redo qui soit plus proche du undo (U) => √à{{{
" Pour Refaire √† c√¥t√© de Undo:
" nnoremap √® :redo<CR>
" => ach non, √ßa bloque Alt-H...
" Bof...
" unmap √®
" Ah, avec _:
"                                                => _
nnoremap _ :redo<CR>
" }}}


" Le paquet simple_highlighting.vim ne semble pas avoir ses raccourcis clavier qui fonctionnent: je les mets ici:{{{
" Ah non... en fait, ce n'est pas un paquet, mais un script; donc je le source, plut√¥t:
source ~/.vim/pack/plugins/start/simple_highlighting/simple_highlighting.vim
" Je refais un mappage moins ch!ant, avec un delay moindre pour √©viter d'utiliser la touche Leader:
nnoremap <A-!> <silent> :Windofast<C-U> exe "call HighlightAdd(".v:count.",'\\<".expand('<cword>')."\\>')"<CR>


" 2024_02_14__12_07_30 
" D'apr√®s https://vi.stackexchange.com/questions/20077/automatically-highlight-all-occurrences-of-the-selected-text-in-visual-mode :

" highlight the visual selection after pressing enter.
xnoremap <silent> <cr> "*y:silent! let searchTerm = '\V'.substitute(escape(@*, '\/'), "\n", '\\n', "g") <bar> let @/ = searchTerm <bar> echo '/'.@/ <bar> call histadd("search", searchTerm) <bar> set hls<cr>

" Give ctrl+c a job when it is otherwise being wasted!
" Now it toggles `hlsearch` while in NORMAL mode:
nnoremap <silent> <c-c> :if (&hlsearch == 1) \| set nohlsearch \| else \| set hlsearch \| endif<cr>

" Put <enter> to work too! Otherwise <enter> moves to the next line, which we can
" already do by pressing the <j> key, which is a waste of keys!

" Be useful <enter> key!:
" nnoremap <silent> <cr> :let searchTerm = '\v<'.expand("<cword>").'>' <bar> let @/ = searchTerm <bar> echo '/'.@/ <bar> call histadd("search", searchTerm) <bar> set hls<cr>
" Tentative (vaine jusqu'ici) d'am√©lioration:
" nnoremap <silent> <cr> :let searchTerm = '\v<'.expand("<cword>").'>' <bar> let @/ = searchTerm <bar> 0 echowindow '/'.@/ <bar> call Windofast histadd("search", searchTerm) <bar> set hls<cr>
nnoremap <silent> <cr> :let searchTerm = '\v<'.expand("<cword>").'>' <bar> let @/ = searchTerm <bar> 0 echowindow '/'.@/ <bar> call histadd("search", searchTerm) <bar> set hls<cr>

" }}}

" Tiens, faire un * qui aille chercher dans toutes les fen√™tres l'occurrence suivante du mot sous le curseur, √ßa ne serait pas si b√™te:{{{

" nnoremap <*> :Windo *<cr>
" \_ marche pas...
" _______________TODO__________________

"}}}



" Pour se d√©placer verticalement dans un paragraphe wrapp√©:{{{
let g:move_vertically_in_wrapped_paragraph = 1
function! Move_vertically_in_wrapped_paragraph()
  if g:move_vertically_in_wrapped_paragraph == 1
    nmap <expr> k      (v:count == 0 ? 'gk' : 'k')
    nmap <expr> j      (v:count == 0 ? 'gj' : 'j')
    nmap <expr> <Up>   (v:count == 0 ? 'gk' : 'k')
    nmap <expr> <Down> (v:count == 0 ? 'gj' : 'j')
    vmap <expr> <Up>   (v:count == 0 ? 'gk' : 'k')
    vmap <expr> <Down> (v:count == 0 ? 'gj' : 'j')
  else
    nmap <expr> k      'k'
    nmap <expr> j      'j'
    nmap <expr> <Up>   'k'
    nmap <expr> <Down> 'j'
    vmap <expr> <Up>   'k'
    vmap <expr> <Down> 'j'
  endif
endfunction
function! Toggle_move_vertically_in_wrapped_paragraph()
  if g:move_vertically_in_wrapped_paragraph == 1
    let g:move_vertically_in_wrapped_paragraph = 0
    echom "JK keys move normally from line to line"
  else
    let g:move_vertically_in_wrapped_paragraph = 1
    echom "JK keys move inside wrapped paragraphs"
  endif
  call Move_vertically_in_wrapped_paragraph()
endfunction
" Basculer ce comportement (parfois d√©sir√©, parfois pas) par Alt-W (comme wrapp√©):
nnoremap <a-w> :call Toggle_move_vertically_in_wrapped_paragraph()<cr>
" }}}

" Un th√®me de couleurs un peu plus √† la mode:
" colorscheme evening


" Diff√©rents trucs, venant de vimrc_spi notamment: TODO √† remettre en ordre:

" Pour comparer deux lignes successives: {{{
function! DiffLineWithNext()
  " let f1=tempname()
  " let f2=tempname()
  let f1="/tmp/tmp_vim_line1"
  let f2="/tmp/tmp_vim_line2"
  exec ".write! " . f1
  exec ".+1write! " . f2
  " :!bash diff f1 f2<cr>
  "TODO faire une condition, ne continuer que si f1 et f2 diff√®rent
  " faire √ßa avec une fonction interne de comparaison de vim?
  exec "tabedit " . f1
  exec "diffsplit " . f2
  resize 1
  windo set colorcolumn=
  windo set nocursorcolumn
  windo set nocursorline
endfunction
nnoremap <F4>      mz:call DiffLineWithNext()<cr>`z
inoremap <F4> <Esc>mz:call DiffLineWithNext()<cr>`za
" }}}

" Pour mettre des espaces en indentant, et non point des tabulations:
set expandtab

" Pour pouvoir ouvrir tout plein d'onglets:
set tabpagemax=100

" Couleur diff√©rente des TODO et FIXME pour les recherches:
:hi Search guibg=gray guifg=white


" Un mode de couleur un peu reposant:
" colorscheme evening
" Bah non, √ßa pue dans gvim, en fait

" Comme √ßa, c'est pas mal pour le bash
set noautoindent noexpandtab tabstop=2 shiftwidth=2

" Montre la colonne 80
set colorcolumn=80
" Y mettre une couleur un peu moins aggressive que le rouge par d√©faut (surtout chouette pour le Cobol):
" highlight ColorColumn term=reverse cterm=reverse ctermbg=gray cterm=bold
" highlight ColorColumn term=reverse cterm=reverse ctermbg=gray cterm=bold guifg=white guibg=yellow gui=bold
" \_ bof, c'est d√©gueu, je pr√©f√®re configurer √ßa seulement pour les fontchiers Cobol, cf. au des *.cbl


" Ne pas afficher la barre de menus dans gvim;
" c'est pour pouvoir avoir <a-L> qui aille vers la fen√™tre de gauche,
" au lieu de faire tomber un menu:
set guioptions-=T
set guioptions-=m

" __________***_JEANSUILA_***__________ <= tag n'existant QUE deux fois ####### ******** JEANSUILA_INSTANT_PR√âSENT ########################################################################################################################################
" TODO FIXME !!
" o # BkSp marche pas en mode insertion!!! => au_quai => non, PAS au_quai!

" Fini: {{{

" x # ^W marche pas en mode insertion!!! => dans gvim, √ßa fonctionne; mais pas dans vim => ay√©, 2023_09_06__18_40_13, √ßa fonctionne (pourquoi?...)
" x √® et √© merdoient en mode insertion!!! => √©√©√®√® => au_quai
" x # BkSp marche pas en mode insertion!!! => au_quai

" set foldmarker=[[[[,]]]]

" }}}


" # let salut="coucou6"
" # endif "@# fin de code d√©sactiv√© #############################################]]]]


" Terrain de jeu pour des essais: {{{
" https://loremipsum.io/generator/?n=5&t=p
" set syLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Dictumst quisque sagittis purus sit amet volutpat consequat mauris nunc. Risus in hendrerit gravida rutrum quisque non tellus orci. Quam viverra orci sagittis eu volutpat odio facilisis mauris sit. Mauris augue neque gravida in fermentum. Blandit libero volutpat sed cras ornare arcu dui vivamus arcu. Senectus et netus et malesuada. Proin gravida hendrerit lectus a. Dui ut ornare lectus sit amet est placerat in. Ut faucibus pulvinar elementum integer. Massa massa ultricies mi quis hendrerit dolor. Dui nunc mattis enim ut tellus elementum sagittis. Risus commodo viverra maecenas accumsan lacus vel facilisis volutpat est. Cras semper auctor neque vitae tempus. Neque egestas congue quisque egestas diam in arcu cursus.
" Lorem ipsum
" Lorem ipsum dol()or sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Dictumst quisque sagittis purus sit amet volutpat consequat mauris nunc. Risus in hendrerit gravida rutrum quisque non tellus orci. Quam viverra orci sagittis eu volutpat odio facilisis mauris sit. Mauris augue neque gravida in fermentum. Blandit libero volutpat sed cras ornare arcu dui vivamus arcu. Senectus et netus et malesuada. Proin gravida hendrerit lectus a. Dui ut ornare lectus sit amet est placerat in. Ut faucibus pulvinar elementum integer. Massa massa ultricies mi quis hendrerit dolor. Dui nunc mattis enim ut tellus elementum sagittis. Risus commodo viverra maecenas accumsan lacus vel facilisis volutpat est. Cras semper auctor neque vitae tempus. Neque egestas congue[ quisque egestas diam in arcu cursus.
" em ipsum dol()or sit amet, consect
" Lorem ipsum

"32
"31

" }}}


syntax on
syntax enable

" _______________TODO__________________ 

" Probl√®mes √† r√©soudre:
" o BkSp ne fonctionne pas en mode insertion
" x Caps_Lock ne fonctionne plus (pas que dans vim)
" x Alt-H ne va pas √† gauche
" x √® en mode insertion va vers la gauche
" o cohabitation avec tmux (...)



" √† r√©ordonner o√π il convient:{{{

" Un raccourci pratique pour basculer la maximisation d'une fen√™tre en hauteur:{{{

" if va18 == "zb" "@# d√©but de code d√©sactiv√© #############################################[[[[
" " Premi√®re solution:{{{
" " https://vim.fandom.com/wiki/Maximize_window_and_return_to_previous_split_structure
" 
" " nnoremap <C-W>O :call MaximizeToggle()<CR>
" " nnoremap <C-W>o :call MaximizeToggle()<CR>
" " nnoremap <C-W><C-O> :call MaximizeToggle()<CR>
" " \_ quelque chose de plus ergonomique:
" " nnoremap <A-_> <C-W>_
" nnoremap <A-_> :call MaximizeToggle()<CR>
" 
" function! MaximizeToggle()
  " if exists("s:maximize_session")
    " exec "source " . s:maximize_session
    " call delete(s:maximize_session)
    " unlet s:maximize_session
    " let &hidden=s:maximize_hidden_save
    " unlet s:maximize_hidden_save
  " else
    " let s:maximize_hidden_save = &hidden
    " let s:maximize_session = tempname()
    " set hidden
    " exec "mksession! " . s:maximize_session
    " only
  " endif
" endfunction
" 
" " }}}
" endif "@# fin de code d√©sactiv√© #############################################]]]]

" Seconde solution:{{{

function! ToggleZoom(zoom, vertical)
  if exists("t:restore_zoom") && (a:zoom == v:true || t:restore_zoom.win != winnr())
      exec t:restore_zoom.cmd
      unlet t:restore_zoom
  elseif a:zoom
      let t:restore_zoom = { 'win': winnr(), 'cmd': winrestcmd() }
      if (a:vertical == v:false)
          exec "normal \<C-W>\|\<C-W>_"
      else
          " \_ je pr√©f√®re une maximisation verticale seulement (question de go√ªt):
          exec "normal \<C-W>_"
      endif
  endif
endfunction

augroup restorezoom
    au WinEnter * silent! :call ToggleZoom(v:false, v:false)
augroup END

" Raccourci initial:
" nnoremap <silent> <Leader>+ :call ToggleZoom(v:true)<CR>
" Raccourcis pour maximiser verticalement par d√©faut, et en tous sens avec shift:
nnoremap <A-_>      :call ToggleZoom(v:true,  v:true)<CR>
inoremap <A-_> <Esc>:call ToggleZoom(v:true,  v:true)<CR>a

nnoremap <A-8> :call ToggleZoom(v:true, v:false)<CR>
inoremap <A-8> :call ToggleZoom(v:true, v:false)<CR>a

" }}}
" }}}

" Des trucs qui ne tournent pas encore, qu'il faut mettre au point: {{{

" Pour faire un * sur un mot et qu'on y aille dans toutes les fen√™tres, en y restant dans la fen√™tre courante:
" map ¬™ :silent! *N :Windofast n<cr>
" => marche p√¥... 
nnoremap √ß :normal! *N :Windo n<cr>



" }}}

" }}}

" poubelle:{{{

" set syntax=vim "Juste pour d√©boguer le pr√©sent f√©chier! Commenter d√®s que c'est fini.

" 2024_03_28__11_51_07 juste le temps de faire le diff avec vimrc_spi:{{{
" syntax off
" set foldmethod=diff

" }}}
" _______________TODO__________________2023_10_03__21_53_23

"}}}

" vimrc_spi: voir toutes ces √©tiquettes, et r√©soudre les choses, tester ce qui est le mieux, etc.
