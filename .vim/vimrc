let va1="oui"
let va2="oui"
let va3="oui"
let va4="oui"
let va5="oui"
let va55="oui"
" C'est à ce va55 que se situe le problème qui empêche de faire è en mode insertion
let va6="oui"
let va7="oui"
let va8="oui"
let va9="oui"
let va10="oui"
let va11="oui"
let va12="oui"
let va13="oui"
let va14="oui"
let va15="oui"
let va16="oui"
let va17="oui"
  let va18="oui"
" Les touches de fonctions avec des raccourcis (à maintenir):
" F1  F2  F3  F4  F5  F6  F7  F8  F9  F10  F11  F12  F13  F14  F15  F16  F17  F18  F19  F20
" -   -   |   |   |   |   |   |   |    |    |    |   -    -    -    -    -    -    -    -
" F2  \_ bascule le viseur/réticule
" F3      \_ ouvre une fenêtre au-dessus avec l'occurrence précédente du mot sous le curseur
" F4          \_ fait le diff entre la ligne courante et la suivante
" F5              \_ sauver et faire tourner le fichier courant par rebol, ou plutôt par le shebang
" F6                  \_ faire tourner le paragraphe courant par rebol
" ctrl-F6             \_ faire tourner le paragraphe courant par python3
" shift-F6            \_ faire tourner le paragraphe courant par javascript
" ctrl-shift-F6       \_ faire tourner le paragraphe courant par une compilation de C et une exécution
" F7                      \_ insertion de timestamp, comme dans le bon vieux ultraedit
" F8                          \_ faire tourner le paragraphe courant par bash
" shift-F8                    \_ faire tourner la ligne courante par bash
" F9                              \_ dictée du paragraphe en cours
" shift-F9                        \_ shift => idem en anglais
" F10                                  \_ correction orthographique du paragraphe courant
" F11                                       \_ aller à l'étiquette _______________ENCOURS_______________ précédente
" F12                                            \_ dernière macro


" Pour le débogage du présent féchier:{{{ [[[[
" il faut faire:
" set foldmarker=[[[[,]]]]


" }}} ]]]]

" Ces tests if va* == "oui", c'est pour déboguer le contenu de ce féchier, en invalidant de grosses portions de ce féchier de temps à autre.
if va1 == "oui" "@# début de code désactivé #############################################[[[[
" Trucs bateau:
" Des trucs assez bateau:{{{

" get easier to use and more user friendly vim defaults
" CAUTION: This option breaks some vi compatibility.
"          Switch it off if you prefer real vi compatibility
set nocompatible

syntax on
" set noautoindent
set autoindent
set noerrorbells

set ignorecase
set ruler
set showmatch
set showmode

set hlsearch
set incsearch
set scrolloff=5
set mouse=a
set infercase


" changes special characters in search patterns (default)
" set magic
set esckeys            " Required to be able to use keypad keys and map missed escape sequences


" Complete longest common string, then each full match
" enable this for bash compatible behaviour
" set wildmode=longest,full


set history=10000
set encoding=utf-8
set fileencoding=utf-8


" Je ne sais trop ce que c'est que ceci:
set keymodel=startsel,stopsel


"Pour ne pas recommencer la recherche au début/fin du fichier:
"set nowrapscan
"Pour PAS ne pas recommencer la recherche au début/fin du fichier:
set wrapscan



" Pour ne pas être embêté avec les messages de tampons non sauvés, quand on va d'un tampon à un autre (en suivant le conseil de iggredible):
" Before you start, make sure you have the set hidden option in vimrc. Without it, whenever you switch buffers and your current buffer is not saved, Vim will prompt you to save the file (you don't want that if you want to move quickly). I haven't covered vimrc yet. If you don't have a vimrc, create one. It is usually placed in your home directory and is named .vimrc. I have mine on ~/.vimrc. To see where you should create your vimrc, check out :h vimrc. Inside it, add:
set hidden


" }}}

" Des fonctions de débogage: {{{

function! DebugPauseWaitForKeyPress()
  " Fonction utilitaire à la c.n pour attendre un pressage de touche:
  echo "Touche quelconque pour continuer..."
  let c = getchar()
endfunction

" }}}
let salut="coucou1"
endif "@# fin de code désactivé #############################################]]]]

" De vieux trucs avec des clefs:
if va2 == "oui" "@# début de code désactivé #############################################[[[[
" Un tas de trucs hérités d'un passé lointain, avec des machins liés au type de terminal: {{{

" Try to get the correct main terminal type {{{
if &term =~ "xterm"
    let myterm = "xterm"
else
    let myterm =  &term
endif
let myterm = substitute(myterm, "cons[0-9][0-9].*$",  "linux", "")
let myterm = substitute(myterm, "vt1[0-9][0-9].*$",   "vt100", "")
let myterm = substitute(myterm, "vt2[0-9][0-9].*$",   "vt220", "")
let myterm = substitute(myterm, "\\([^-]*\\)[_-].*$", "\\1",   "")
" }}}



" Here we define the keys of the NumLock in keyboard transmit mode of xterm {{{
" which misses or hasn't activated Alt/NumLock Modifiers.  Often not defined
" within termcap/terminfo and we should map the character printed on the keys.
if myterm == "xterm" || myterm == "kvt" || myterm == "gnome"
    " keys in insert/command mode.
    map! <ESC>Oo  :
    map! <ESC>Oj  *
    map! <ESC>Om  -
    map! <ESC>Ok  +
    map! <ESC>Ol  ,
    map! <ESC>OM  
    map! <ESC>Ow  7
    map! <ESC>Ox  8
    map! <ESC>Oy  9
    map! <ESC>Ot  4
    map! <ESC>Ou  5
    map! <ESC>Ov  6
    map! <ESC>Oq  1
    map! <ESC>Or  2
    map! <ESC>Os  3
    map! <ESC>Op  0
    map! <ESC>On  .
    " keys in normal mode
    map <ESC>Oo  :
    map <ESC>Oj  *
    map <ESC>Om  -
    map <ESC>Ok  +
    map <ESC>Ol  ,
    map <ESC>OM  
    map <ESC>Ow  7
    map <ESC>Ox  8
    map <ESC>Oy  9
    map <ESC>Ot  4
    map <ESC>Ou  5
    map <ESC>Ov  6
    map <ESC>Oq  1
    map <ESC>Or  2
    map <ESC>Os  3
    map <ESC>Op  0
    map <ESC>On  .
endif
" }}}

" xterm but without activated keyboard transmit mode {{{
" and therefore not defined in termcap/terminfo.
if myterm == "xterm" || myterm == "kvt" || myterm == "gnome"
    " keys in insert/command mode.
    map! <Esc>[H  <Home>
    map! <Esc>[F  <End>
    " Home/End: older xterms do not fit termcap/terminfo.
    map! <Esc>[1~ <Home>
    map! <Esc>[4~ <End>
    " Up/Down/Right/Left
    map! <Esc>[A  <Up>
    map! <Esc>[B  <Down>
    map! <Esc>[C  <Right>
    map! <Esc>[D  <Left>
    " KP_5 (NumLock off)
    map! <Esc>[E  <Insert>
    " PageUp/PageDown
    map <ESC>[5~ <PageUp>
    map <ESC>[6~ <PageDown>
    map <ESC>[5;2~ <PageUp>
    map <ESC>[6;2~ <PageDown>
    map <ESC>[5;5~ <PageUp>
    map <ESC>[6;5~ <PageDown>
    " keys in normal mode
    map <ESC>[H  0
    map <ESC>[F  $
    " Home/End: older xterms do not fit termcap/terminfo.
    map <ESC>[1~ 0
    map <ESC>[4~ $
    " Up/Down/Right/Left
    map <ESC>[A  k
    map <ESC>[B  j
    map <ESC>[C  l
    map <ESC>[D  h
    " KP_5 (NumLock off)
    map <ESC>[E  i
    " PageUp/PageDown
    map <ESC>[5~ 
    map <ESC>[6~ 
    map <ESC>[5;2~ 
    map <ESC>[6;2~ 
    map <ESC>[5;5~ 
    map <ESC>[6;5~ 
endif
" }}}

" xterm/kvt but with activated keyboard transmit mode. {{{
" Sometimes not or wrong defined within termcap/terminfo.
if myterm == "xterm" || myterm == "kvt" || myterm == "gnome"
    " keys in insert/command mode.
    map! <Esc>OH <Home>
    map! <Esc>OF <End>
    map! <ESC>O2H <Home>
    map! <ESC>O2F <End>
    map! <ESC>O5H <Home>
    map! <ESC>O5F <End>
    " Cursor keys which works mostly
    " map! <Esc>OA <Up>
    " map! <Esc>OB <Down>
    " map! <Esc>OC <Right>
    " map! <Esc>OD <Left>
    map! <Esc>[2;2~ <Insert>
    map! <Esc>[3;2~ <Delete>
    map! <Esc>[2;5~ <Insert>
    map! <Esc>[3;5~ <Delete>
    map! <Esc>O2A <PageUp>
    map! <Esc>O2B <PageDown>
    map! <Esc>O2C <S-Right>
    map! <Esc>O2D <S-Left>
    map! <Esc>O5A <PageUp>
    map! <Esc>O5B <PageDown>
    map! <Esc>O5C <S-Right>
    map! <Esc>O5D <S-Left>
    " KP_5 (NumLock off)
    map! <Esc>OE <Insert>
    " keys in normal mode
    map <ESC>OH  0
    map <ESC>OF  $
    map <ESC>O2H  0
    map <ESC>O2F  $
    map <ESC>O5H  0
    map <ESC>O5F  $
    " Cursor keys which works mostly
    " map <ESC>OA  k
    " map <ESC>OB  j
    " map <ESC>OD  h
    " map <ESC>OC  l
    map <Esc>[2;2~ i
    map <Esc>[3;2~ x
    map <Esc>[2;5~ i
    map <Esc>[3;5~ x
    map <ESC>O2A  ^B
    map <ESC>O2B  ^F
    map <ESC>O2D  b
    map <ESC>O2C  w
    map <ESC>O5A  ^B
    map <ESC>O5B  ^F
    map <ESC>O5D  b
    map <ESC>O5C  w
    " KP_5 (NumLock off)
    map <ESC>OE  i
endif
" }}}


" tmux stuff:{{{
" https://stackoverflow.com/questions/15445481/mapping-arrow-keys-when-running-tmux

" Vim knows that xterm-like terminals (identified by TERM starting with xterm, or a particular response to the t_RV sequence, if it is defined) support extended sequences for certain modified keys, but it does not assume this for screen TERMs (which you should be using under tmux).
" 
" You can, however tell Vim about these sequences and enable them if TMUX is present, and TERM starts with screen (the first lines enable (better) mouse support under tmux, which you might also like):

if &term =~ '^screen' && exists('$TMUX')
    set mouse+=a
    " tmux knows the extended mouse mode
    set ttymouse=xterm2
    " tmux will send xterm-style keys when xterm-keys is on
    execute "set <xUp>=\e[1;*A"
    execute "set <xDown>=\e[1;*B"
    execute "set <xRight>=\e[1;*C"
    execute "set <xLeft>=\e[1;*D"
    execute "set <xHome>=\e[1;*H"
    execute "set <xEnd>=\e[1;*F"
    execute "set <Insert>=\e[2;*~"
    execute "set <Delete>=\e[3;*~"
    execute "set <PageUp>=\e[5;*~"
    execute "set <PageDown>=\e[6;*~"
    execute "set <xF1>=\e[1;*P"
    execute "set <xF2>=\e[1;*Q"
    execute "set <xF3>=\e[1;*R"
    execute "set <xF4>=\e[1;*S"
    execute "set <F5>=\e[15;*~"
    execute "set <F6>=\e[17;*~"
    execute "set <F7>=\e[18;*~"
    execute "set <F8>=\e[19;*~"
    execute "set <F9>=\e[20;*~"
    execute "set <F10>=\e[21;*~"
    execute "set <F11>=\e[23;*~"
    execute "set <F12>=\e[24;*~"
endif

" As the comment indicates, you also need to have the window’s xterm-keys option enabled. You can do this for all your windows like this (in your ~/.tmux.conf):

" set-option -gw xterm-keys on



" }}}



" Tentative (annulée) pour faire fonctionner <C-j> dans vim dans screen: {{{
" En suivant les conseils de https://vim.fandom.com/wiki/GNU_Screen_integration :
" if match($TERM, "screen")!=-1
"   " On est dans un screen
"   set term=xterm
"   map [1~ <Home>
"   " Tentative de remapper Ctrl-j:
"   "noremap   <C-j>
"   " => ne fonctionne pas
"   let g:GNU_Screen_used = 1
" else
"   " Hors screen
"   map OH <Home>
"   let g:GNU_Screen_used = 0
" endif
" }}}


if myterm == "linux"
    " keys in insert/command mode.
    map! <Esc>[G  <Insert>
    " KP_5 (NumLock off)
    " keys in normal mode
    " KP_5 (NumLock off)
    map <ESC>[G  i
endif

" This escape sequence is the well known ANSI sequence for
" Remove Character Under The Cursor (RCUTC[tm])
map! <Esc>[3~ <Delete>
map  <ESC>[3~    x


" }}}
let salut="coucou2"
endif "@# fin de code désactivé #############################################]]]]

if va3 == "oui" "@# début de code désactivé #############################################[[[[

" Leader key: {{{

" La leader key: espace, au lieu de l'abscon et malpratique \:
nnoremap <Space> <Nop>
let mapleader = " "         " map leader to Space
let mapleader = "\<Space>"  " map leader to Space

" => non, plutôt la touche Caps_Lock, mais uniquement en mode normal:
" tentatives: {{{
" let mapleader = "\<Caps_Lock>"
" => ne fonctionne pas

" Suggestion de ChatGPT:{{{
" let mapleader = "\<Caps_Lock>"
" augroup leader_capslock
  " autocmd!
  " autocmd InsertEnter * let leader_save = mapleader | let mapleader = "\<Nop>"
  " autocmd InsertLeave * let mapleader = leader_save
" augroup END
" 
" let g:leader_capslock_active = 0
" 
" function! ToggleLeaderCapslock()
  " if g:leader_capslock_active
    " let mapleader = "\<Nop>"
  " else
    " let mapleader = "\<Caps_Lock>"
  " endif
  " let g:leader_capslock_active = !g:leader_capslock_active
  " echo "Leader CapsLock " . (g:leader_capslock_active ? "activated" : "deactivated")
" endfunction
" 
" nnoremap <silent> <leader> :call ToggleLeaderCapslock()<CR>
" }}}
" => ne fonctionne pas

" Suggestion de ChatGPT:{{{

" augroup leader_capslock
  " autocmd!
  " autocmd InsertEnter * silent !toggle_caps_lock.sh
  " autocmd InsertLeave * silent !toggle_caps_lock.sh
" augroup END
" 
" let mapleader = "\<Leader>"


" }}}
" => ne fonctionne pas

" Suggestion de ChatGPT:{{{

" function! ToggleCapsLock()
  " let caps_state = system('xset q | grep "Caps Lock:" | awk "{print $NF}"')
  " if caps_state =~ "on"
    " call feedkeys("\<Esc>:echo 'Caps on!'\<CR>", 'n')
  " else
    " call feedkeys("\<Esc>:echo 'Caps off!'\<CR>", 'n')
  " endif
" endfunction
" 
" }}}
" nnoremap <Caps_Lock> :call ToggleCapsLock()<CR>
" }}}
" let mapleader = "\<Leader>"



" test:
" nnoremap <Leader>b :echo "Hello, Caps_Lock!"<CR>


" set timeoutlen=500          " Set timeout length to 500 ms
set showcmd "Vim, by default, shows no feedback for this timeout length. Add set showcmd to your vimrc and it will show your leader key in the bottom right corner for the duration of the timeout.

" Nota Bene: pour highlighter les mots sous le curseur avec 123456789,
" il faut faire <leader>m
" puis <leader>1 ou 2 ... sur le mot choisi
" }}}



" Remplacement pour windo, qui a l'inconvénient de revenir à la fenêtre initiale:{{{

" 2024_03_25__12_12_58
" https://vim.fandom.com/wiki/Windo_and_restore_current_window
" 
" The :windo, :bufdo, :argdo and :tabdo commands are great. However, they have one side-effect that I don't like: they change the current window/buffer/tab and make it the last one. Toward that end, I have the following commands defined in my environment: 

" Just like windo, but restore the current window when done.
function! WinDo(command)
  let currwin=winnr()
  execute 'windo ' . a:command
  execute currwin . 'wincmd w'
endfunction
com! -nargs=+ -complete=command Windo call WinDo(<q-args>)

" Just like Windo, but disable all autocommands for super fast processing.
com! -nargs=+ -complete=command Windofast noautocmd call WinDo(<q-args>)

" Just like bufdo, but restore the current buffer when done.
function! BufDo(command)
  let currBuff=bufnr("%")
  execute 'bufdo ' . a:command
  execute 'buffer ' . currBuff
endfunction
com! -nargs=+ -complete=command Bufdo call BufDo(<q-args>)



"Using them is no different from using the standard :windo or :bufdo, except that when you're done, you're right back where you were.
" 
" Examples:
" 
" :Windofast set nu
" 
" Turns on line-numbers in all windows – quickly (because no autocommands trigger) – and leaves your cursor exactly where it was so that you may continue with what you were doing.
" 
" Here's another example, one that I have defined permanently:
" 
" function! SetAutoSaveAndRestore( enable )
  " augroup SaveAndRestoreAll
    " au!
    " if a:enable
      " au FocusLost * silent! Windo call UpdateIfPossible()
      " au FocusGained * silent! checktime
    " endif
  " augroup END
" endfunction
" " Automatically write all changed buffers every time we move out of the Vim window
" call SetAutoSaveAndRestore( 1 )
" 
" " Writes out the current file if it isn't read-only, has changed and has a name.
" " Useful from the autocommand that saves all files upon Vim's losing focus.
" function! UpdateIfPossible()
  " if expand('%') == ''
    " return
  " elseif &ro || !&modified
    " return
  " endif
  " update
" endfunction
" 
" Whenever the Vim window is left (to go to an IDE for concurrent development, for example), all modified and writable files are saved. Conversely, the call to 'checktime' automatically updates the contents of any files that may have been modified with the latest version on disk.
" 
" The above should be combined with 'autoread' and 'autowrite' for best results.


" }}}

" Lecture automatique des fichiers ouverts: {{{
" Autoread file par défaut
set autoread | au CursorHold * checktime | call feedkeys("lh")
" }}}


" Pour rigoler: {{{

" Ça met en verlan toutes les fenêtres de tous les onglets:
" nnoremap <C-F1> :tabdo windo set rl!<CR>
" inoremap <C-F1> :tabdo windo set rl!<CR>

" Moins drôle: juste pour l'onglet courant:
nnoremap <C-F1> :Windofast set rl!<CR>
inoremap <C-F1> :Windofast set rl!<CR>

" }}}

" Pour les folds^Wreplis chéris: {{{

set foldmethod=marker
set fdc=5
set foldclose=all

" pour se déplacer dans les replis: {{{
" https://stackoverflow.com/questions/9403098/is-it-possible-to-jump-to-the-next-closed-fold-in-vim
"
" In Vim, I often find myself wanting to do a quick zk or zj to jump to the previous or next fold in a file. The problem is, I frequently want to skip all the open folds, and just jump to the nearest closed fold.
" Is there a way to do this? I see no built-in keymap in the help.
"
"=>
" Let me propose the following implementation of the described behavior.
nnoremap <silent> <leader>zj :call NextClosedFold('j')<cr>
nnoremap <silent> <leader>zk :call NextClosedFold('k')<cr>

function! NextClosedFold(dir)
    let cmd = 'norm!z'..a:dir
    let view = winsaveview()
    let [l0, l, open] = [0, view.lnum, 1]
    while l != l0 && open
        exe cmd
        let [l0, l] = [l, line('.')]
        let open = foldclosed(l) < 0
    endwhile
    if open
        call winrestview(view)
    endif
endfunction

" If it is desirable for the mappings to accept a count for the number of repetitions of the corresponding movement, one can implement a simple function for repeating any given command:

function! RepeatCmd(cmd) range abort
    let n = v:count < 1 ? 1 : v:count
    while n > 0
        exe a:cmd
        let n -= 1
    endwhile
endfunction

" and then redefine the above mappings as follows:
nnoremap <silent> <leader>zj :<c-u>call RepeatCmd('call NextClosedFold("j")')<cr>
nnoremap <silent> <leader>zk :<c-u>call RepeatCmd('call NextClosedFold("k")')<cr>

" }}}

"Pour ôter les /* */ disgrâcieux de mes folds {{{ }}} ou [ ]
set commentstring=%s

" }}}

" Pour commenter des lignes: {{{

" pour commenter une ligne de code Rebol et passer à la suivante:
noremap ; ^i;<Space><Esc><Down>

" pour commenter une ligne de code, genre shell script, par # , puis passer à la suivante:
"noremap &; <Home>i#<Esc><Down>
" => marche pas...
noremap £ ^i#<Space><Esc><Down>

" _______________JEANSUILÀ_____________ rationaliser cette partie avec vimrc_spi
" pour faire la même chose, MAIS en mettant le '# ' au début de la ligne, et non pas devant le premier caractère non blanc:
noremap ¤ 0i#<Space><Esc><Down>
" Idem, de 2023 dans vimrc_spi: {{{
" " pour commenter de la même manière, mais en #ant ça tout à gauche, et non pas juste avant le texte:
" " map <A-£> <Home>i#<Space><Esc><Down>
" " C'est Alt-$:
" noremap $ <Home>i#<Space><Esc><Down>
" }}}

" pour commenter une ligne de code SQL et passer à la suivante:
noremap - ^i--<Space><Esc><Down><Home>

" pour commenter une ligne de code vim et passer à la suivante:
noremap " ^i"<Space><Esc><Down><Home>
" Idem, de 2023 dans vimrc_spi: {{{
" noremap " ^i"<Space><Esc><Down>
" " }}}

" enfin, pour décommenter une ligne en supprimant les 2 premiers caractères (ça laissera une espace pour le SQL: bof, osef):
noremap µ ^<Del><Del><Down><Home>
" Idem, de 2023 dans vimrc_spi: {{{
" " pour décommenter une ligne de code commentée par le £ précédent, puis passer à la suivante:
" map µ ^xx<Down>
" }}}


" 2023_07_25__18_32_28 je fais plutôt une fonction, pour trouver s'il n'y a pas des espaces en début de ligne et préserver ainsi une indentation:
"function! CommentLine(commentstring)
"    "check if at beginning of line or after a space
"    if strpart(getline('.'), 0, col('.')-1) =~ '^\s*$'
"    return "w
"endfunction

" " Plutôt, je recopie un plugin, commentary: {{{ "" => annulé
"
" " https://github.com/tpope/vim-commentary/blob/master/plugin/commentary.vim
"
"
" " commentary.vim - Comment stuff out
" " Maintainer:   Tim Pope <http://tpo.pe/>
" " Version:      1.3
" " GetLatestVimScripts: 3695 1 :AutoInstall: commentary.vim
"
" if exists("g:loaded_commentary") || v:version < 703
"   finish
" endif
" let g:loaded_commentary = 1
"
" function! s:surroundings() abort
"   return split(get(b:, 'commentary_format', substitute(substitute(substitute(
"         \ &commentstring, '^$', '%s', ''), '\S\zs%s',' %s', '') ,'%s\ze\S', '%s ', '')), '%s', 1)
" endfunction
"
" function! s:strip_white_space(l,r,line) abort
"   let [l, r] = [a:l, a:r]
"   if l[-1:] ==# ' ' && stridx(a:line,l) == -1 && stridx(a:line,l[0:-2]) == 0
"     let l = l[:-2]
"   endif
"   if r[0] ==# ' ' && (' ' . a:line)[-strlen(r)-1:] != r && a:line[-strlen(r):] == r[1:]
"     let r = r[1:]
"   endif
"   return [l, r]
" endfunction
"
" function! s:go(...) abort
"   if !a:0
"     let &operatorfunc = matchstr(expand('<sfile>'), '[^. ]*$')
"     return 'g@'
"   elseif a:0 > 1
"     let [lnum1, lnum2] = [a:1, a:2]
"   else
"     let [lnum1, lnum2] = [line("'["), line("']")]
"   endif
"
"   let [l, r] = s:surroundings()
"   let uncomment = 2
"   let force_uncomment = a:0 > 2 && a:3
"   for lnum in range(lnum1,lnum2)
"     let line = matchstr(getline(lnum),'\S.*\s\@<!')
"     let [l, r] = s:strip_white_space(l,r,line)
"     if len(line) && (stridx(line,l) || line[strlen(line)-strlen(r) : -1] != r)
"       let uncomment = 0
"     endif
"   endfor
"
"   if get(b:, 'commentary_startofline')
"     let indent = '^'
"   else
"     let indent = '^\s*'
"   endif
"
"   let lines = []
"   for lnum in range(lnum1,lnum2)
"     let line = getline(lnum)
"     if strlen(r) > 2 && l.r !~# '\\'
"       let line = substitute(line,
"             \'\M' . substitute(l, '\ze\S\s*$', '\\zs\\d\\*\\ze', '') . '\|' . substitute(r, '\S\zs', '\\zs\\d\\*\\ze', ''),
"             \'\=substitute(submatch(0)+1-uncomment,"^0$\\|^-\\d*$","","")','g')
"     endif
"     if force_uncomment
"       if line =~ '^\s*' . l
"         let line = substitute(line,'\S.*\s\@<!','\=submatch(0)[strlen(l):-strlen(r)-1]','')
"       endif
"     elseif uncomment
"       let line = substitute(line,'\S.*\s\@<!','\=submatch(0)[strlen(l):-strlen(r)-1]','')
"     else
"       let line = substitute(line,'^\%('.matchstr(getline(lnum1),indent).'\|\s*\)\zs.*\S\@<=','\=l.submatch(0).r','')
"     endif
"     call add(lines, line)
"   endfor
"   call setline(lnum1, lines)
"   let modelines = &modelines
"   try
"     set modelines=0
"     silent doautocmd User CommentaryPost
"   finally
"     let &modelines = modelines
"   endtry
"   return ''
" endfunction
"
" function! s:textobject(inner) abort
"   let [l, r] = s:surroundings()
"   let lnums = [line('.')+1, line('.')-2]
"   for [index, dir, bound, line] in [[0, -1, 1, ''], [1, 1, line('$'), '']]
"     while lnums[index] != bound && line ==# '' || !(stridx(line,l) || line[strlen(line)-strlen(r) : -1] != r)
"       let lnums[index] += dir
"       let line = matchstr(getline(lnums[index]+dir),'\S.*\s\@<!')
"       let [l, r] = s:strip_white_space(l,r,line)
"     endwhile
"   endfor
"   while (a:inner || lnums[1] != line('$')) && empty(getline(lnums[0]))
"     let lnums[0] += 1
"   endwhile
"   while a:inner && empty(getline(lnums[1]))
"     let lnums[1] -= 1
"   endwhile
"   if lnums[0] <= lnums[1]
"     execute 'normal! 'lnums[0].'GV'.lnums[1].'G'
"   endif
" endfunction
"
" command! -range -bar -bang Commentary call s:go(<line1>,<line2>,<bang>0)
" xnoremap <expr>   <Plug>Commentary     <SID>go()
" nnoremap <expr>   <Plug>Commentary     <SID>go()
" nnoremap <expr>   <Plug>CommentaryLine <SID>go() . '_'
" onoremap <silent> <Plug>Commentary        :<C-U>call <SID>textobject(get(v:, 'operator', '') ==# 'c')<CR>
" nnoremap <silent> <Plug>ChangeCommentary c:<C-U>call <SID>textobject(1)<CR>
" nmap <silent> <Plug>CommentaryUndo :echoerr "Change your <Plug>CommentaryUndo map to <Plug>Commentary<Plug>Commentary"<CR>
"
" if !hasmapto('<Plug>Commentary') || maparg('gc','n') ==# ''
"   xmap gc  <Plug>Commentary
"   nmap gc  <Plug>Commentary
"   omap gc  <Plug>Commentary
"   nmap gcc <Plug>CommentaryLine
"   nmap gcu <Plug>Commentary<Plug>Commentary
" endif
"
" " vim:set et sw=2:
"
" }}}

" }}}


" Syntaxe: {{{

"syntaxe Rebol:
set syntax=rebol
"aussitôt désactivée:
set syntax=none
"=> c'est pour avoir les complétions judicieuses, les mots avec des - vus comme un seul mot (ce qui est commode), mais sans avoir les couleurs (qui n'aident pas forcément beaucoup).

" }}}


" Couleurs pour vimdiff: {{{

" Des couleurs de vimdiff un peu plus humainement lisibles pour un presse-b!t3:
highlight DiffAdd    ctermbg=6
highlight DiffChange ctermbg=2
highlight DiffDelete ctermbg=6
highlight DiffText   ctermfg=1 ctermbg=2 cterm=bold

" Toujours dans le cadre d'un vimdiff, passer à la ligne et ne pas coloriser la syntaxe:
if &diff
    syntax off
    " essayé tout ça, sans succès: {{{
    "execute 'set wrap'
    ""set wrap
    "execute 'windo set wrap'
    "autocmd FilterWritePre * if &diff | setlocal wrap< | endif
    " }}}
    set wrap
    " Pour ignorer les espaces (utile quand collage de codes divers...)
    " set diffopt+=iwhite
    " \_ c'est parfois aussi très embêtant: à basculer, au besoin
    " set diffexpr=""
endif

" }}}

" Toujours pour vimdiff, remappage des raccourcis pour Patcher des diffs et pour les Getter en allant, après, à la diff suivante:{{{

" Pour vimdiff, faire aller à la diff suivante quand on fait un dp ou un dg:
nnoremap dp :diffput<cr>]c
nnoremap dg :diffget<cr>]c

" }}}

" Toujours pour vimdiff, remappage de raccourcis pour naviguer entre les  diffs:{{{


nnoremap <Leader>j ]c
nnoremap <Leader>k [c
" Mieux?:
nnoremap <A-PageUp>   ]c
nnoremap <A-PageDown> [c

" }}}


" Remappage de touches diverses: {{{

" Pour coller rapidement en passant par xclip, au lieu d'avoir des caractères à la noix quand on colle: {{{
nnoremap <C-Insert>         :r !xclip -o<cr>
inoremap <C-Insert>  <Esc>mz:r !xclip -o<cr>`za
" vnoremap <C-Insert>        x:r !xclip -o<cr>
" non, ce dernier est stupide, dans la mesure où la sélection (chez un vim
" bien élevé) est déjà dans le presse-papiers de X...


" Voici les traficougnages sans noms que j'ai faits pour avoir le presse-papiers de X en mettant un xclip à la rache chez Spie sur Suse avec ce p. de vim sans X...:{{{

" " Mapper Ctrl-Insert avec copier vers xclip: uniquement si l'on n'est PAS dans gvim:
" if has('gui_running')
  " " RAS... (je sais pas écrire une négation...)
" else
  " " vnoremap <C-Ins> "*y
  " " vnoremap <C-Insert>:w !xclip -i<cr>
  " " nnoremap <C-Insert>V:w !xclip -i<cr>
  " " => marche pas...
  " " Inspiration depuis latitude:
  " " nnoremap <S-Insert>        :r !xclip -r -o<cr>
  " " inoremap <S-Insert>   <Esc>:r !xclip -r -o<cr>a
  " " => annulé, ça mettait le ouaï dans gvim...
" 
" 
" 
  " " vnoremap <C-Insert>        y :execute 'xclip -i < echo '.shellescape(@", 1)
  " " vnoremap <silent> <C-Insert> y:execute '! echo '.shellescape(@", 1).' | xclip -i'
  " " vnoremap <C-Insert> y:! 'echo '.shellescape(@", 1).' | xclip -i'<cr>
  " " vnoremap <C-Insert> y:silent exec ":!xclip -i <".shellescape(@", 1)<cr>
  " " vnoremap <C-Insert> :w !cat > $HOME/totoxclip<cr>
  " "let coucou="coucouroucoucou"
  " " Avec Ctrl-V, C-Insert donne ça:
  " " [2;5
  " " vnoremap [2;5~ :w !xclip -i<cr>
  " " vnoremap <silent> [2;5~ y:! bash -c 'echo "0" \| xclip -i'<cr>
  " " vnoremap [2;5~ y :execute 'xclip -i < echo '.shellescape(@", 1)
  " " y :execute 'xclip -i < echo '.shellescape(@", 1)
  " " vnoremap [2;5~ :w !eval 'xclip -i "'"$(cat)"'"'<cr>
  " " y:! bash -c 'echo "0" \| xclip -i'<cr>
  " " vnoremap [2;5~ y:execute '! xclip -i < echo '.shellescape(@", 1)
  " " vnoremap [2;5~ y:execute '! xclip -i < echo '.shellescape(@")<cr>
  " " vnoremap [2;5~ y:execute '! echo '.shellescape(@").'! | xclip -i'<cr>
  " " function! CopySelectionToXClipBoard()
    " " yank
    " " ...
  " " endfunction
  " "Selon du stackoverflow.com: #{{{
  " set clipboard=unnamedplus
  " function! ClipboardYank()
    " " call system('xclip -i -selection clipboard', @@)
    " call system('xclip -i', @@)
  " endfunction
  " let vlcb = 0
  " let vlce = 0
  " function! ClipboardPaste(mode)
    " if (a:mode == "v")
      " call cursor(g:vlcb[0], g:vlcb[1]) | execute "normal! v" | call cursor(g:vlce[0], g:vlce[1])
    " endif
    " " let @@ = system('xclip -o -selection clipboard')
    " let @@ = system('xclip -o')
  " endfunction
  " " Replace currently selected text with default register without yanking it
  " vnoremap <silent>p   "_dP
  " vnoremap <silent>y   y: call ClipboardYank()<CR>
  " nnoremap <silent>yy  yy: call ClipboardYank()<CR>
  " nnoremap <silent><S-y> yy: call ClipboardYank()<CR>
  " " nnoremap <silent>wx icocowwww<Esc>
  " vnoremap <silent>d   d: call ClipboardYank()<CR>
  " nnoremap <silent>dd  dd: call ClipboardYank()<CR>
  " nnoremap <silent><S-d>  dd: call ClipboardYank()<CR>
  " nnoremap <silent>p   :call ClipboardPaste("n")<CR>p
  " vnoremap p           :<C-U>let vlcb = getpos("'<")[1:2] \| let vlce = getpos("'>")[1:2] \| call ClipboardPaste("v")<CR>p
  " " au_quai jusqu'ici
" 
  " " " ça fonctionne!
  " " J'ajoute les raccourcis C-Insert et autres:
  " " <C-Insert>
  " vnoremap <silent>[2;5~    y: call ClipboardYank()<CR>
  " inoremap <silent>[2;5~    y: call ClipboardYank()<CR>a
  " " _______________ENCOURS_______________QUELQUECHOSE
" 
  " " Annulation de tout!
  " " unmap <silent>wx
  " " unmap <S-Insert>
  " " unmap <S-Insert>
  " " unmap <S-Insert>
  " " unmap <S-Insert>
  " unmap <silent>d
  " unmap <silent>dd
  " unmap <silent><S-d>
  " unmap <silent>p
  " " _______________ENCOURS_______________QUELQUECHOSE
" 
" 
" 
  " " #}}}
" endif

" }}}

" }}}


" Té, pour naviguer dans les tampons (buffers): {{{
nnoremap <Leader>b :buffers<cr>:buffer<Space>
" }}}


" }}}
let salut="coucou3"
endif "@# fin de code désactivé #############################################]]]]

" Ctrl-flèches et Ctrl-jk pour déplacer les lignes: 
if va4 == "oui" "@# début de code désactivé #############################################[[[[
" Ctrl-flèches et Ctrl-jk pour déplacer les lignes: {{{

"Ctrl-jk pour faire pareil: (marche pas...) => 2020_07_09__12_13_32 en fait, si on met les lignes map <S-C-k> avant, ce sont elles qui prennent le pas sur les lignes map <C-k>, curieusement. Ça ne le fait pas pour les <C-Flèches, c'est étrange.
" => 2023_07_25__18_21_51 ça fonctionne. => 2023_07_26__13_01_35 ça fonctionne, mais pas dans un screen... => 2023_08_30__18_23_19 ça fonctionne, mais pas dans un tmux...
"Ctrl-jk pour faire pareil: (marche pas...) => 2020_07_09__12_13_32 en fait, si on met les lignes map <S-C-k> avant, ce sont elles qui prennent le pas sur les lignes map <C-k>, curieusement. Ça ne le fait pas pour les <C-Flèches, c'est étrange.
" let g:C_Ctrl_j = 'off'

" nnoremap < > <C-j>
" nnoremap <> <C-k>
nnoremap <C-j>      ddp
noremap  <C-j>      ddp
inoremap <C-j> <Esc>ddpa
nnoremap <C-k>      ddkP
noremap  <C-k>      ddkP
inoremap <C-k> <Esc>ddkPa

if empty($TMUX)
  " nnoremap <A-j> :echo "Pas dans TMUX!"<cr>
  " nnoremap <C-j> :echo "Pas dans TMUX!"<cr>
  nnoremap <C-j>  ddp
else
  " nnoremap <A-j> :echo " dans TMUX!"<cr>
  " nnoremap <C-j> :echo " dans TMUX!"<cr>
  " noremap <C- > :echo "Dans TMUX!"<cr>
  " let g:C_Ctrl_j = 'off'
endif

" Idem, de 2023 dans vimrc_spi: {{{
" map <C-j> ddp
" map <C-k> ddkP
" inoremap <C-j> <Esc>ddpa
" inoremap <C-k> <Esc>ddkPa
" }}}

"map   ddp
"map    ddkP
" => ne fonctionne pas...

"Ctrl-flèches pour déplacer les lignes, comme dans oOo: {{{
"nnoremap <C-Up> ddkp <CR>    "DONE marche pas => si, ainsi:
"map <C-Up> ddkP
"map <C-Down> ddp
"inoremap <C-Up>   <Esc>ddkPa
"inoremap <C-Down> <Esc>ddpa

" Autre version, trouvée dans http://www.billodom.com/talks/vim-key-mapping.pdf: plus efficace, marche avec des sélections, en les gardant:
"nnoremap <silent> <C-Up> :move -2<CR>
"nnoremap <silent> <C-Down> :move +<CR>
"xnoremap <silent> <C-Up> :move '<-2<CR>gv
"xnoremap <silent> <C-Down> :move '>+<CR>gv
"imap <silent> <C-Up> <C-O><C-Up>
"imap <silent> <C-Down> <C-O><C-Down>
"smap <silent> <C-Up> <C-G><C-Up><C-G>
"smap <silent> <C-Down> <C-G><C-Down><C-G>

"Encore une autre version, en essayant d'améliorer, pour faire comme avant, notamment en bougeant les blocs z:
"nnoremap <C-Up> ddkp <CR>    "DONE marche pas => si, ainsi:
"map <C-Up> ddkP
"map <C-Down> ddp
"inoremap <C-Up>   <Esc>ddkPa
"inoremap <C-Down> <Esc>ddpa

nnoremap <silent> <C-Up>        ddkP
inoremap <silent> <C-Up>   <Esc>ddkPa
snoremap <silent> <C-Up>   <Esc>ddkPa
" _______________JEANSUILÀ_____________ c'est quoi, snoremap?
xnoremap <silent> <C-Up>        :move '<-2<CR>gv
nnoremap <silent> <C-Down>      ddp
inoremap <silent> <C-Down> <Esc>ddpa
snoremap <silent> <C-Down> <Esc>ddpa
xnoremap <silent> <C-Down>      :move '>+<CR>gv

" }}}


" }}}

" Shift-Ctrl-flèches et Shift-Ctrl-jk pour défiler: {{{
" Shift-Ctrl-flèches pour défiler (scroller) de 10 lignes (passé de 5 à 7 à 10):
noremap  <S-C-Up>        10<C-y>
inoremap <S-C-Up>   <Esc>10<C-y>a
noremap  <S-C-Down>      10<C-e>
inoremap <S-C-Down> <Esc>10<C-e>a

" Shift-Ctrl-jk pour défiler (scroller) de 10 lignes (passé de 3 à 5 à 10):
noremap  <S-C-k>        10<C-y>
inoremap <S-C-k>   <Esc>10<C-y>a
noremap  <S-C-j>        10<C-e>
inoremap <S-C-j>   <Esc>10<C-e>a

" }}}
let salut="coucou4"
endif "@# fin de code désactivé #############################################]]]]

if va5 == "oui" "@# début de code désactivé #############################################[[[[
" Navigation entre fenêtres avec Alt-flèches et Alt-hjkl: {{{

" Pour vivre avec tmux, voir 2023_10_01__20_32_50


" " Alt-flèches pour naviguer entre les fenêtres, à la mode de chez terminator: {{{
" " 2023_08_28__12_36_18 Annulé, pour le tmux_navigator, voir à cet autre horodatage
" noremap  <A-Up>         :wincmd k<cr>
" noremap  <A-Down>       :wincmd j<cr>
" noremap  <A-Left>       :wincmd h<cr>
" noremap  <A-Right>      :wincmd l<cr>
" inoremap <A-Up>    <esc>:wincmd k<cr>a
" inoremap <A-Down>  <esc>:wincmd j<cr>a
" inoremap <A-Left>  <esc>:wincmd h<cr>a
" inoremap <A-Right> <esc>:wincmd l<cr>a
"
" "Alt-hjkl pour naviguer de même:
" noremap <A-k>           :wincmd k<cr>
" noremap <A-j>           :wincmd j<cr>
" noremap <A-h>           :wincmd h<cr>
" noremap <A-l>           :wincmd l<cr>
" " inoremap <A-k>   <Esc>mz:wincmd k<cr>`za
" " inoremap <A-j>   <Esc>mz:wincmd j<cr>`za
" " inoremap <A-h>   <Esc>mz:wincmd h<cr>`za
" " inoremap <A-l>   <Esc>mz:wincmd l<cr>`za
" " => annulé les 4 derni:wincmd h
" " res lignes, car voilà ce qu'elles induisaient, m:wincmd j
" " me si l'on n'était pas dans un screen...
" 2023_08_28__12_36_18

" Idem, de 2023 dans vimrc_spi: {{{
" " Sur Suse:
" map k :wincmd k<cr>
" map j :wincmd j<cr>
" map h :wincmd h<cr>
" map l :wincmd l<cr>
" 
" " Sur Suse dans un screen:
" " map [1;3A :wincmd k<cr>
" " map [1;3B :wincmd j<cr>
" " map [1;3D :wincmd h<cr>
" " map [1;3C :wincmd l<cr>

" if empty($TMUX)
"     " Touches capturées dans vim SANS tmux avec C-V:
"     " 
"     "  
"     " 
"     " 
"     noremap  <A-Up>         :TmuxNavigateUp<cr>
"     noremap  <A-Down>       :TmuxNavigateDown<cr>
"     noremap  <A-Left>       :TmuxNavigateLeft<cr>
"     noremap  <A-Right>      :TmuxNavigateRight<cr>
"     inoremap <A-Up>    <esc>:TmuxNavigateUp<cr>a
"     inoremap <A-Down>  <esc>:TmuxNavigateDown<cr>a
"     inoremap <A-Left>  <esc>:TmuxNavigateLeft<cr>a
"     inoremap <A-Right> <esc>:TmuxNavigateRight<cr>a
"     "Alt-hjkl pour naviguer de même:
"     noremap  <A-k>          :TmuxNavigateUp<cr>
"     noremap  <A-j>          :TmuxNavigateDown<cr>
"     noremap  <A-h>          :TmuxNavigateLeft<cr>
"     noremap  <A-l>          :TmuxNavigateRight<cr>
"     inoremap <A-k>   <Esc>mz:TmuxNavigateUp<cr>`za
"     inoremap <A-j>   <Esc>mz:TmuxNavigateDown<cr>`za
"     inoremap <A-h>   <Esc>mz:TmuxNavigateLeft<cr>`za
"     inoremap <A-l>   <Esc>mz:TmuxNavigateRight<cr>`za
" else
"     " Touches capturées dans vim dans tmux avec C-V:
"     " k
"     " j
"     " h
"     " l
"     " Ah bé si je refais ça, c'est différent: ???
"     " ê
"     " ë
"     " è
"     " ì
"     " => à ne SURTOUT pas mettre en inoremap...
"     " TODO vérifier que tout aille bien avec les flèches
"     noremap  k          :TmuxNavigateUp<cr>
"     noremap  j          :TmuxNavigateDown<cr>
"     noremap  h          :TmuxNavigateLeft<cr>
"     noremap  l          :TmuxNavigateRight<cr>
"     inoremap k     <esc>:TmuxNavigateUp<cr>a
"     inoremap j     <esc>:TmuxNavigateDown<cr>a
"     inoremap h     <esc>:TmuxNavigateLeft<cr>a
"     inoremap l     <esc>:TmuxNavigateRight<cr>a
"     "Alt-hjkl pour naviguer de même:
"     noremap  k          :TmuxNavigateUp<cr>
"     noremap  j          :TmuxNavigateDown<cr>
"     noremap  h          :TmuxNavigateLeft<cr>
"     noremap  l          :TmuxNavigateRight<cr>
"     inoremap k   <Esc>mz:TmuxNavigateUp<cr>`za
"     inoremap j   <Esc>mz:TmuxNavigateDown<cr>`za
"     inoremap h   <Esc>mz:TmuxNavigateLeft<cr>`za
"     inoremap l   <Esc>mz:TmuxNavigateRight<cr>`za
"     "Alt-hjkl pour naviguer de même, avec l'autre mappage dans tmux (??), SANS le mode insertion:
"     noremap  ê            :TmuxNavigateUp<cr>
"     noremap  ë            :TmuxNavigateDown<cr>
"     noremap  è            :TmuxNavigateLeft<cr>
"     noremap  ì            :TmuxNavigateRight<cr>
" endif



" Pareil, avec les touches telles que reçues dans le xterm en regardant avec
" sed -n l
"  nnoremap ë :wincmd k<cr>
"  nnoremap ê :wincmd j<cr>
"  nnoremap è :wincmd h<cr>
"  nnoremap ì :wincmd l<cr>
" Cela ne fonctionne pas en mode insertion, bien sûr.
" => mais si!! Ça prend le pas et ça marque :wincmd h quand on tape sur la touche e avec accent grave!! => annulé!


" # => ça ne fonctionne point...


" }}}
let salut="coucou5"
endif "@# fin de code désactivé #############################################]]]]


if va55 == "oui" "@# début de code désactivé #############################################[[[[
" # Autre essai, selon https://www.codeography.com/2013/06/19/navigating-vim-and-tmux-splits : {{{

if exists('$TMUX')
  function! TmuxOrSplitSwitch(wincmd, tmuxdir)
    let previous_winnr = winnr()
    silent! execute "wincmd " . a:wincmd
    if previous_winnr == winnr()
      call system("tmux select-pane -" . a:tmuxdir)
      redraw!
    endif
  endfunction

  let previous_title = substitute(system("tmux display-message -p '#{pane_title}'"), '\n', '', '')
  let &t_ti = "\<Esc>]2;vim\<Esc>\\" . &t_ti
  let &t_te = "\<Esc>]2;". previous_title . "\<Esc>\\" . &t_te

  nnoremap <silent> <A-h>          :call TmuxOrSplitSwitch('h', 'L')<cr>
  nnoremap <silent> <A-j>          :call TmuxOrSplitSwitch('j', 'D')<cr>
  nnoremap <silent> <A-k>          :call TmuxOrSplitSwitch('k', 'U')<cr>
  nnoremap <silent> <A-l>          :call TmuxOrSplitSwitch('l', 'R')<cr>

" C'est à la ligne suivante que se situe le problème qui empêche de faire è en mode insertion ###
  inoremap <silent> <A-h>     <esc>:call TmuxOrSplitSwitch('h', 'L')<cr>a
  inoremap <silent> <A-j>     <esc>:call TmuxOrSplitSwitch('j', 'D')<cr>a
  inoremap <silent> <A-k>     <esc>:call TmuxOrSplitSwitch('k', 'U')<cr>a
  inoremap <silent> <A-l>     <esc>:call TmuxOrSplitSwitch('l', 'R')<cr>a


  nnoremap <silent> <A-Left>       :call TmuxOrSplitSwitch('h', 'L')<cr>
  nnoremap <silent> <A-Down>       :call TmuxOrSplitSwitch('j', 'D')<cr>
  nnoremap <silent> <A-Up>         :call TmuxOrSplitSwitch('k', 'U')<cr>
  nnoremap <silent> <A-Right>      :call TmuxOrSplitSwitch('l', 'R')<cr>

  inoremap <silent> <A-Left>  <esc>:call TmuxOrSplitSwitch('h', 'L')<cr>a
  inoremap <silent> <A-Down>  <esc>:call TmuxOrSplitSwitch('j', 'D')<cr>a
  inoremap <silent> <A-Up>    <esc>:call TmuxOrSplitSwitch('k', 'U')<cr>a
  inoremap <silent> <A-Right> <esc>:call TmuxOrSplitSwitch('l', 'R')<cr>a

else
  "2023_12_16__19_47_21 
  " Déplacé vers .vim/vimrc_else.vim
  " => rapatrié, avec des tests infructueux pour essayer avec Meta au lieu de Alt, en appelant la fonction Bonjour, pour voir:
  " nnoremap <M-h>                   :Bonjour h<cr>
  nnoremap <A-h>                   :wincmd h<cr>
  nnoremap <A-j>                   :wincmd j<cr>
  nnoremap <A-k>                   :wincmd k<cr>
  nnoremap <A-l>                   :wincmd l<cr>

  nnoremap <A-Left>                :wincmd h<cr>
  nnoremap <A-Down>                :wincmd j<cr>
  nnoremap <A-Up>                  :wincmd k<cr>
  nnoremap <A-Right>               :wincmd l<cr>


" C'est à la ligne suivante que se situe le problème qui empêche de faire è en mode insertion ###
  " inoremap <M-h>              <esc>:Bonjour h<cr>a
  inoremap <A-h>              <esc>:wincmd h<cr>a
  inoremap <A-j>              <esc>:wincmd j<cr>a
  inoremap <A-k>              <esc>:wincmd k<cr>a
  inoremap <A-l>              <esc>:wincmd l<cr>a

  inoremap <A-Left>           <esc>:wincmd h<cr>a
  inoremap <A-Down>           <esc>:wincmd j<cr>a
  inoremap <A-Up>             <esc>:wincmd k<cr>a
  inoremap <A-Right>          <esc>:wincmd l<cr>a

" source $HOME/.vim/vimrc_else.vim
endif


" }}}

" }}}
" }}}
let salut="coucou55"
endif "@# fin de code désactivé #############################################]]]]

if va6 == "oui" "@# début de code désactivé #############################################[[[[
""""""""""""""""""""""""""""""""""""""""""""""""""
" Complétion par tabulation: à partir d'un vimrc trouvé sur la Toile: {{{
""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""
" Fichier .vimrc de Nicolas Gressier
" Créé le 11 mai 2006
" Yoshidu62@gmail.com
" Mise à jour : 03/06/2009
" Version 2.6
""""""""""""""""""""""""""""""""""""""""""""""""""
"Complétion par tabulation: {{{
""""""""""""""""""""""""""""""""""""""""""""""""""
function! CleverTab()
    "check if at beginning of line of after a space
    if strpart(getline('.'), 0, col('.')-1) =~ '^\s*$'
    return "\<Tab>"
    else
    "use know-word completion
    "return "\<C-N>"
    "use know-word completion, mais plutôt à l'envers
    return "\<C-P>"
    endif
endfunction

function! CleverTabShift()
    "check if at beginning of line or after a space
    if strpart(getline('.'), 0, col('.')-1) =~ '^\s*$'
    return "\<S-Tab>"
    else
    "use known-word completion, à l'endroit
    return "\<C-N>"
    endif
endfunction

"Mapping sur la touche Tab
inoremap <Tab> <C-R>=CleverTab()<CR>

"et pareil sur la combinaison de touches Shift Tab:
inoremap <S-Tab> <C-R>=CleverTabShift()<CR>
" }}}

" }}}
let salut="coucou6"
endif "@# fin de code désactivé #############################################]]]]

if va7 == "oui" "@# début de code désactivé #############################################[[[[
" Ctrl-Tab pour naviguer entre les fenêtres (bof, peu usité, abandonné le 2022_03_24__18_26_16 avec un " devant): {{{

" " MARCHE PAS :
" map <C-Tab> <C-w><C-w>
" 2023_08_03__18_30_38 => si, ça fonctionne, mais ça n'est pas ce que je souhaite


" "Marche =>
" " http://stackoverflow.com/questions/2686766/mapping-c-tab-in-my-vimrc-fails-in-ubuntu
" " ...
" " Put this in your .vimrc:

" " !! Important - instead of XXXX you must type CTRL-V and then Esc OR copy-paste the whole text and run %s/\(set <F1[34]>=\)XXXX/\=submatch(1) . "\33"/g which is copy-pastable (insert it with <CTRL-R> +).
" set timeout timeoutlen=1000 ttimeoutlen=100
" set <F13>=[27;5;9~
" "nnoremap <F13> gt
" map <F13> <C-w><C-w>
" set <F14>=[27;6;9~
" "nnoremap <F14> gT
" "map <F14> :tabNext<CR>
" map <F14> <C-w><S-w>
" "And restart vim.
" "Done.
" " Pareil, pour le mode insertion (c'est quand même commode):
" inoremap <F13> <Esc><C-w><C-w>a
" inoremap <F14> <Esc><C-w><S-w>a

" }}}
let salut="coucou7"
endif "@# fin de code désactivé #############################################]]]]

if va8 == "oui" "@# début de code désactivé #############################################[[[[

" Pour naviguer dans les onglets (bof => non, retenté le 2022_03_24__18_26_16): {{{

noremap      <C-tab>            :tabnext<cr>
noremap      <C-S-tab>          :tabprevious<cr>
"noremap     <C-tab>            :tabnext<cr>
"""map       <C-w>              :tabclose<cr> "Surtout pas! Quand on commence à jouer avec les fenêtres, ça interfère, mal!
inoremap     <C-S-tab>  <ESC>   :tabprevious<cr>a
inoremap     <C-tab>    <ESC>   :tabnext<cr>a

if empty($TMUX)
" Ceci ne fonctionne pas dans tmux, ça dit que "E73: La pile des marqueurs est vide"
" Donc on met ça dans un if
  noremap  <C-t>           :tabnew<cr>
  inoremap <C-t>      <ESC>:tabnew<cr>
else
  noremap                :tabnew<cr>
  inoremap          <ESC>:tabnew<cr>
endif

" Idem, de 2023 dans vimrc_spi: {{{
" "# 2023_06_29__08_46_13 Fonctionne avec gvim, mais point avec vim...
" noremap      <C-tab>            :tabnext<cr>
" nmap     <C-tab>            :tabnext<cr>
" nnoremap <C-tab>            :tabnext<cr>
" inoremap <C-tab> <ESC>      :tabnext<cr>a
" imap     <C-tab> <ESC>      :tabnext<cr>a
" map      <C-S-tab>          :tabprevious<cr>
" nmap     <C-S-tab>          :tabprevious<cr>
" nnoremap <C-S-tab> <ESC>    :tabprevious<cr>
" inoremap <C-S-tab> <ESC>    :tabprevious<cr>a
" }}}

" Idem, de 2023 dans vimrc_spi: {{{

" " Sur la Suse:
" " Voilà ce que donne Ctrl-Tab dans vim:
" " [27;5;9~
" map      [27;5;9~         :tabnext<cr>
" nmap     [27;5;9~         :tabnext<cr>
" nnoremap [27;5;9~         :tabnext<cr>
" inoremap [27;5;9~         :tabnext<cr>a
" imap     [27;5;9~  <ESC>  :tabnext<cr>a
" " Et voilà ce que donne Shift-Ctrl-Tab dans vim:
" " [27;6;9~
" map      [27;6;9~  <ESC>  :tabprevious<cr>
" nmap     [27;6;9~  <ESC>  :tabprevious<cr>
" nnoremap [27;6;9~  <ESC>  :tabprevious<cr>
" inoremap [27;6;9~  <ESC>  :tabprevious<cr>a

" }}}
" 2024_03_25__14_01_26

"Alt-+- pour retailler les fenêtres:
nnoremap <A-=> <C-W>=
nnoremap  <A-+> :vertical resize +5<cr>
nnoremap  <A--> :vertical resize -5<cr>
" map  <A-kPlus> :vertical resize +5<cr>
" map  <A-kPlus> :vertical resize +5<cr>
" noremap <A-kPlus>  :vertical resize +5<cr>
" noremap <A-kPlus>  :vertical resize +5<cr>
" => les vertical resize ne fonctionnent pas _______________TODO__________________ faire fonctionner, un beau jour


" Bof: je préfère naviguer dans les onglets avec Ctrl-PgUp/Dn: => 2022_03_25__21_10_28 marde, ça ne fonctionne pas.
if empty($TMUX)
    nnoremap     <C-PageUp>         :tabprevious<cr>
    inoremap     <C-PageUp>    <ESC>:tabprevious<cr>a
    nnoremap     <C-PageDown>       :tabnext<cr>
    inoremap     <C-PageDown>  <ESC>:tabnext<cr>a
else
    " Dans vim dans tmux, C-V donne ça:
    " Ctrl-PgDn:
    " [6;5~
    " Ctrl-PgUp:
    " [5;5~
    " Ctrl-Tab:
    " 	
    " Maj-Ctrl-Tab:
    " 	
    nnoremap  [5;5~       :tabprevious<cr>
    inoremap  [5;5~  <ESC>:tabprevious<cr>a
    nnoremap  [6;5~       :tabnext<cr>
    inoremap  [6;5~  <ESC>:tabnext<cr>a
endif

if empty($TMUX)
  " Navigation entre les onglets en mode vimesque:
  nnoremap <S-A-l>         :tabnext<cr>
  inoremap <S-A-l>  mz<Esc>:tabnext<cr>`za
  nnoremap <S-A-h>         :tabprevious<cr>
  inoremap <S-A-h>  mz<Esc>:tabprevious<cr>`za
else
  nnoremap Ì               :tabnext<cr>
  inoremap Ì        mz<Esc>:tabnext<cr>`za
  nnoremap È               :tabprevious<cr>
  inoremap È        mz<Esc>:tabprevious<cr>`za
endif




" Poubelle:
"     nmap      <C-PageUp>         :tabprevious<cr>
"     nmap      <C-PageUp>         :tabprevious<cr>
"     noremap      <C-PageDown>       :tabnext<cr>
"     nnoremap     <C-PageDown>       :tabnext<cr>
"     ""noremap      <C-t>              :tabnew<cr>
"     ""nnoremap <C-t>                  :tabnew<cr>
"     ""inoremap <C-t>             <ESC>:tabnew<cr>i
"     """map <C-w>                      :tabclose<cr> "Surtout pas! Quand on commence à jouer avec les fenêtres, ça interfère, mal!

" Idem, de 2023 dans vimrc_spi: {{{
" "map      <C-PageDown>       :tabnext<cr>
" "nmap     <C-PageDown>       :tabnext<cr>
" "nnoremap <C-PageDown>       :tabnext<cr>
" "inoremap <C-PageDown> <ESC> :tabnext<cr>i
" map      <C-PageUp>         :tabprevious<cr>
" nmap     <C-PageUp>         :tabprevious<cr>
" nnoremap <C-PageUp>         :tabprevious<cr>
" inoremap <C-PageUp> <ESC>   :tabprevious<cr>i
" 
" map      <C-t>              :tabnew<cr>
" nnoremap <C-t>              :tabnew<cr>
" inoremap <C-t> <ESC>        :tabnew<cr>i
" 
" map      <C-t>              :tabnew<cr>
" nmap     <C-t>              :tabnew<cr>
" imap     <C-t> <ESC>        :tabnew<cr>i
" "map <C-w> :tabclose<cr> "Surtout pas! Quand on commence à jouer avec les fenêtres, ça interfère, mal!
" }}}

" _______________JEANSUILÀ_____________


"2023_07_18__23_02_42 solution plus VIMesque:
nnoremap H gT
nnoremap L gt

" }}}
let salut="coucou8"
endif "@# fin de code désactivé #############################################]]]]

if va9 == "oui" "@# début de code désactivé #############################################[[[[
" 2024_03_28__10_04_16 
"Alt-+- pour retailler les fenêtres: (ne fonctionne pas) {{{
"noremap  <A-+> :vertical resize +5<cr>
"noremap  <A--> :vertical resize -5<cr>
"noremap  <A-kPlus> :vertical resize +5<cr>
"noremap  <A-kMinus> :vertical resize -5<cr>
" 2024_03_28__10_04_16 
" }}}
let salut="coucou9"
endif "@# fin de code désactivé #############################################]]]]

if va10 == "oui" "@# début de code désactivé #############################################[[[[
" Autocmd: {{{
" _______________ENCOURS_______________
" Only do this part when compiled with support for autocommands. {{{
if has("autocmd")
  " When editing a file, always jump to the last known cursor position.
  " Don't do it when the position is invalid or when inside an event handler
  " (happens when dropping a file on gvim).
  autocmd BufReadPost *
    \ if line("'\"") > 0 && line("'\"") <= line("$") |
    \   exe "normal g`\"" |
    \ endif
endif " has("autocmd")

" }}}

" }}}
let salut="coucou10"
endif "@# fin de code désactivé #############################################]]]]

if va11 == "oui" "@# début de code désactivé #############################################[[[[
" F10 - La correction orthographique, c'est très très bien {{{
noremap ,c :w<CR>:!aspell -c %<CR>:e %<CR>
" Pour le paragraphe en cours:
noremap <F10> vip :w! /tmp/tmp_current_paragraph<cr>dip<up>:!aspell -c /tmp/tmp_current_paragraph<cr> :r /tmp/tmp_current_paragraph<cr>
" i<cr>
" }}}
let salut="coucou11"
endif "@# fin de code désactivé #############################################]]]]

if va12 == "oui" "@# début de code désactivé #############################################[[[[
" F9 - La dictée, c'est très très bien aussi, pour le paragraphe en cours: {{{
noremap <F9> vip :w! /tmp/tmp_vim_block<cr> :!espeak -v fr -s 200 -f /tmp/tmp_vim_block &<cr>


" Pareil, en anglais:
noremap <S-F9> vip :w! /tmp/tmp_vim_block<cr> :!espeak -v en -s 200 -f /tmp/tmp_vim_block &<cr>

" }}}
let salut="coucou12"
endif "@# fin de code désactivé #############################################]]]]

if va13 == "oui" "@# début de code désactivé #############################################[[[[
" copié depuis /usr/share/doc/hibernate/examples/hibernate.vim.gz {{{
   augroup filetypedetect
       au BufNewFile,BufRead hibernate.conf set filetype=hibernate
       au BufNewFile,BufRead common.conf set filetype=hibernate
       au BufNewFile,BufRead suspend2.conf set filetype=hibernate
       au BufNewFile,BufRead disk.conf set filetype=hibernate
       au BufNewFile,BufRead ram.conf set filetype=hibernate
       au BufNewFile,BufRead .vimrc set syntax=vim
   augroup END

" }}}
let salut="coucou13"
endif "@# fin de code désactivé #############################################]]]]

if va14 == "oui" "@# début de code désactivé #############################################[[[[
" F7 - horodatage: {{{
"###################################################################################

" mapper F7 avec l'insertion de timestamp, comme dans le bon vieux ultraedit:
"brouillons: {{{
"map <F7> :r !date +\%d/\%m/\%Y\ \%T <Enter>
"07/10/2013 09:51:06
"map <F7> :r !date +\%d_\%m_\%Y__\%T \| sed -e 's/\:/_/g' <Enter>
"23_12_2013__15_48_43
"map <F7> :r !date +\%Y_\%m_\%d__\%T \| sed -e 's/\:/_/g' <Enter>
"2013_12_29__20_29_38

" Je mets la date en ISO 8601, plutôt:
"r !date +\%Y_\%m_\%d__\%T
"2014_01_01__21:55:01
"r !date +\%Y-\%m-\%d_\%T
"2014-01-01_21:55:51
"map <F7> :r !date +\%Y-\%m-\%d_\%T \| sed -e 's/\:/h/' \| sed -e 's/\:/m/' <Enter>
"non, plutôt en ISO underscoré, comme dans le .bashrc:
"map <F7> :r !date +\%Y_\%m_\%d__\%T \| sed -e 's/\:/_/g' <Enter>
"map <F7> :r!date +\%Y_\%m_\%d__\%T \| sed -e 's/\:/h/' \| sed -e 's/\:/m/'<Enter>
"2014_01_03__14h45m36
"2014_01_07__16h34m19
" }}}
noremap  <F7>      :r !date +\%Y_\%m_\%d__\%T \| sed -e 's/\:/_/g'<cr>A<space>
inoremap <F7> <Esc>:r !date +\%Y_\%m_\%d__\%T \| sed -e 's/\:/_/g'<cr>A<space>
"2014_01_14__08_53_38
"###################################################################################
" }}}

" mapper F2 avec la ligne courante à faire tourner en tant que commande vi (:) {{{
" map <F2> <Esc>V<Left><Home>:<S-Ins><Enter>
" => marche pas...
" nnoremap <F2> <Esc>V<Left><Home>:<S-Ins><CR>
" %s/nnoremap/ouaisçaamarché/gc
"
"
" }}}


" F11 - recherche d'étiquettes à faire, en cours, etc. {{{
"mapper F11 avec la recherche de la précédente occurrence de:
"    _______________ENCOURS_______________ 
" ou @# 
" ou _______________TODO__________________
" nnoremap <F11>     :silent!      ?\<_______________ENCOURS_______________\\|@#\\|_______________TODO__________________<cr>
" inoremap <F11>     :silent! <Esc>?\<_______________ENCOURS_______________\\|@#\\|_______________TODO__________________<cr>a
nnoremap <F11>                   ?\<_______________ENCOURS_______________\\|@#\\|_______________TODO__________________\\|_______________JEANSUILÀ_____________\\|\<__.*JEAN.*SUI.*L[AÀ].*__<cr>zO
inoremap <F11>              <Esc>?\<_______________ENCOURS_______________\\|@#\\|_______________TODO__________________\\|_______________JEANSUILÀ_____________\\|\<__.*JEAN.*SUI.*L[AÀ].*__<cr>a

"mapper Shift-F11 avec la même chose, dans l'autre sens:
" nnoremap <S-F11>   :silent!      /\<_______________ENCOURS_______________\\|@#\\|_______________TODO__________________<cr>
" inoremap <S-F11>   :silent! <Esc>/\<_______________ENCOURS_______________\\|@#\\|_______________TODO__________________<cr>a
nnoremap <S-F11>                 /\<_______________ENCOURS_______________\\|@#\\|_______________TODO__________________\\|_______________JEANSUILÀ_____________\\|\<__.*JEAN.*SUI.*L[AÀ].*__<cr>zO
inoremap <S-F11>            <Esc>/\<_______________ENCOURS_______________\\|@#\\|_______________TODO__________________\\|_______________JEANSUILÀ_____________\\|\<__.*JEAN.*SUI.*L[AÀ].*__<cr>a



" Idem, de 2023 dans vimrc_spi: {{{
" "mapper F11 avec la recherche de la précédente occurrence de _______________ENCOURS_______________ et autres étiquettes usuelles
" " nnoremap <F11>          ?\<_______________ENCOURS_______________\\|@#\\|TODO\\|FIXME<cr>
" " inoremap <F11>     <Esc>?\<_______________ENCOURS_______________\\|@#\\|TODO\\|FIXME<cr>a
" nnoremap <F11>          ?\<_______________ENCOURS_______________\\|@#\\|_______________TODO__________________\\|_______________JEANSUILÀ_____________<cr>zO
" inoremap <F11>     <Esc>?\<_______________ENCOURS_______________\\|@#\\|_______________TODO__________________\\|_______________JEANSUILÀ_____________<cr>a
" 
" 
" "mapper Shift-F11 avec la même chose, dans l'autre sens:
" " nnoremap <S-F11>        /\<_______________ENCOURS_______________\\|@#\\|TODO\\|FIXME<cr>
" " inoremap <S-F11>   <Esc>/\<_______________ENCOURS_______________\\|@#\\|TODO\\|FIXME<cr>a
" nnoremap <S-F11>      \<_______________ENCOURS_______________\\|@#\\|_______________TODO__________________\\|_______________JEANSUILÀ_____________<cr>zO
" inoremap <S-F11> <Esc>\<_______________ENCOURS_______________\\|@#\\|_______________TODO__________________\\|_______________JEANSUILÀ_____________<cr>a
" 
" 
" ""mapper Ctrl-F11 avec la recherche de la précédente occurrence de @#
" "nnoremap <C-F11>        ?@#<cr>
" "inoremap <C-F11>   <Esc>?@#<cr>a
" "
" ""mapper Ctrl-Shift-F11 avec la même chose, dans l'autre sens:
" "nnoremap <C-S-F11>        /@#<cr>
" "inoremap <C-S-F11>   <Esc>/@#<cr>a
" " => inutile, F11 fait ça tout seul
" " => plutôt, on va mapper pour chercher les TODO et FIXME (F11 est plus confortable pour seulement les encours et @#)
" nnoremap <C-F11>        ?@#\\|TODO\\|FIXME<cr>
" inoremap <C-F11>   <Esc>?@#\\|TODO\\|FIXME<cr>a
" " et dans l'autre sens:
" nnoremap <C-S-F11>      /@#\\|TODO\\|FIXME<cr>
" inoremap <C-S-F11> <Esc>/@#\\|TODO\\|FIXME<cr>a
" 
" 
" "mapper Alt-F11 avec 32 fois souligner, pour annuler un tag _______________ENCOURS_______________truc ou _______________TODO__________________machin, juste après avoir fait un F11 pour y arriver:
" nnoremap <A-F11>        32r_<Esc>
" 
" " }}}



" Aller au tag actue*l*, aller *L*à: mapper Ctrl-L pour aller *L*à:
nnoremap   <C-l>   :silent!       /\<__.*JEAN.*SUI.*L[AÀ].*__<cr>zO$
inoremap   <C-l>   :silent! <Esc> /\<__.*JEAN.*SUI.*L[AÀ].*__<cr>$a

" avec Maj enfoncée, dans *L*'autre sens:
nnoremap  <S-C-l>   :silent!       ?\<__.*JEAN.*SUI.*L[AÀ].*__<cr>zO$
inoremap  <S-C-l>   :silent! <Esc> ?\<__.*JEAN.*SUI.*L[AÀ].*__<cr>$a
" _______________TODO__________________ ajouter le message:
" echo "=> on est Làààà"<cr>
" nnoremap   <C-l>   :silent!      ?\<___?JEAN.*SUI.*L[AÀ]?___?<cr>zO :ec "=> on est Là"
  " \_ le echo, ech, echom ne fonctionne point du tout.

" Idem, de 2023 dans vimrc_spi: {{{
" nnoremap <C-L>      \<_______________JEANSUILÀ_____________<cr>zO
" inoremap <C-L> <Esc>\<_______________JEANSUILÀ_____________<cr>a
" }}}
" }}}


" F12 - dernière macro invoquée: {{{
"mapper F12 avec la dernière macro:
noremap  <F12>      @@
inoremap <F12> <ESC>@@a
" }}}


" ! - Highlighter^Wsurligner toutes les occurrences du mot sous le curseur: {{{
"http://vim.wikia.com/wiki/Auto_highlight_current_word_when_idle {{{
"
"created 2003 · complexity basic · author mosh · version 6.0
"Vim can easily highlight all search pattern matches and search for the current word (the word under the cursor). This tip shows how to automatically highlight all occurrences of the current word without searching. That can be useful when examining unfamiliar source code: just move the cursor to a variable, and all occurrences of the variable will be highlighted.
"
"
" Highlight all instances of word under cursor, when idle.
" Useful when studying strange source code.
" Type z/ to toggle highlighting on/off.
function! AutoHighlightToggle()
  let @/ = ''
  if exists('#auto_highlight')
    au! auto_highlight
    augroup! auto_highlight
    setl updatetime=4000
    echo 'Highlight current word: off'
    return 0
  else
    augroup auto_highlight
      au!
      au CursorHold * let @/ = '\V\<'.escape(expand('<cword>'), '\').'\>'
    augroup end
    setl updatetime=500
    echo 'Highlight current word: ON'
    return 1
  endif
endfunction
" on fait ça avec... ! (pas loin de *)
noremap ! :if AutoHighlightToggle()<Bar>set hls<Bar>endif<CR>
" non, plutôt avec... µ (maj - *)
" => marche pas
"map <S-*> :if AutoHighlightToggle()<Bar>set hls<Bar>endif<CR>
" ni <C-*> ni <S-C-*> ni <S-*> ... donc retour au !

" }}}

" "Autre solution pour highlighter toutes les occurrences du mot sous le curseur: (bof, commenté) {{{
" "https://vi.stackexchange.com/questions/17493/how-to-highlight-match-but-not-search-the-word-under-cursor
"
" "You indicate that you were trying to get the mapping to work with <cword>. Though the answer you accepted is just fine I'm surprised no one answered with a corrected use of that.
" "Normally the string on the RHS of a mapping is executed literally as an Ex command. No pre- expansion/evaluation/processing of the string occurs. So :match in
" "nnoremap <F5> :match StatusLineTerm /.expand(<cword>)./
" "(along the lines of your attempt) will try to literally match the string '.expand(<cword>).'
" "If we want the string or some portion of it to be expanded/evaluated we have to do it ourselves by passing it to the :exec command as an expression:
" "exec 'match StatusLineTerm /' . expand('<cword>') . '/'
" "Note that we surround with quotes any parts that we want to use literally and append them with .. The rest is evaluated. (Also note that <cword> is a special string and needs to be quoted before being passed to expand().)
" "So, the mapping you were originally going for is:
" "nnoremap <F5> :exec 'match StatusLineTerm /' . expand('<cword>') . '/'<CR>
"
" " on fait ça avec... ! (pas loin de *)
" " nnoremap ! :windo exec 'match StatusLineTerm /' . expand('<cword>') . '/'<CR>
" " => fonctionne pas
" " Autre essai:
" " nnoremap ! :let tt=expand('<cword>') windo exec 'match StatusLineTerm /' . tt . '/'<CR>
"
" " Pas mieux, encore autre chose, avec une fonction:
" function! HighlightCurrentWord(text)
"   windo exec 'match StatusLineTerm /' . a:text . '/'
" endfunction
" nnoremap ! :call HighlightCurrentWord(expand('<cWORD>'))<cr>
"
" }}}

" "Encore une autre solution pour highlighter toutes les occurrences du mot sous le curseur: {{{

" Définition des couleurs:
" highlight HighlightCurrentWord guibg=#463626 ctermbg=94
" \_ moche
" highlight HighlightCurrentWord guibg=#463626 ctermbg=0
" \_ nulach
" => retour au départ
highlight HighlightCurrentWord guibg=#463626 ctermbg=9 ctermfg=0

augroup highlight_current_word
    au!
    au CursorMoved * call Highlight_current_word()
augroup END

" Il faut pouvoir toggler cela, faisons une variable:
let g:highlight_current_word = 1

function! Highlight_current_word()
  let exclude_ft = ["nerdtree", "fugitive", "fzf"]
    if index(exclude_ft, &filetype) == -1
      if g:highlight_current_word == 1
        try
            call matchdelete(481516)
        catch
        endtry
        let current_word = escape(expand("<cword>"), "\\/[]*~")
        call matchadd("HighlightCurrentWord", "\\<" . current_word ."\\>", 0, 481516)
      endif
    endif
endfunction

function! Toggle_highlightCurrentWord()
  if g:highlight_current_word == 1
    let g:highlight_current_word = 0
        try
            call matchdelete(481516)
        catch
        endtry
    echom "Current word not highlighted"
  else
    let g:highlight_current_word = 1
    call Highlight_current_word() 
    echom "Current word highlighted"
  endif
endfunction

" Pour basculer (toggler)ça, faisons avec Ctrl-F2, par exemple:
noremap <C-F2> :call Toggle_highlightCurrentWord()<cr>

" }}}
" }}}


"quelques conseils de http://vim.wikia.com/wiki/Using_standard_editor_shortcuts_in_Vim; fait un peu (beaucoup!) de ménage, quand même: {{{

"set smartindent
set tabstop=4
set shiftwidth=4
"set expandtab

"set mouse=a
"set nu

"noremap <C-a> GVgg
"noremap <C-n> :enew
"noremap <C-o> :e . <Enter>
"noremap <C-s> :w <Enter>
"noremap <C-c> y
"noremap <C-v> p
"noremap <C-x> d
"noremap <C-z> u
"noremap <C-t> :tabnew <Enter>
"noremap <C-i> >>
"noremap <C-w> :close <Enter>
"noremap <C-W> :q! <Enter>
"noremap <C-f> /
"noremap <C-h> :%s/
"noremap <S-t> vat
"noremap <S-T> vit
"noremap <S-{> vi{
"noremap <S-(> vi(
"noremap <S-[> vi[
" }}}

let salut="coucou14"
endif "@# fin de code désactivé #############################################]]]]

if va15 == "oui" "@# début de code désactivé #############################################[[[[

" Raccourcis pour quitter et sauver comme tout le monde: {{{
" Pour sauvegarder "comme tout le monde" avec un Ctrl-S
nnoremap <c-s>      :w<CR>
inoremap <c-s> <Esc>:w<CR>a
onoremap <c-s> <Esc>:w<CR><Insert><Insert>
" Dans tmux, voilà ce que donne Ctrl-S avec Ctrl-V avant: 
nnoremap <>       :w<CR>
inoremap <>  <Esc>:w<CR>a
onoremap <>  <Esc>:w<CR><Insert><Insert>
" => ça ne fonctionne point...
nnoremap <> :w<CR>
inoremap <> <Esc>:w<CR>a
" => ça ne fonctionne point non plus...


" Pour quitter "comme tout le monde" avec un Ctrl-Q, poil au...
if empty($TMUX)
    nnoremap <c-q>      :q<CR>
    inoremap <c-q> <Esc>:q<CR>
    nnoremap <>       :q<CR>
    inoremap <>  <Esc>:q<CR>
" => ça ne fonctionne point non plus dans tmux...
else
    nnoremap          :q<CR>
    inoremap          :q<CR>
endif

" Pour tout sélectionner "comme tout le monde" avec un Ctrl-A:
if empty($TMUX)
    nnoremap <c-a>      :silent! mzggVG<Esc>`z
    inoremap <c-a> <Esc>mzggVG<Esc>`za
    nnoremap <>       :silent! mzggVG<Esc>`z
    inoremap <>  <Esc>mzggVG<Esc>`za
" => TODO ça ne donne pas toujours satisfaction: @#à peaufiner, au besoin
endif


" }}}


"Je me fais des raccourcis pour les Fn:
"noremap <F1>
"noremap <F2>
"noremap <F3>
"noremap <F4>


" Pour faire tourner le paragraphe ou le féchier courant: {{{

" TODO il y a beaucoup de redondances: factoriser, faire des fonctions. Penser à quelque chose de générique, un genre de wrapper peut-être.
" Brouillon d'idées:{{{

function! SaveCurrentLineToTmpCodeFile()
  " ...
endfunction

function! SaveCurrentParagraphToTmpCodeFile()
  " ...
endfunction

function! RunCurrentFile()
  " Exécute le fichier qu'on est en train d'éditer
  " echo "Le fichier qu'on est en train d'éditer est" @%
  " call DebugPauseWaitForKeyPress()
  " echo "Son chemin est" expand('%:p:h')
  " call DebugPauseWaitForKeyPress()
  call RunFile( expand('%:p'))
endfunction


function! RunFile(file)
  " Exécute le fichier passé en argument
  let full_file_path = shellescape(expand(a:file))
  echo "On va exécuter le fichier" full_file_path
  " call DebugPauseWaitForKeyPress()
  execute '!'.full_file_path
  " call DebugPauseWaitForKeyPress()
  " echom "Voilà, c'est fait."
endfunction


function! RunTmpCodeFile()
  try
    execute 'wincmd ' . a:direction
    " ...
  catch
    echohl ErrorMsg | echo 'E11: Invalid in command-line window; <CR> executes, CTRL-C quits: wincmd k' | echohl None
  endtry
endfunction

function! PasteOutputFromRanTmpCodeFile()
  " ...
endfunction



" }}}


"pour sauver et faire tourner le fichier courant par rebol^W n'importe quoi, pourvu que le chieboum soit bien fait:
"to save and run the current file by rebol^W interpreter^W anything, as long as the shebang is correct:
"noremap <F5> :w<cr> :!rebol -qs %<cr>
" *** ENLEVÉ POUR VIMSPECTOR( ***
" noremap  <F5>      :w<cr> :!./%<cr>
noremap  <F5>      :call RunCurrentFile()<cr>
inoremap <F5> <esc>:w<cr> :!./%<cr>a
" *** ENLEVÉ POUR VIMSPECTOR) ***
"Utile pour un script Rebol existant, qu'on n'a nulle intention de modifier, et qui n'a aucun chieboum:
noremap <s-F5>     :!rebol -qs %<cr>


""pour faire tourner la sélection courante par rebol:
""to interpret the current visual selection by rebol interpreter:
"map <F6> :w! tmp_vim_block<cr> :!echo "rebol []" > tmp_vim_block.rr && cat tmp_vim_block.rr tmp_vim_block > tmp_vim_block.r && rebol -qs tmp_vim_block.r && rm tmp_vim_block.rr tmp_vim_block.r tmp_vim_block<cr>

"mieux:
"even better:

"pour faire tourner le paragraphe courant par rebol:
"to interpret the current paragraph by rebol interpreter:
noremap <F6>        mzvip :w! /tmp/tmp_vim_block<cr>:!echo "rebol []" > /tmp/tmp_vim_block.rr && echo 'prin rejoin [newline "=>"         {;==== Rebol code evaluation output: ========= }] ' >> /tmp/tmp_vim_block.rr && echo 'print "{{{"' >> /tmp/tmp_vim_block.rr && cat /tmp/tmp_vim_block.rr /tmp/tmp_vim_block > /tmp/tmp_vim_block.r && echo 'prin {;==========================================}' >> /tmp/tmp_vim_block.r && echo 'print " }}}" wait 0.1 print rejoin [newline {... Entrée pour continuer}] input' >> /tmp/tmp_vim_block.r && rebol -qs /tmp/tmp_vim_block.r<cr>`z
inoremap <F6> <ESC> mzvip :w! /tmp/tmp_vim_block<cr>:!echo "rebol []" > /tmp/tmp_vim_block.rr && echo 'prin rejoin [newline "=>"         {;==== Rebol code evaluation output: ========= }] ' >> /tmp/tmp_vim_block.rr && echo 'print "{{{"' >> /tmp/tmp_vim_block.rr && cat /tmp/tmp_vim_block.rr /tmp/tmp_vim_block > /tmp/tmp_vim_block.r && echo 'prin {;==========================================}' >> /tmp/tmp_vim_block.r && echo 'print " }}}" wait 0.1 print rejoin [newline {... Entrée pour continuer}] input' >> /tmp/tmp_vim_block.r && rebol -qs /tmp/tmp_vim_block.r<cr>`za
"(des vieilleries:) {{{
" noremap  <F6>       mzvip :w! /tmp/tmp_vim_block<cr>:!echo "rebol []" > /tmp/tmp_vim_block.rr && echo 'prin rejoin [newline "=>" newline {;======== code evaluation output: ========= }] ' >> /tmp/tmp_vim_block.rr && echo 'print "{{{"' >> /tmp/tmp_vim_block.rr && cat /tmp/tmp_vim_block.rr /tmp/tmp_vim_block > /tmp/tmp_vim_block.r && echo 'prin {;==========================================}' >> /tmp/tmp_vim_block.r && echo 'print " }}}" wait 0.1 print rejoin [newline {... Entrée pour continuer}] input' >> /tmp/tmp_vim_block.r && rebol -qs /tmp/tmp_vim_block.r<cr>`z
"map <F6> vip :w! tmp_vim_block<cr> :!echo "rebol []" > tmp_vim_block.rr && cat tmp_vim_block.rr tmp_vim_block > tmp_vim_block.r && rebol -qs tmp_vim_block.r && rm tmp_vim_block.rr tmp_vim_block.r tmp_vim_block<cr>
"map <F6> vip :w! /tmp/tmp_vim_block<cr>:!echo "rebol []" > /tmp/tmp_vim_block.rr && echo 'print rejoin [newline "=>" newline {;======== code evaluation output: =========} ]' >> /tmp/tmp_vim_block.rr  && cat /tmp/tmp_vim_block.rr /tmp/tmp_vim_block > /tmp/tmp_vim_block.r && echo "print {;==========================================} wait 0.5 print rejoin [newline newline newline {Entrée pour continuer}] input" >> /tmp/tmp_vim_block.r && rebol -qs /tmp/tmp_vim_block.r<cr>}k
"map <F6> vip :w! /tmp/tmp_vim_block<cr>:!echo "rebol []" > /tmp/tmp_vim_block.rr && echo 'prin rejoin [newline "=>" newline {;======== code evaluation output: ========= } ]' >> /tmp/tmp_vim_block.rr && echo " ; {{{" >> /tmp/tmp_vim_block.rr  && cat /tmp/tmp_vim_block.rr /tmp/tmp_vim_block > /tmp/tmp_vim_block.r && echo "prin {;==========================================}  >> /tmp/tmp_vim_block.r && echo '}}}"' >> /tmp/tmp_vim_block.r && echo "wait 0.5 print rejoin [newline newline newline {Entrée pour continuer}] input" >> /tmp/tmp_vim_block.r && rebol -qs /tmp/tmp_vim_block.r"<cr>}k
"KK! map <F6> vip :w! /tmp/tmp_vim_block<cr>:!echo "rebol []" > /tmp/tmp_vim_block.rr && \ echo 'prin rejoin [newline "=>" newline {;======== code evaluation output: ========= } ]' >> /tmp/tmp_vim_block.rr && echo "{{{" >> /tmp/tmp_vim_block.rr  && cat /tmp/tmp_vim_block.rr /tmp/tmp_vim_block > /tmp/tmp_vim_block.r && echo "prin {;==========================================} > /tmp/tmp_vim_block.r && echo 'print "}}}"' > /tmp/tmp_vim_block.r print rejoin [newline newline newline {Entrée pour continuer}] input" >> /tmp/tmp_vim_block.r && rebol -qs /tmp/tmp_vim_block.r<cr>}k
"map <F6> vip :w! /tmp/tmp_vim_block<cr>:!echo "rebol []" > /tmp/tmp_vim_block.rr && echo 'prin rejoin [newline "=>" newline {;======== code evaluation output: ========= } ]' >> /tmp/tmp_vim_block.rr && echo "{{{" >> /tmp/tmp_vim_block.rr  && cat /tmp/tmp_vim_block.rr /tmp/tmp_vim_block > /tmp/tmp_vim_block.r && echo "prin {;==========================================} && echo "}}}" wait 0.5 print rejoin [newline newline newline {Entrée pour continuer}] input" >> /tmp/tmp_vim_block.r && rebol -qs /tmp/tmp_vim_block.r<cr>}k
"map <F6> vip :w! /tmp/tmp_vim_block<cr>:!echo "rebol []" > /tmp/tmp_vim_block.rr && echo 'print rejoin [newline "=>" newline {;======== code evaluation output: =========} ]' >> /tmp/tmp_vim_block.rr  && cat /tmp/tmp_vim_block.rr /tmp/tmp_vim_block > /tmp/tmp_vim_block.r && echo "print {;==========================================} wait 0.5 print rejoin [newline newline newline {Entrée pour continuer}] input" >> /tmp/tmp_vim_block.r && rebol -qs /tmp/tmp_vim_block.r<cr>}k
"map <F6> vip :w! /tmp/tmp_vim_block<cr>:!echo "rebol []" > /tmp/tmp_vim_block.rr && echo 'prin rejoin [newline "=>" newline {;======== code evaluation output: ========= }] ' >> /tmp/tmp_vim_block.rr && echo 'print "{{{"' >> /tmp/tmp_vim_block.rr && cat /tmp/tmp_vim_block.rr /tmp/tmp_vim_block > /tmp/tmp_vim_block.r && echo 'prin {;==========================================}' >> /tmp/tmp_vim_block.r && echo 'print " }}}" wait 0.1 print rejoin [newline newline {... Entrée pour continuer}] input' >> /tmp/tmp_vim_block.r && rebol -qs /tmp/tmp_vim_block.r<cr>}k
" }}}

" Pour faire à la mode, et faire du javascript (à reculons...), faire tourner le paragraphe courant par javascript:
nnoremap <s-F6>       mzvip :w! /tmp/tmp_vim_block<cr>:! js /tmp/tmp_vim_block && echo "Entrée pour poursuivre..." && read<cr>`z
inoremap <s-F6> <ESC> mzvip :w! /tmp/tmp_vim_block<cr>:! js /tmp/tmp_vim_block && echo "Entrée pour poursuivre..." && read<cr>`za


" Pour faire tourner le paragraphe courant par python3:
nnoremap <c-F6>       mzvip :w! /tmp/tmp_vim_block<cr>:!echo 'print("\n=>\n\# ======== Python code evaluation output: ========= {{{")' > /tmp/tmp_vim_block.pyy && cat /tmp/tmp_vim_block.pyy /tmp/tmp_vim_block > /tmp/tmp_vim_block.py && echo 'print("\# ========================================== }}}\n... Entrée pour continuer")' >> /tmp/tmp_vim_block.py && echo 'input()' >> /tmp/tmp_vim_block.py && python3 /tmp/tmp_vim_block.py\|\|read<cr>`z
inoremap <c-F6> <ESC> mzvip :w! /tmp/tmp_vim_block<cr>:!echo 'print("\n=>\n\# ======== Python code evaluation output: ========= {{{")' > /tmp/tmp_vim_block.pyy && cat /tmp/tmp_vim_block.pyy /tmp/tmp_vim_block > /tmp/tmp_vim_block.py && echo 'print("\# ========================================== }}}\n... Entrée pour continuer")' >> /tmp/tmp_vim_block.py && echo 'input()' >> /tmp/tmp_vim_block.py && python3 /tmp/tmp_vim_block.py\|\|read<cr>`za

"Pour faire tourner le paragraphe courant par un compilateur C:
" FIXME logique des raccourcis pourrie. Plutôt demander quel langage au début, en gardant le même pour faire, par exemple: F6 P (pour python) Entrée, et après F6 Entrée Entrée. À réfléchir, puis refaire les raccourcis de manière logique, en faisant tourner ligne, paragraphe, en collant ou pas la sortie après.
noremap  <s-c-F6>       mzvip :w! /tmp/tmp_vim_block.c<cr>: !gcc -g -Wall -std=c99 /tmp/tmp_vim_block.c -o /tmp/tmp_vim_block && /tmp/tmp_vim_block > /tmp/tmp_vim_block.ccc   ; echo "... Entrée pour continuer" && read<cr>`z
inoremap <s-c-F6> <ESC> mzvip :w! /tmp/tmp_vim_block.c<cr>: !gcc -g -Wall -std=c99 /tmp/tmp_vim_block.c -o /tmp/tmp_vim_block && /tmp/tmp_vim_block ; echo "... Entrée pour continuer" && read<cr>`za


" pour faire tourner le paragraphe courant par bash:
noremap  <F8>          mzvip :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && echo "... Entrée pour continuer" && read <cr>`z
inoremap <F8>     <esc>mzvip :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && echo "... Entrée pour continuer" && read <cr>`za

" pour faire tourner le paragraphe courant par bash et coller la sortie après:
" noremap  <F8>          mzvip :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && read <cr>`z
" inoremap <F8>     <esc>mzvip :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && read <cr>`za
" nnoremap <C-F8>        mzvip:w! /tmp/tmp_vim_block<cr> A<cr># => {{{<esc> :exec 'r!bash /tmp/tmp_vim_block'<cr><cr>i<cr># }}}<cr><cr><esc>`z
nnoremap <C-F8>    mzyip:redir! > /tmp/tmp_vim_block<cr>:echo @0<cr>:redir END<cr>}A<cr># => {{{<cr><cr># }}}<cr><esc>kk:exec 'r!bash /tmp/tmp_vim_block'<cr>A<cr><esc>`z}j0
" CETTE LIGNE CI-DESSUS FONCTIONNE TRÈS-TRÈS BIEN (enfin, presque; quand il y a des trucs interactifs, ça n'a pas l'air de trop le faire): TODO factoriser tout ça, et faire appel au code factorisé (fonction? commande?)

inoremap <C-F8>   <esc>mzvip :w! /tmp/tmp_vim_block<cr>A<cr># => {{{<esc>:exec 'r!bash /tmp/tmp_vim_block'<cr><cr>a# }}}<cr><cr><esc>`z<cr>a


" pour faire tourner la ligne courante par bash:
noremap  <S-F8>        mzV   :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && read <cr>`z
inoremap <S-F8>   <esc>mzV   :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && read <cr>`za

" pour faire tourner la ligne courante par bash et coller la sortie après:
nnoremap <C-S-F8>      mzV   :w! /tmp/tmp_vim_block<cr>} o<cr># => {{{<esc> :exec 'r!bash /tmp/tmp_vim_block'<cr><cr>a<cr># }}}<cr><esc>`z
inoremap <C-S-F8> <esc>mzV   :w! /tmp/tmp_vim_block<cr>} o<cr># => {{{<esc> :exec 'r!bash /tmp/tmp_vim_block'<cr><cr>a<cr># }}}<cr><esc>`za




" Flûte, F8 ne semble pas compris dans tmux:
" Voilà ce que donne le C-V:
" [19~

" Pareil, mais pour dans tmux:
" pour faire tourner le paragraphe courant par bash:
noremap  <[19~>      mzvip :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && read <cr>`z
inoremap <[19~> <esc>mzvip :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && read <cr>`za

" Flûte, S-F8 ne semble pas non plus compris dans tmux:
" Voilà ce que donne le C-V:
" [19;2~
" pour faire tourner la ligne courante par bash:
noremap  <[19;2~>      mzV :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && read <cr>`z
inoremap <[19;2~> <esc>mzV :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && read <cr>`za



noremap <[19;2~>      mzV :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && read <cr>`z
noremap <[19;2~> <esc>mzV :w! /tmp/tmp_vim_block<cr> :!bash /tmp/tmp_vim_block && read <cr>`zi

" }}}
let salut="coucou15"
endif "@# fin de code désactivé #############################################]]]]


if va16 == "oui" "@# début de code désactivé #############################################[[[[

"Et un raccourci pour sélectionner un Paragraphe: {{{
noremap <C-S-p> vip
"(enlevé <S-p> qui fait paste avant)
"Un autre raccourci, qui utilise le symbole § (touche !):
noremap  § vip
"inoremap <C-§> <esc>vipi "     => marche pas...
" }}}


" pour ouvrir l'URL (la phrase) sous le curseur par le navigateur: {{{
"noremap  <C-F8>       mzvis :w! /tmp/tmp_vim_block<cr> :!$BROWSER /tmp/tmp_vim_block && read <cr>`z
"inoremap <C-F8> <esc> mzvis :w! /tmp/tmp_vim_block<cr> :!$BROWSER /tmp/tmp_vim_block && read <cr>`za
"noremap  <C-F8>       mzvis :w! /tmp/tmp_vim_block<cr> :!$BROWSER /tmp/tmp_vim_block && read <cr>`z
"inoremap <C-F8> <esc> mzvis :w! /tmp/tmp_vim_block<cr> :!$BROWSER /tmp/tmp_vim_block && read <cr>`za
" Meuh non, bien plus simple: simplement gx et ça ouvre le navigateur défini ainsi:
let g:netrw_browsex_viewer= "$BROWSER"
"let g:netrw_browsex_viewer= "xdg-open"
" }}}



" Pour sélectionner divers bidules par des double (non, déjà fait) {{{
"<LeftMouse>     - Left mouse button press
"<RightMouse>    - Right mouse button press
"<MiddleMouse>   - Middle mouse button press
"<LeftRelease>   - Left mouse button release
"<RightRelease>  - Right mouse button release
"<MiddleRelease> - Middle mouse button release
"<LeftDrag>      - Mouse drag while Left mouse button is pressed
"<RightDrag>     - Mouse drag while Right mouse button is pressed
"<MiddleDrag>    - Mouse drag while Middle mouse button is pressed
"<2-LeftMouse>   - Left mouse button double-click
"<2-RightMouse>  - Right mouse button double-click
"<3-LeftMouse>   - Left mouse button triple-click
"<3-RightMouse>  - Right mouse button triple-click
"<4-LeftMouse>   - Left mouse button quadruple-click
"<4-RightMouse>  - Right mouse button quadruple-click
"<X1Mouse>       - X1 button press
"<X2Mouse>       - X2 button press
"<X1Release>     - X1 button release
"<X2Release>     - X2 button release
"<X1Drag>        - Mouse drag while X1 button is pressed
"<X2Drag>        - Mouse drag while X2 button is pressed
" }}}

"  - Right mouse button triple-click => sélectionne déjà une ligne, je laisse.

"pour sélectionner une phraSe:
nnoremap <3-LeftMouse> vis

"pour sélectionner un Paragraphe (comme ctrl-P):
nnoremap <4-LeftMouse> vip


" Un raccourci similaire à *, mais avec shift, ça fait µ, qui ouvre une autre fenêtre puis fait un *: {{{
" => très utile pour les tags
" => mince, pas pu faire :map <S-*> :split <cr>*
"                  ni:   :map <µ> :split <cr>*
"donc je fais avec F3, et vers le haut, c'est plus commode, avec #:
noremap <F3>      :split<cr>#
" Pareil, en mode insertion aussi:
inoremap <F3> <Esc>:split<cr>#a
"Pareil, en faisant une division verticale:
noremap <S-F3> :vsplit<cr>#
"=> ne fonctionne pas... 2023_08_04__11_54_09 => si, ça refonctionne (hors screen...)
" }}}

"Réticule; {{{
""Pour avoir un réticule amusant (et utile):
"set cursorcolumn
"set cursorline
"
""Pour mettre du grisé dans les 2 axes du réticule (car le soulignement de l'axe horizontal gêne quelque peu la lecture):
"hi CursorLine cterm=NONE
""hi CursorLine ctermbg=Cyan
"hi CursorLine ctermbg=Grey
""hi CursorColumn ctermbg=Cyan
"
"=> En fait, dès qu'on est dans un ssh quelconque, ou une console, ce réticule est giga-chiasseur: zou, je le zappe.

"Voici une version plus discrète, et basculable par <jeader>r (pour Réticule)
" hi CursorColumn cterm=NONE ctermbg=Grey guibg=Grey40
" hi CursorColumn cterm=underline ctermfg=11
hi CursorLine   cterm=NONE ctermbg=Grey
hi link CursorColumn CursorLine

" nnoremap <Leader>r        :set cursorline! cursorcolumn!<cr>
" inoremap <Leader>r <Esc>mz:set cursorline! cursorcolumn!<cr>`zi
" Plutôt avec F2 (car le délai après Leader est bien trop court (dû à la modif pour avoir kj qui fasse Esc...)):
nnoremap <S-F2>             :Windo set cursorline! cursorcolumn!<cr>
inoremap <S-F2>      <Esc>mz:Windo set cursorline! cursorcolumn!<cr>`za

nnoremap <F2>             :set cursorline! cursorcolumn!<cr>
inoremap <F2>      <Esc>mz:set cursorline! cursorcolumn!<cr>`za

" " Idem, de 2023 dans vimrc_spi: {{{
" " Un mapping pour switcher le réticule:
" noremap  <F2>        :set cursorcolumn!<bar>set cursorline!<CR>
" inoremap <F2> <Esc>mz:set cursorcolumn!<bar>set cursorline!<CR>`za
" 
" }}}
" }}}

" Pour scroller plus confortablement, mappons Fn+Ctrl+flèches avec C-D et C-U: {{{
"noremap <C-S-PageDown> <C-D>
"noremap <C-S-PageUp> <C-U>
"inoremap <C-S-PageDown> <p>
"inoremap <C-S-PageUp> <p>
"  2018_10_13__11_44_06 => ne fonctionne pas.
" }}}

" Contenu de ~/dev/postgresql/src/tools/editors/vim.samples: {{{
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" These settings are appropriate for editing PostgreSQL code with vim
" You would copy this into your .vimrc or equivalent
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if match(getcwd(), "/pgsql") >=0 ||  match(getcwd(), "/postgresql") >= 0
      set cinoptions=(0
      set tabstop=4
      set shiftwidth=4
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" }}}

" Incrémenter et décrémenter un nombre sous le curseur: {{{

" normalement, c'est <C-A>,<C-X>, mais dans un screen c'est peu aisé:
"Mieux, A augmente et Q (juste en-dessous sur mon AZERTY)" diminue, avec Alt:
nnoremap <A-a> <C-a>
nnoremap <A-q> <C-x>
inoremap <A-a> <C-a>
inoremap <A-q> <C-x>

" Ça ne fonctionne point ainsi dans un screen: je tente de redéfinir les choses en guettant ce qui se passe dans un:
" sed -n l
nnoremap á      <C-a>
nnoremap ñ      <C-x>
inoremap á <Esc><C-a>a
inoremap ñ <Esc><C-x>a

" Idem, de 2023 dans vimrc_spi: {{{
" Sur Suse:
nnoremap a <C-a>
nnoremap q <C-x>
inoremap a <C-a>
inoremap q <C-x>

" 32

"}}}
" Bac à sable: 32

" }}}


" Mes macros pratiques, que je conserve: {{{
" @S Soulignements => pour mettre 32 fois _ sur une ligne de type
" _____________________________________QUELQUECHOSE
let @s = '[1~32r_[1~'

" Une tentative ratée pour ne souligner que les 32 premiers caractères du mot (et non de la ligne) courant:
" nnoremap à b32r_

" }}}



" Pour fermer les ([{"' automagiquement:
inoremap ( ()<Left>
inoremap [ []<Left>
inoremap { {}<Left>
"inoremap " ""<Left>
" " était (annulé, ça met souvent le ouaï ...) => de nouveau annulé
"inoremap ' ''<Left> (annulé, ça met le ouaï dans l'apostrophage...)
inoremap < <><Left>


""2020_11_12__15_59_26 => J'annule tout ça: {{{
""
""" 2020_10_13__11_41_18
""" En lisant ça: https://realpython.com/vim-and-python-a-match-made-in-heaven/
""" Pour Vundle:
"""set nocompatible              " required  <= inutile, c'est déjà mentionné plus haut
""filetype off                  " required
"""
""" set the runtime path to include Vundle and initialize
""set rtp+=~/.vim/bundle/Vundle.vim
""call vundle#begin()
"""
""" alternatively, pass a path where Vundle should install plugins
"""call vundle#begin('~/some/path/here')
"""
""" let Vundle manage Vundle, required
""Plugin 'gmarik/Vundle.vim'
"""
""" add all your plugins here (note older versions of Vundle
""" used Bundle instead of Plugin)
"""
""Plugin 'tmhedberg/SimpylFold'
""Plugin 'vim-scripts/indentpython.vim'
""Plugin 'scrooloose/nerdtree'
""" ...
""" All of your Plugins must be added before the following line
""call vundle#end()            " required
""filetype plugin indent on    " required
" }}}



"Pro Tip #5: Try this if you want to see the docstrings for folded code:
let g:SimpylFold_docstring_preview=1

"To add the proper PEP 8 indentation, add the following to your .vimrc:
"au BufNewFile,BufRead *.py set tabstop=4 softtabstop=4 shiftwidth=4 textwidth=79 expandtab autoindent fileformat=unix
" textwidth=79 me GONFLE gravement.
au BufNewFile,BufRead *.py set tabstop=4 softtabstop=4 shiftwidth=4 expandtab autoindent fileformat=unix
"
"For full stack development, you can use another au command for each filetype:
au BufNewFile,BufRead *.js,*.html,*.css set tabstop=2 softtabstop=2 shiftwidth=2

"Pour les fichiers shell:
au BufNewFile,BufRead *.sh set tabstop=2 softtabstop=2 shiftwidth=2 expandtab autoindent

"Pour les fichiers cobol:
" au BufNewFile,BufRead *.cbl set tabstop=4 softtabstop=4 shiftwidth=4 expandtab autoindent colorcolumn=7,72
" Mieux, pour ajouter des arrêts de tabulations; mais ça implique de devoir convertir les tabulations, amande au nez...
au BufNewFile,BufRead *.cbl set et vts=6,1,4,60 noexpandtab autoindent colorcolumn=7,8,12,72 
au BufNewFile,BufRead *.cbl :highlight ColorColumn ctermbg=7

"Flagging Unnecessary Whitespace
"You also want to avoid extraneous whitespace. You can have VIM flag that for you so that it’s easy to spot and then remove:
"au BufRead,BufNewFile *.py,*.pyw,*.c,*.h match BadWhitespace /\s\+$/




"Auto-Complete

"The best plugin for Python auto-complete is YouCompleteMe. Again, use Vundle to install:
"Bundle 'Valloric/YouCompleteMe'
    "=> bof, non, mon autocomplétion est déjà Parfaite.


"""python with virtualenv support
""py << EOF
""import os
""import sys
""if 'VIRTUAL_ENV' in os.environ:
""  project_base_dir = os.environ['VIRTUAL_ENV']
""  activate_this = os.path.join(project_base_dir, 'bin/activate_this.py')
""  execfile(activate_this, dict(__file__=activate_this))
""EOF
"" => ? Marche pas.


" Un moignon de plugin pour corriger la faute d'orthographe précédente par la première suggestion et revenir au même endroit en faisant <espace>sp  => {{{
" Voilà mon premier plugin, à ce stade (oui, c'est pas un plugin, c'est quelques lignes dans mon .vimrc):

function! FixLastSpellingError()
 normal! mm[s1z=`m
endfunction

nnoremap <leader>sp :call FixLastSpellingError()<cr>
nnoremap <leader>sop :source %<cr>

" }}}



"En suivant les conseils de https://riptutorial.com/ vim.pdf : {{{
"2020_11_29__18_28_55

" Automatically source .vimrc after saving
" Add this to your $MYVIMRC :{{{

" Source vim configuration file whenever it is saved
if has ('autocmd')         " Remain compatible with earlier versions
    augroup Reload_Vimrc   " Group name. Always use a unique name!
    autocmd!
                           " Clear any preexisting autocommands from this group
    autocmd! BufWritePost $MYVIMRC source % | echom "Reloaded " . $MYVIMRC | redraw
    autocmd! BufWritePost $MYGVIMRC if has('gui_running') | so % | echom "Reloaded " . $MYGVIMRC | endif | redraw
    augroup END
endif " has autocmd

" Features:
"    • echom tells the user what has happened (and also logs to :messages ).
"    • $MYVIMRC and $MYGVIMRC handle platform-specific names for the configuration files,
"    • and only match the actual configuration files (ignoring copies in other directories, or a
"     fugitive://diff)
"    • has() will prevent an error if using incompatible versions, such as vim-tiny .
"    • autocmd! avoids buildup of multiple identical autocommands if this file is sourced again. (It
"     clears all commands in the named group, so the group name is important.)
" }}}

" }}}


"Numérotation des lignes: {{{
set nu

" Pratique, pour n'avoir que la ligne courante numérotée, et les autres lignes numérotée en relatif.
" Ligne affichée relative:
set relativenumber

" Pour basculer toutes les numérotations de lignes de relatif à absolu, dans toutes les fenêtres ouvertes:
nnoremap <A-r> :Windo set relativenumber!<cr>

" Pour basculer toutes les numérotations de lignes, dans toutes les fenêtres ouvertes:
nnoremap <A-n> :Windo set number!<cr>

" }}}


" Ouverture d'une fenêtre d'exploration de fichiers netrw à gauche: {{{
" Lexplore
" => marche pas... Pagrave.
" }}}


" Définition de répertoires pour les sauvegardes, les fontchiers temporaires, et les fontchiers d'annulation: {{{
" selon le conseil de https://medium.com/@Aenon/vim-swap-backup-undo-git-2bf353caa02f:
set backupdir=.backup/,~/.backup/,/tmp//
set directory=.swp/,~/.swp/,/tmp//
set undodir=.undo/,~/.undo/,/tmp//
" }}}


" Installation de vimspector {{{
"let g:vimspector_enable_mappings = 'HUMAN'
" => annulé, je préfère mon F5 tout bête
"Voici les raccourcis "humains" de vimspector:
"  nnoremap <F5>         <Plug>VimspectorContinue
"  nnoremap <leader><F5> <Plug>VimspectorLaunch
"  nnoremap <F3>         <Plug>VimspectorStop
"  nnoremap <F4>         <Plug>VimspectorRestart
"  nnoremap <F6>         <Plug>VimspectorPause
"  nnoremap <F9>         <Plug>VimspectorToggleBreakpoint
"  nnoremap <leader><F9> <Plug>VimspectorToggleConditionalBreakpoint
"  nnoremap <F8>         <Plug>VimspectorAddFunctionBreakpoint
"  nnoremap <leader><F8> <Plug>VimspectorRunToCursor
"  nnoremap <F10>        <Plug>VimspectorStepOver
"  nnoremap <F11>        <Plug>VimspectorStepInto
"  nnoremap <F12>        <Plug>VimspectorStepOut
" => du coup, il faut que je redéfinisse mes raccourcis...
" => non: quand on réussit à lancer le débogueur python, les raccourcis de vimspector fonctionnent.


" Activation des raccourcis
function! Vimspector_human_keybindings ()
 let g:vimspector_enable_mappings = 'HUMAN'
endfunction
function! Vimspector_vscode_keybindings ()
  let g:vimspector_enable_mappings = 'VISUAL_STUDIO'
endfunction
" }}}


" Faire un Esc plus ergonomique: {{{
" Té, un truc marrant pour remapper <Esc> dans vim => kj:
" https://vi.stackexchange.com/questions/16963/remap-esc-key-in-vim
" TL;DR
" It's actually nice to remap esc to the home row. Here's how you decide what to map it to: Pick a hand and roll your 4 fingers across your desktop as fast as you can in whichever direction is fastest. Use that to choose what keys to remap.
" For me it's more natural to roll from pinky to index finger. Therefore I chose to use kj. Also, I did a grep -rHin kj ~/src (recursive grep on the parent directory of all my source code) and found no matches.
" esc in insert & visual mode
inoremap kj <esc>
vnoremap kj <esc>

" Idem, de 2023 dans vimrc_spi: {{{

inoremap kj         <Esc><Right>
inoremap <Up><Left> <Esc><Right>


" " De même, faire un ii pour faire comme Insert-Insert:
" nnoremap ii         R
" " => ne fonctionne pas

" }}}

" esc in command mode
cnoremap kj <C-C>
" Note: In command mode mappings to esc run the command for some odd
" historical vi compatibility reason. We use the alternate method of
" existing which is Ctrl-C

" Note: If you do need to type a literal kj (or whatever your mapping is) just type them with 2 seconds in between. (You'll see the cursor hesitate to move after the 1st char. Wait for it to move before typing the 2nd.)
"
" You can shorten this delay by setting a shorter timeout to timeoutlen. For example, to have a timeout of 500ms add the following to your vimrc:
"
" set timeoutlen=500
"
" I have been using vim for 19 years. I was horrified when Apple updated their MacBook Pros to have a touch bar and no physical esc key. I saw a post that suggested mapping jj and jk to <Esc> and hated it. But I patiently jotted down on an index card every time it annoyed me. About 15 minutes later I reviewed my notes and came up with the TL;DR above to address the following:
"     I tend to hit esc allot when I'm not in insert mode just to "be sure" and jj would drop me 2 lines.
"     jk is a no-op (down, up) but kj is more natural for my hands.
"     I also need to use esc to exit command mode without completing the command.
" It's my hope that I can finally break my habit of hitting esc in other applications and closing windows when I'm several minutes into writing. I'd much rather insert stray kj characters than lose my work!


" Alors, je vais tenter d'adapter ça en restant AUSSI dans la position des flèches:
inoremap <silent> <Up><Left> <esc>
vnoremap <silent> <Up><Left> <esc>


if va15 == "oui" "@# début de code désactivé #############################################[[[[
" Mouais, il faut que ce soit VRAIMENT très rapide, pour être confortable:
" Il faut que ce soit VRAIMENT très rapide pour que ça soit confortable:
set timeoutlen=50
" FIXME chiotte, cela rend les combinaisons avec la touche <Leader> quasiment impossibles à faire...
" set timeoutlen=500

" En suivant le conseil de Benoît_Castang, ça fonctionnerait sans timeoutlen ultracourt:
imap kj <Esc>
cmap kj <Esc>

" Oui, MAIS avec le Leader sur espace, en mode insertion, c'était infernal... @#à résoudre.
" }}}
endif "@# fin de code désactivé #############################################]]]]


" Retour à la ligne visuel (wrap): {{{

" le plus souvent, le wrap m'emmerdoie, pour des sources bien indentés notamment; donc j'ôte:
set nowrap

"mais des fois, il rend service..
set wrap

" pour ne pas wrapper en coupant les mots:
set linebreak
" pour wrapper en respectant l'indentation:
set breakindent

" Idem, de 2023 dans vimrc_spi: {{{

" Pour les word wraps:
" set linebreak
set formatoptions=1
set lbr
set showbreak=\\__\ \ \ \ \ \ \ \

" Pour montrer les tabulations (superutile pour les Heredocs):
set list
set listchars=tab:²²
" set listchars=eol:$

" }}}


" Bascule le retour à la ligne visuel (wrap) avec le raccourci Alt-Z (comme vsc...): {{{
noremap  <A-z>           :set invwrap<cr>
inoremap <A-z> <Esc>mz   :set invwrap<cr>`za

" Avec majuscule en plus: ça le fait dans toutes les fenêtres:
noremap  <S-A-z>         :Windofast set invwrap<cr>
inoremap <S-A-z>    <Esc>:Windofast set invwrap<cr>a

" Idem, de 2023 dans vimrc_spi: {{{

" Retour à la ligne comme chez vsc:
"nnoremap z      mz:windo set wrap!<cr>`z
"inoremap z <esc>mz:windo set wrap!<cr>`za
"" Idem, dans gvim:
"nnoremap ú        mz:windo set wrap!<cr>`z
"inoremap ú   <esc>mz:windo set wrap!<cr>`za
"
"=> plutôt, sans windo:
" Retour à la ligne comme chez vsc:
nnoremap z      mz:set wrap!<cr>`z
inoremap z <esc>mz:set wrap!<cr>`za
" Idem, dans gvim:
nnoremap ú        mz:set wrap!<cr>`z
inoremap ú   <esc>mz:set wrap!<cr>`za


" Plutôt avec <leader> W (pour Wrapper:
nnoremap <leader>w      :windo set wrap!<cr>
inoremap <leader>w <esc>:windo set wrap!<cr>a


" }}}
" }}}

" }}}


" Cohabitation avec un multiplexeur de terminaux, comme screen ou tmux: {{{

" 2023_10_01__20_32_50
" Alors, maintenant, pour vivre avec tmux (selon config/.vim/pack/plugins/start/vim-tmux-navigator/README.md): {{{

" Je colle ici le contenu du greffon: {{{
" 2023_08_28__12_36_18

" Maps <C-h/j/k/l> to switch vim splits in the given direction. If there are
" no more windows in that direction, forwards the operation to tmux.
" Additionally, <C-\> toggles between last active vim splits/tmux panes.

if exists("g:loaded_tmux_navigator") || &cp || v:version < 700
  " finish " commenté: ça arrêtait tout mon .vimrc... _______________TODO__________________2023_10_03__21_53_23
endif
let g:loaded_tmux_navigator = 1

function! s:VimNavigate(direction)
  try
    execute 'wincmd ' . a:direction
  catch
    echohl ErrorMsg | echo 'E11: Invalid in command-line window; <CR> executes, CTRL-C quits: wincmd k' | echohl None
  endtry
endfunction

if !get(g:, 'tmux_navigator_no_mappings', 0)
  noremap <silent> <A-h>     :<C-U>TmuxNavigateLeft<cr>
  noremap <silent> <A-j>     :<C-U>TmuxNavigateDown<cr>
  noremap <silent> <A-k>     :<C-U>TmuxNavigateUp<cr>
  noremap <silent> <A-l>     :<C-U>TmuxNavigateRight<cr>
"   noremap <silent> <A-\> :<C-U>TmuxNavigatePrevious<cr>
  noremap <silent> <A-Left>  :<C-U>TmuxNavigateLeft<cr>
  noremap <silent> <A-Down>  :<C-U>TmuxNavigateDown<cr>
  noremap <silent> <A-Up>    :<C-U>TmuxNavigateUp<cr>
  noremap <silent> <A-Right> :<C-U>TmuxNavigateRight<cr>
" 2023_11_29__22_02_12 Mince, ces 4 dernières lignes ne fonctionnent pas; remplaçons les A-* par les codes capturés par vim à l'intérieur d'une session tmux, avec C-V:
  noremap <silent> h  :<C-U>TmuxNavigateLeft<cr>
  noremap <silent> j  :<C-U>TmuxNavigateDown<cr>
  noremap <silent> k  :<C-U>TmuxNavigateUp<cr>
  noremap <silent> l  :<C-U>TmuxNavigateRight<cr>
endif

if empty($TMUX)
  command! TmuxNavigateLeft call s:VimNavigate('h')
  command! TmuxNavigateDown call s:VimNavigate('j')
  command! TmuxNavigateUp call s:VimNavigate('k')
  command! TmuxNavigateRight call s:VimNavigate('l')
  command! TmuxNavigatePrevious call s:VimNavigate('p')
  " finish " commenté: ça arrêtait tout mon .vimrc... _______________TODO__________________2023_10_03__21_53_23
endif
let salut="coucouroucoucou"

command! TmuxNavigateLeft call s:TmuxAwareNavigate('h')
command! TmuxNavigateDown call s:TmuxAwareNavigate('j')
command! TmuxNavigateUp call s:TmuxAwareNavigate('k')
command! TmuxNavigateRight call s:TmuxAwareNavigate('l')
command! TmuxNavigatePrevious call s:TmuxAwareNavigate('p')

if !exists("g:tmux_navigator_save_on_switch")
  let g:tmux_navigator_save_on_switch = 0
endif

if !exists("g:tmux_navigator_disable_when_zoomed")
  let g:tmux_navigator_disable_when_zoomed = 0
endif

if !exists("g:tmux_navigator_preserve_zoom")
  let g:tmux_navigator_preserve_zoom = 0
endif

if !exists("g:tmux_navigator_no_wrap")
  let g:tmux_navigator_no_wrap = 0
endif

let s:pane_position_from_direction = {'h': 'left', 'j': 'bottom', 'k': 'top', 'l': 'right'}

function! s:TmuxOrTmateExecutable()
  return (match($TMUX, 'tmate') != -1 ? 'tmate' : 'tmux')
endfunction

function! s:TmuxVimPaneIsZoomed()
  return s:TmuxCommand("display-message -p '#{window_zoomed_flag}'") == 1
endfunction

function! s:TmuxSocket()
  " The socket path is the first value in the comma-separated list of $TMUX.
  return split($TMUX, ',')[0]
endfunction

function! s:TmuxCommand(args)
  let cmd = s:TmuxOrTmateExecutable() . ' -S ' . s:TmuxSocket() . ' ' . a:args
  let l:x=&shellcmdflag
  let &shellcmdflag='-c'
  let retval=system(cmd)
  let &shellcmdflag=l:x
  return retval
endfunction

function! s:TmuxNavigatorProcessList()
  echo s:TmuxCommand("run-shell 'ps -o state= -o comm= -t ''''#{pane_tty}'''''")
endfunction
command! TmuxNavigatorProcessList call s:TmuxNavigatorProcessList()

let s:tmux_is_last_pane = 0
augroup tmux_navigator
  au!
  autocmd WinEnter * let s:tmux_is_last_pane = 0
augroup END

function! s:NeedsVitalityRedraw()
  return exists('g:loaded_vitality') && v:version < 704 && !has("patch481")
endfunction

function! s:ShouldForwardNavigationBackToTmux(tmux_last_pane, at_tab_page_edge)
  if g:tmux_navigator_disable_when_zoomed && s:TmuxVimPaneIsZoomed()
    return 0
  endif
  return a:tmux_last_pane || a:at_tab_page_edge
endfunction

function! s:TmuxAwareNavigate(direction)
  let nr = winnr()
  let tmux_last_pane = (a:direction == 'p' && s:tmux_is_last_pane)
  if !tmux_last_pane
    call s:VimNavigate(a:direction)
  endif
  let at_tab_page_edge = (nr == winnr())
  " Forward the switch panes command to tmux if:
  " a) we're toggling between the last tmux pane;
  " b) we tried switching windows in vim but it didn't have effect.
  if s:ShouldForwardNavigationBackToTmux(tmux_last_pane, at_tab_page_edge)
    if g:tmux_navigator_save_on_switch == 1
      try
        update " save the active buffer. See :help update
      catch /^Vim\%((\a\+)\)\=:E32/ " catches the no file name error
      endtry
    elseif g:tmux_navigator_save_on_switch == 2
      try
        wall " save all the buffers. See :help wall
      catch /^Vim\%((\a\+)\)\=:E141/ " catches the no file name error
      endtry
    endif
    let args = 'select-pane -t ' . shellescape($TMUX_PANE) . ' -' . tr(a:direction, 'phjkl', 'lLDUR')
    if g:tmux_navigator_preserve_zoom == 1
      let l:args .= ' -Z'
    endif
    if g:tmux_navigator_no_wrap == 1
      let args = 'if -F "#{pane_at_' . s:pane_position_from_direction[a:direction] . '}" "" "' . args . '"'
    endif
    silent call s:TmuxCommand(args)
    if s:NeedsVitalityRedraw()
      redraw!
    endif
    let s:tmux_is_last_pane = 1
  else
    let s:tmux_is_last_pane = 0
  endif
endfunction


" }}}

" 2023_08_28__12_36_18
let g:tmux_navigator_no_mappings = 1
if empty($TMUX)
 " RAS...
else
 noremap <silent> <A-Left>  :<C-U>TmuxNavigateLeft<cr>
 noremap <silent> <A-Down>  :<C-U>TmuxNavigateDown<cr>
 noremap <silent> <A-Up>    :<C-U>TmuxNavigateUp<cr>
 noremap <silent> <A-Right> :<C-U>TmuxNavigateRight<cr>
" noremap <silent> {Previous-Mapping} :<C-U>TmuxNavigatePrevious<cr>
 noremap <silent> <A-h>     :<C-U>TmuxNavigateLeft<cr>
 noremap <silent> <A-j>     :<C-U>TmuxNavigateDown<cr>
 noremap <silent> <A-k>     :<C-U>TmuxNavigateUp<cr>
 noremap <silent> <A-l>     :<C-U>TmuxNavigateRight<cr>
" *Note* Each instance of `{Left-Mapping}` or `{Down-Mapping}` must be replaced
" in the above code with the desired mapping. Ie, the mapping for `<ctrl-h>` =>
" Left would be created with `noremap <silent> <c-h> :<C-U>TmuxNavigateLeft<cr>`.
endif

" }}}
" # => ça ne fonctionne point...


" " Screen-ify an external command.
" function InScreen(command)
"   return g:GNU_Screen_used ? 'screen '.a:command : a:command
" endfunction
" Test:
" map <C-j> :r !echo "coucou"<CR>

" }}}



" Surround the visual selection in parenthesis/brackets/etc.: {{{
vnoremap ( <esc>`>a)<esc>`<i(<esc>
" vnoremap ) <esc>`>a)<esc>`<i(<esc>
vnoremap [ <esc>`>a]<esc>`<i[<esc>
vnoremap ] <esc>`>a]<esc>`<i[<esc>
vnoremap { <esc>`>a}<esc>`<i{<esc>
" vnoremap } <esc>`>a}<esc>`<i{<esc>
vnoremap " <esc>`>a"<esc>`<i"<esc>
vnoremap ' <esc>`>a'<esc>`<i'<esc>
vnoremap ` <esc>`>a`<esc>`<i`<esc>
" => invalidé ) et }, pour pouvoir continuer à sélectionner une phrase ou un paragraphe

" FIXME double emploi avec ce qui est horodaté là?  2023_10_09__23_58_39 " Pour entourer une sélection avec des {}:
" vnoremap { yc{}<Esc>P
" vnoremap } yc{}<Esc>P
" FIXME double emploi avec ce qui est horodaté là?  2023_10_09__23_58_39

" }}}

" Une macro pour entourer de parenthèses la prochaine variable shell qui ne l'est pas déjà:{{{

" let @a= '/kulviw}'
" (ne fonctionne pas)


" 2023_12_24__13_34_53 mince, pas vu...
" Refait, de tête:
nnoremap <C-F12>        /\$[A-Za-z]<cr> i{<esc>ea}<esc>
inoremap <C-F12> <esc>mz/\$[A-Za-z]<cr> i{<esc>ea}<esc>'za

" Idem, de 2023 dans vimrc_spi: {{{
" TODO voir le .vimrc chez Spie, où ça fonctionne correctement
" " Pour entourer des $variables d'environnement par des {}:
" nnoremap  <C-F12>      /\$[a-zA-Z]<cr>li{<Esc>lea}<Esc>
" }}}
" }}}


" Pour ouvrir une URL avec gx: (pas la peine, ça fonctionne sans ceci) {{{
" function! OpenURLUnderCursor()
"   let s:uri = expand('<cWORD>')
"   let s:uri = substitute(s:uri, '?', '\\?', '')
"   let s:uri = shellescape(s:uri, 1)
"   if s:uri != ''
"     silent exec "!open '".s:uri."'"
"     redraw!
"   endif
" endfunction
" nnoremap gx :call OpenURLUnderCursor()<CR>
"
" " If you’re on Linux, try changing !open to !gio.

" }}}




" Je remets tous mes greffons par ici: {{{

" Pour éditer rapidos du HTML et CSS, plugin https://github.com/mattn/emmet-vim/:
" Plugin 'mattn/emmet-vim' (non, marche pas ainsi)


" vim-plug:
" call plug#begin('~/.vim/plugged')
" call plug#begin()
"   Plug 'preservim/nerdtree'
"   Plug 'iberianpig/ranger-explorer.vim'
" call plug#end()

" paquets vim (pack ages):
packadd! vimspector
packadd! vim-tmux-navigator





" }}}
let salut="coucou16"
endif "@# fin de code désactivé #############################################]]]]

if va17 == "oui" "@# début de code désactivé #############################################[[[[
" Raccourcis clavier pour les greffons: {{{

" NERDTree: {{{
" A pour Arborescence
noremap <leader>a   :NERDTreeFocus<cr>
" let NERDTreeMapCloseChildren='h'
let NERDTreeMapCloseDir='h'
" let NERDTreeMapUpdir='h'
" let NERDTreeMapActivateNode='l'
let NERDTreeShowHidden=1
let NERDTreeMapPreview='l'
let NERDTreeMapActivateNode='l'
" => ça ne fonctionne pas...

" Exit Vim if NERDTree is the only window remaining in the only tab.
autocmd BufEnter * if tabpagenr('$') == 1 && winnr('$') == 1 && exists('b:NERDTree') && b:NERDTree.isTabTree() | quit | endif
" Close the tab if NERDTree is the only window remaining in it.
autocmd BufEnter * if winnr('$') == 1 && exists('b:NERDTree') && b:NERDTree.isTabTree() | quit | endif

" Pour éviter le message de NERDTree pour les gros répertoires:
let g:NERDTreeNotificationThreshold = 5000

" }}}

" }}}



" Pour ouvrir avec le navigateur par défaut avec gx {{{
" let g:netrw_http_cmd  = "$BROWSER"
" => ez, ça ne fonctionne pas, ça ouvre aussi un truc tmp
" nmap gx :!open <c-r><c-a><cr>

" }}}
let salut="coucou17"
endif "@# fin de code désactivé #############################################]]]]

if va18 == "oui" "@# début de code désactivé #############################################[[[[
" Bonjour matinal: {{{
command! Bonjour :r !echo -e "________________________________________________________________________________\n$(date +\%d_\%m_\%Y__\%T | sed -e 's/\:/_/g')                    $HOSTNAME\n$(acpi -i)"
" nnoremap <c-b>      :Bonjour<cr>o
" vnoremap <c-b>      :Bonjour<cr>
" cnoremap <c-b>      :Bonjour<cr>
" \_ annulé, cata, ça mettait la date quand on faisait PageUp...
inoremap <c-b> <Esc>:Bonjour<cr>o

" }}}

let salut="Coucou final, .vimrc chargé!"
endif "@# fin de code désactivé #############################################]]]]

" Poubelle: {{{

" Un vestige inconnu: {{{
" let c='a'
" while c <= 'z'
"   exec "set <A-".c.">=\e".c
"   exec "imap \e".c." <A-".c.">"
"   let c = nr2char(1+char2nr(c))
" endw
" }}}

" Changed default required by SuSE security team--be aware if enabling this
" that it potentially can open for malicious users to do harmful things.
set modelines=0


" get easier to use and more user friendly vim defaults
" /etc/vimrc ends here

" }}}
" echo salut



" Faire un redo qui soit plus proche du undo (U) => È{{{
" Pour Refaire à côté de Undo:
" nnoremap è :redo<CR>
" => ach non, ça bloque Alt-H...
" Bof...
" unmap è
" Ah, avec _:
"                                                => _
nnoremap _ :redo<CR>
" }}}


" Le paquet simple_highlighting.vim ne semble pas avoir ses raccourcis clavier qui fonctionnent: je les mets ici:{{{
" Ah non... en fait, ce n'est pas un paquet, mais un script; donc je le source, plutôt:
source ~/.vim/pack/plugins/start/simple_highlighting/simple_highlighting.vim
" Je refais un mappage moins ch!ant, avec un delay moindre pour éviter d'utiliser la touche Leader:
nnoremap <A-!> <silent> :Windofast<C-U> exe "call HighlightAdd(".v:count.",'\\<".expand('<cword>')."\\>')"<CR>


" 2024_02_14__12_07_30 
" D'après https://vi.stackexchange.com/questions/20077/automatically-highlight-all-occurrences-of-the-selected-text-in-visual-mode :

" highlight the visual selection after pressing enter.
xnoremap <silent> <cr> "*y:silent! let searchTerm = '\V'.substitute(escape(@*, '\/'), "\n", '\\n', "g") <bar> let @/ = searchTerm <bar> echo '/'.@/ <bar> call histadd("search", searchTerm) <bar> set hls<cr>

" Give ctrl+c a job when it is otherwise being wasted!
" Now it toggles `hlsearch` while in NORMAL mode:
nnoremap <silent> <c-c> :if (&hlsearch == 1) \| set nohlsearch \| else \| set hlsearch \| endif<cr>

" Put <enter> to work too! Otherwise <enter> moves to the next line, which we can
" already do by pressing the <j> key, which is a waste of keys!

" Be useful <enter> key!:
" nnoremap <silent> <cr> :let searchTerm = '\v<'.expand("<cword>").'>' <bar> let @/ = searchTerm <bar> echo '/'.@/ <bar> call histadd("search", searchTerm) <bar> set hls<cr>
" Tentative (vaine jusqu'ici) d'amélioration:
" nnoremap <silent> <cr> :let searchTerm = '\v<'.expand("<cword>").'>' <bar> let @/ = searchTerm <bar> 0 echowindow '/'.@/ <bar> call Windofast histadd("search", searchTerm) <bar> set hls<cr>
nnoremap <silent> <cr> :let searchTerm = '\v<'.expand("<cword>").'>' <bar> let @/ = searchTerm <bar> 0 echowindow '/'.@/ <bar> call histadd("search", searchTerm) <bar> set hls<cr>

" }}}

" Tiens, faire un * qui aille chercher dans toutes les fenêtres l'occurrence suivante du mot sous le curseur, ça ne serait pas si bête:{{{

" nnoremap <*> :Windo *<cr>
" \_ marche pas...
" _______________TODO__________________

"}}}



" Pour se déplacer verticalement dans un paragraphe wrappé:{{{
let g:move_vertically_in_wrapped_paragraph = 1
function! Move_vertically_in_wrapped_paragraph()
  if g:move_vertically_in_wrapped_paragraph == 1
    nmap <expr> k      (v:count == 0 ? 'gk' : 'k')
    nmap <expr> j      (v:count == 0 ? 'gj' : 'j')
    nmap <expr> <Up>   (v:count == 0 ? 'gk' : 'k')
    nmap <expr> <Down> (v:count == 0 ? 'gj' : 'j')
    vmap <expr> <Up>   (v:count == 0 ? 'gk' : 'k')
    vmap <expr> <Down> (v:count == 0 ? 'gj' : 'j')
  else
    nmap <expr> k      'k'
    nmap <expr> j      'j'
    nmap <expr> <Up>   'k'
    nmap <expr> <Down> 'j'
    vmap <expr> <Up>   'k'
    vmap <expr> <Down> 'j'
  endif
endfunction
function! Toggle_move_vertically_in_wrapped_paragraph()
  if g:move_vertically_in_wrapped_paragraph == 1
    let g:move_vertically_in_wrapped_paragraph = 0
    echom "JK keys move normally from line to line"
  else
    let g:move_vertically_in_wrapped_paragraph = 1
    echom "JK keys move inside wrapped paragraphs"
  endif
  call Move_vertically_in_wrapped_paragraph()
endfunction
" Basculer ce comportement (parfois désiré, parfois pas) par Alt-W (comme wrappé):
nnoremap <a-w> :call Toggle_move_vertically_in_wrapped_paragraph()<cr>
" }}}

" Un thème de couleurs un peu plus à la mode:
" colorscheme evening


" Différents trucs, venant de vimrc_spi notamment: TODO à remettre en ordre:

" Pour comparer deux lignes successives: {{{
function! DiffLineWithNext()
  " let f1=tempname()
  " let f2=tempname()
  let f1="/tmp/tmp_vim_line1"
  let f2="/tmp/tmp_vim_line2"
  exec ".write! " . f1
  exec ".+1write! " . f2
  " :!bash diff f1 f2<cr>
  "TODO faire une condition, ne continuer que si f1 et f2 diffèrent
  " faire ça avec une fonction interne de comparaison de vim?
  exec "tabedit " . f1
  exec "diffsplit " . f2
  resize 1
  windo set colorcolumn=
  windo set nocursorcolumn
  windo set nocursorline
endfunction
nnoremap <F4>      mz:call DiffLineWithNext()<cr>`z
inoremap <F4> <Esc>mz:call DiffLineWithNext()<cr>`za
" }}}

" Pour mettre des espaces en indentant, et non point des tabulations:
set expandtab

" Pour pouvoir ouvrir tout plein d'onglets:
set tabpagemax=100

" Couleur différente des TODO et FIXME pour les recherches:
:hi Search guibg=gray guifg=white


" Un mode de couleur un peu reposant:
" colorscheme evening
" Bah non, ça pue dans gvim, en fait

" Comme ça, c'est pas mal pour le bash
set noautoindent noexpandtab tabstop=2 shiftwidth=2

" Montre la colonne 80
set colorcolumn=80
" Y mettre une couleur un peu moins aggressive que le rouge par défaut (surtout chouette pour le Cobol):
" highlight ColorColumn term=reverse cterm=reverse ctermbg=gray cterm=bold
" highlight ColorColumn term=reverse cterm=reverse ctermbg=gray cterm=bold guifg=white guibg=yellow gui=bold
" \_ bof, c'est dégueu, je préfère configurer ça seulement pour les fontchiers Cobol, cf. au des *.cbl


" Ne pas afficher la barre de menus dans gvim;
" c'est pour pouvoir avoir <a-L> qui aille vers la fenêtre de gauche,
" au lieu de faire tomber un menu:
set guioptions-=T
set guioptions-=m

" __________***_JEANSUILA_***__________ <= tag n'existant QUE deux fois ####### ******** JEANSUILA_INSTANT_PRÉSENT ########################################################################################################################################
" TODO FIXME !!
" o # BkSp marche pas en mode insertion!!! => au_quai => non, PAS au_quai!

" Fini: {{{

" x # ^W marche pas en mode insertion!!! => dans gvim, ça fonctionne; mais pas dans vim => ayé, 2023_09_06__18_40_13, ça fonctionne (pourquoi?...)
" x è et é merdoient en mode insertion!!! => ééèè => au_quai
" x # BkSp marche pas en mode insertion!!! => au_quai

" set foldmarker=[[[[,]]]]

" }}}


" # let salut="coucou6"
" # endif "@# fin de code désactivé #############################################]]]]


" Terrain de jeu pour des essais: {{{
" https://loremipsum.io/generator/?n=5&t=p
" set syLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Dictumst quisque sagittis purus sit amet volutpat consequat mauris nunc. Risus in hendrerit gravida rutrum quisque non tellus orci. Quam viverra orci sagittis eu volutpat odio facilisis mauris sit. Mauris augue neque gravida in fermentum. Blandit libero volutpat sed cras ornare arcu dui vivamus arcu. Senectus et netus et malesuada. Proin gravida hendrerit lectus a. Dui ut ornare lectus sit amet est placerat in. Ut faucibus pulvinar elementum integer. Massa massa ultricies mi quis hendrerit dolor. Dui nunc mattis enim ut tellus elementum sagittis. Risus commodo viverra maecenas accumsan lacus vel facilisis volutpat est. Cras semper auctor neque vitae tempus. Neque egestas congue quisque egestas diam in arcu cursus.
" Lorem ipsum
" Lorem ipsum dol()or sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Dictumst quisque sagittis purus sit amet volutpat consequat mauris nunc. Risus in hendrerit gravida rutrum quisque non tellus orci. Quam viverra orci sagittis eu volutpat odio facilisis mauris sit. Mauris augue neque gravida in fermentum. Blandit libero volutpat sed cras ornare arcu dui vivamus arcu. Senectus et netus et malesuada. Proin gravida hendrerit lectus a. Dui ut ornare lectus sit amet est placerat in. Ut faucibus pulvinar elementum integer. Massa massa ultricies mi quis hendrerit dolor. Dui nunc mattis enim ut tellus elementum sagittis. Risus commodo viverra maecenas accumsan lacus vel facilisis volutpat est. Cras semper auctor neque vitae tempus. Neque egestas congue[ quisque egestas diam in arcu cursus.
" em ipsum dol()or sit amet, consect
" Lorem ipsum

"32
"31

" }}}


syntax on
syntax enable

" _______________TODO__________________ 

" Problèmes à résoudre:
" o BkSp ne fonctionne pas en mode insertion
" x Caps_Lock ne fonctionne plus (pas que dans vim)
" x Alt-H ne va pas à gauche
" x è en mode insertion va vers la gauche
" o cohabitation avec tmux (...)



" à réordonner où il convient:{{{

" Un raccourci pratique pour basculer la maximisation d'une fenêtre en hauteur:{{{

" if va18 == "zb" "@# début de code désactivé #############################################[[[[
" " Première solution:{{{
" " https://vim.fandom.com/wiki/Maximize_window_and_return_to_previous_split_structure
" 
" " nnoremap <C-W>O :call MaximizeToggle()<CR>
" " nnoremap <C-W>o :call MaximizeToggle()<CR>
" " nnoremap <C-W><C-O> :call MaximizeToggle()<CR>
" " \_ quelque chose de plus ergonomique:
" " nnoremap <A-_> <C-W>_
" nnoremap <A-_> :call MaximizeToggle()<CR>
" 
" function! MaximizeToggle()
  " if exists("s:maximize_session")
    " exec "source " . s:maximize_session
    " call delete(s:maximize_session)
    " unlet s:maximize_session
    " let &hidden=s:maximize_hidden_save
    " unlet s:maximize_hidden_save
  " else
    " let s:maximize_hidden_save = &hidden
    " let s:maximize_session = tempname()
    " set hidden
    " exec "mksession! " . s:maximize_session
    " only
  " endif
" endfunction
" 
" " }}}
" endif "@# fin de code désactivé #############################################]]]]

" Seconde solution:{{{

function! ToggleZoom(zoom, vertical)
  if exists("t:restore_zoom") && (a:zoom == v:true || t:restore_zoom.win != winnr())
      exec t:restore_zoom.cmd
      unlet t:restore_zoom
  elseif a:zoom
      let t:restore_zoom = { 'win': winnr(), 'cmd': winrestcmd() }
      if (a:vertical == v:false)
          exec "normal \<C-W>\|\<C-W>_"
      else
          " \_ je préfère une maximisation verticale seulement (question de goût):
          exec "normal \<C-W>_"
      endif
  endif
endfunction

augroup restorezoom
    au WinEnter * silent! :call ToggleZoom(v:false, v:false)
augroup END

" Raccourci initial:
" nnoremap <silent> <Leader>+ :call ToggleZoom(v:true)<CR>
" Raccourcis pour maximiser verticalement par défaut, et en tous sens avec shift:
nnoremap <A-_>      :call ToggleZoom(v:true,  v:true)<CR>
inoremap <A-_> <Esc>:call ToggleZoom(v:true,  v:true)<CR>a

nnoremap <A-8> :call ToggleZoom(v:true, v:false)<CR>
inoremap <A-8> :call ToggleZoom(v:true, v:false)<CR>a

" }}}
" }}}

" Des trucs qui ne tournent pas encore, qu'il faut mettre au point: {{{

" Pour faire un * sur un mot et qu'on y aille dans toutes les fenêtres, en y restant dans la fenêtre courante:
" map ª :silent! *N :Windofast n<cr>
" => marche pô... 
nnoremap ç :normal! *N :Windo n<cr>



" }}}

" }}}

" poubelle:{{{

" set syntax=vim "Juste pour déboguer le présent féchier! Commenter dès que c'est fini.

" 2024_03_28__11_51_07 juste le temps de faire le diff avec vimrc_spi:{{{
" syntax off
" set foldmethod=diff

" }}}
" _______________TODO__________________2023_10_03__21_53_23

"}}}

" vimrc_spi: voir toutes ces étiquettes, et résoudre les choses, tester ce qui est le mieux, etc.
